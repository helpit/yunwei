<HTML>
<HEAD>
   <TITLE>Robert's Perl Tutorial</TITLE>
   <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
   <META NAME="description" CONTENT="This Perl tutorial assumes the prospective Perl hacker has no  prior knowledge of programming languages, but is able to differentiate between a computer and a toaster.">
   <META NAME="keywords" CONTENT="perl for win32, perl, tutorial, NT, scripting languages, linux, unix, activeperl, learn, cbt, training">
   <META NAME="author" CONTENT="Robert Pepper">
   <META NAME="copyright" CONTENT="All rights reserved.  Reproduction in whole or part prohibited.">
   <META NAME="location" CONTENT="http://www.netcat.co.uk/rob/perl/win32perltut.html">
   <META NAME="joke" CONTENT="What do you call a woman on the horizon?  .  ">
</HEAD>
<BODY BGCOLOR="#FFFFFF">

<CENTER>
<TABLE BORDER=2 CELLSPACING=4 CELLPADDING=4 BGCOLOR="#CCFFCC">
<TR><TD ALIGN="center">
<H1><FONT COLOR="#0066FF">Robert's Perl Tutorial</FONT></H1>
<FONT FACE="Arial">Version 4.1.1</FONT>
</TD></TR>
</TABLE>
<BR>
The last hack was made on: 20th April 1999<BR>
<SMALL>so Henry can concentrate</SMALL><P>
<B><FONT COLOR="#FF0000">THIS DOCUMENT IS COPYRIGHTED.<BR> 
Reproduction in whole or part is prohibited.  Please email me at
<A HREF="mailto:robert@netcat.co.uk">robert@netcat.co.uk</A> if you want to use this information anywhere.
</FONT></B><P>
<I>The location of this document is<BR>http://www.netcat.co.uk/rob/perl/win32perltut.html</I>
</CENTER>

<BR><A NAME='1-Introduction'></A> <H1>Introduction</H1>

<BR><A NAME='2-Thistutorialis'></A> <H2>This tutorial is...</H2>

<P>
A basic Perl course primarily for use on Win32 platforms.  It assumes that the reader knows nothing of programming whatsoever, but needs a solid grounding for further work.  After you finish this course you'll be ready to specialise in CGI, sysadmin or whatever you want to do with Perl.
</P>




<BR><A NAME='3-Thistutorialisnot'></A> <H2>This tutorial is not...</H2>




<P>
<UL>
<LI>
<B>A reference manual.</B> You won't find all the regex stuff under Regex. I think
it's more fun to learn the basics then add little extras along the way.
Keeps you awake, and it is a good excuse for not organising it better.</LI>
<LI><B>A FAQ.</B></LI>
<LI><B>Politically correct.</B></LI>
<LI><B>Complete.</B> Please don't finish the course and assume you know all there is to know about Perl.  There is certainly enough here to get you started, but consider the contents of this course as the tip of the iceberg.  Except maybe a little warmer.</LI>
<LI><B>Eror three.</B></LI>
</UL>
</P>

<A NAME='toc'></A>
<BR><A NAME='5-TheTableofContents'></A> <H2>The Table of Contents</H2>

I've had a fair amount of requests for a ToC, so here it is:
<TOCHERE>

<HR WIDTH='50%'>
<DL><DL><BR><B><A HREF='#1-Introduction'>Introduction</A><BR>
</B><DL><A HREF='#2-Thistutorialis'>This tutorial is...</A><BR>
<A HREF='#3-Thistutorialisnot'>This tutorial is not...</A><BR>
<A HREF='#4-HowtoUse'>How to Use...</A><BR>
<A HREF='#5-TheTableofContents'>The Table of Contents</A><BR>
<A HREF='#6-ConventionsusedinthisTutorial'>Conventions used in this Tutorial</A><BR>
<A HREF='#7-Whatyouneedtoknow'>What you need to know</A><BR>
<A HREF='#8-Useofthisdocument'>Use of this document</A><BR>
<DL><A HREF='#9-PersonalPrintouts'>Personal Printouts</A><BR>
<A HREF='#10-Intranetusage'>Intranet usage</A><BR>
<A HREF='#11-Mirroring'>Mirroring</A><BR>
<A HREF='#12-Translations'>Translations</A><BR>
</DL></DL><BR><B><A HREF='#13-AShortIntroductionToPerl'>A Short Introduction To Perl</A><BR>
</B><DL><A HREF='#14-WhatisPerl'>What is Perl?</A><BR>
<A HREF='#15-WhatisActivePerlAretheotherPerlsinactive'>What is ActivePerl?  Are the other Perls inactive?</A><BR>
<A HREF='#16-CanIrunPerlonmycomputer'>Can I run Perl on my computer?</A><BR>
<A HREF='#17-WhatcanIdowithPerl'>What can I do with Perl ?</A><BR>
<DL><A HREF='#18-TheInternet'>The Internet</A><BR>
<A HREF='#19-SystemsAdministration'>Systems Administration</A><BR>
</DL><A HREF='#20-WhatcantIdowithPerl'>What can't I do with Perl ?</A><BR>
<A HREF='#21-Support'>Support</A><BR>
</DL><BR><B><A HREF='#22-Setup'>Setup</A><BR>
</B><DL><A HREF='#23-1GettingtheSoftware'>1. Getting the Software</A><BR>
<A HREF='#24-2Installation'>2. Installation</A><BR>
<A HREF='#25-3TestingYourFirstPerlScript'>3. Testing - Your First Perl Script</A><BR>
</DL><BR><B><A HREF='#26-TheTutorialTheJourneyBegins'>The Tutorial: The Journey Begins</A><BR>
</B><DL><A HREF='#27-YourFirstTime'>Your First Time</A><BR>
<A HREF='#28-Whatifitdoesnt'>What if it doesn't...?</A><BR>
<A HREF='#29-Assumingitsnowallright'>Assuming it's now all right...</A><BR>
<A HREF='#30-Shebang'>Shebang</A><BR>
<A HREF='#31-Variables'>Variables</A><BR>
<DL><A HREF='#32-Scalars'>Scalars</A><BR>
<A HREF='#33-areGoodThings'>$ % @ are Good Things</A><BR>
<A HREF='#34-Typing'>Typing</A><BR>
<A HREF='#35-VariableInterpolation'>Variable Interpolation</A><BR>
<A HREF='#36-ChangingVariables'>Changing Variables</A><BR>
<DL><A HREF='#37-Autodeincrements'>Auto(de|in)crements</A><BR>
</DL></DL><A HREF='#38-Escaping'>Escaping</A><BR>
<A HREF='#39-ContextAboutPerland'>Context: About Perl and @^$%&~`/?</A><BR>
<A HREF='#40-StringsandIncrements'>Strings and Increments</A><BR>
<A HREF='#41-PrintAListOperator'>Print: A List Operator</A><BR>
<A HREF='#42-SubroutinesAFirstLook'>Subroutines -- A First Look</A><BR>
<A HREF='#43-Comments'>Comments</A><BR>
</DL><BR><B><A HREF='#44-Comparisons'>Comparisons</A><BR>
</B><DL><A HREF='#45-Aniffystart'>An iffy start</A><BR>
<A HREF='#46-TheTruthAccordingtoPerl'>The Truth According to Perl</A><BR>
<A HREF='#47-EqualityandPerl'>Equality and Perl</A><BR>
<DL><A HREF='#48-AllEqualityisNotEqualNumericversusString'>All Equality is Not Equal: Numeric versus String</A><BR>
</DL><A HREF='#49-AninterludeThePerlMotto'>An interlude -- The Perl Motto</A><BR>
<A HREF='#50-TheComparisonOperatorsListed'>The Comparison Operators Listed</A><BR>
<DL><A HREF='#51-TheGoldenRuleofComparisons'>The Golden Rule of Comparisons</A><BR>
</DL><A HREF='#52-MoreAboutIfMultiples'>More About If: Multiples</A><BR>
<DL><A HREF='#53-elsif'>elsif</A><BR>
</DL></DL><BR><B><A HREF='#54-UserInput'>User Input</A><BR>
</B><DL><A HREF='#55-STDINandotherfilehandles'>STDIN and other filehandles</A><BR>
<A HREF='#56-Chop'>Chop</A><BR>
<DL><A HREF='#57-SafeChoppingwithChomp'>Safe Chopping with Chomp</A><BR>
</DL></DL><BR><B><A HREF='#58-Arrays'>Arrays</A><BR>
</B><DL><A HREF='#59-Listsherdswhatarearrays'>Lists, herds -- what are arrays?</A><BR>
<DL><A HREF='#60-BasicArrayWork'>Basic Array Work</A><BR>
</DL><A HREF='#61-ElementsofArrays'>Elements of Arrays</A><BR>
<DL><A HREF='#62-Howtorefertoelementsofanarray'>How to refer to elements of an array</A><BR>
</DL><A HREF='#63-Morewaystoaccessarrays'>More ways to access arrays</A><BR>
<A HREF='#64-ForLoops'>For Loops</A><BR>
<DL><A HREF='#65-AforLoopdemonstrated'>A for Loop demonstrated</A><BR>
<A HREF='#66-Forloopswiththerangeoperator'>For loops with .. , the range operator</A><BR>
<A HREF='#67-foreach'>foreach</A><BR>
<A HREF='#68-Theinfamous_'>The infamous $_</A><BR>
<A HREF='#69-APrematureEndtoyourloop'>A Premature End to your loop</A><BR>
<DL><A HREF='#70-AlittlemorecontrolovertheprematureendingLabels'>A little more control over the premature ending: Labels</A><BR>
</DL></DL><A HREF='#71-ChangingtheElementsofanArray'>Changing the Elements of an Array</A><BR>
<A HREF='#72-JiggerypokerywithArrays'>Jiggerypokery with Arrays</A><BR>
<DL><A HREF='#73-Atableofarrayhackingfunctions'>A table of array hacking functions</A><BR>
<A HREF='#74-Splice'>Splice</A><BR>
</DL></DL><BR><B><A HREF='#75-DeletingVariables'>Deleting Variables</A><BR>
</B><DL><DL><A HREF='#76-FalsevaluesversusExistenceItistherefore'>False values versus Existence: It is, therefore...</A><BR>
</DL></DL><BR><B><A HREF='#77-BasicRegularExpressions'>Basic Regular Expressions</A><BR>
</B><DL><A HREF='#78-Anintroduction'>An introduction</A><BR>
<A HREF='#79-Senstivityregexesintouchwiththeirinnerchild'>Senstivity -- regexes in touch with their inner child</A><BR>
<A HREF='#80-CharacterClasses'>Character Classes</A><BR>
<A HREF='#81-Matchingatspecificpoints'>Matching at specific points</A><BR>
<A HREF='#82-Negatingtheregex'>Negating the regex</A><BR>
<A HREF='#83-ReturningtheMatch'>Returning the Match</A><BR>
<A HREF='#84-regexesbecomelinenoise'>* + -- regexes become line noise</A><BR>
<A HREF='#85-TheDifferenceBetweenand'>The Difference Between + and *</A><BR>
<A HREF='#86-Reusingthematch11'>Re-using the match -- \1, $1...</A><BR>
<A HREF='#87-HowtoAvoidMakingMountainswhileEscapingSpecialCharacters'>How to Avoid Making Mountains while Escaping Special Characters</A><BR>
</DL><BR><B><A HREF='#88-SubsitutionandYetMoreRegexPower'>Subsitution and Yet More Regex Power</A><BR>
</B><DL><A HREF='#89-Basicchanges'>Basic changes</A><BR>
<A HREF='#90-w'>\w</A><BR>
<A HREF='#91-Replacingwithwhatwasfound'>Replacing with what was found</A><BR>
<A HREF='#92-x'> x </A><BR>
<DL><A HREF='#93-MoreMatching'>More Matching</A><BR>
</DL><A HREF='#94-ParenthesesAgainOR'>Parentheses Again: OR</A><BR>
<DL><A HREF='#95-OREfficiency'>(?: OR Efficiency)</A><BR>
</DL><A HREF='#96-Matchingspecificamountsof'>Matching specific amounts of...</A><BR>
<A HREF='#97-PrePostandMatch'>Pre, Post, and Match</A><BR>
<A HREF='#98-RHSExpressions'>RHS Expressions</A><BR>
<DL><A HREF='#99-e'>/e</A><BR>
<A HREF='#100-ee'>/ee</A><BR>
</DL><A HREF='#101-AWorkedExampleDateChange'>A Worked Example: Date Change</A><BR>
</DL><BR><B><A HREF='#102-SplitandJoin'>Split and Join</A><BR>
</B><DL><A HREF='#103-Splitting'>Splitting</A><BR>
<A HREF='#104-AveryFAQ'>A very FAQ</A><BR>
<A HREF='#105-WhatHumptyDumptyneedsJoin'>What Humpty Dumpty needs : Join</A><BR>
</DL><BR><B><A HREF='#106-Arecapbutwithsomenewfunctions'>A recap, but with some new functions</A><BR>
</B><DL><A HREF='#107-Randomness'>Randomness</A><BR>
<A HREF='#108-Concatenation'>Concatenation</A><BR>
</DL><BR><B><A HREF='#109-Files'>Files</A><BR>
</B><DL><A HREF='#110-Opening'>Opening</A><BR>
<A HREF='#111-Anunforgivableerror'>An unforgivable error</A><BR>
<A HREF='#112-orinpathnamesyourchoice'>\\ or / in pathnames -- your choice</A><BR>
<A HREF='#113-Readingafile'>Reading a file</A><BR>
<A HREF='#114-WritingtoaFile'>Writing to a File</A><BR>
<DL><A HREF='#115-Asimplewrite'>A simple write</A><BR>
<A HREF='#116-Appending'>Appending</A><BR>
<A HREF='#117-ARGVCommandLineArguments'>@ARGV: Command Line Arguments</A><BR>
<A HREF='#118-ModifyingaFilewithI'>Modifying a File with $^I</A><BR>
<A HREF='#119-Changingwhatisreadinto_'>$/ -- Changing what is read into $_</A><BR>
<A HREF='#120-HEREDocs'>HERE Docs</A><BR>
</DL></DL><BR><B><A HREF='#121-ReadingDirectories'>Reading Directories</A><BR>
</B><DL><A HREF='#122-Globbing'>Globbing</A><BR>
<A HREF='#123-readdirHowtoreadfromdirectories'>readdir : How to read from directories</A><BR>
</DL><BR><B><A HREF='#124-AssociativeArrays'>Associative Arrays</A><BR>
</B><DL><A HREF='#125-TheBasics'>The Basics</A><BR>
<A HREF='#126-AHashinAction'>A Hash in Action</A><BR>
<A HREF='#127-Whenyoushouldusehashes'>When you should use hashes</A><BR>
<A HREF='#128-HashHackingFunctions'>Hash Hacking Functions</A><BR>
<A HREF='#129-MoreHashAccessIterationkeysandvalues'>More Hash Access: Iteration, keys and values</A><BR>
</DL><BR><B><A HREF='#130-Sorting'>Sorting</A><BR>
</B><DL><A HREF='#131-ASimpleSort'>A Simple Sort</A><BR>
<A HREF='#132-NumericSortingHowSortReallyWorks'>Numeric Sorting -- How Sort Really Works</A><BR>
<A HREF='#133-SortingMultipleLists'>Sorting Multiple Lists</A><BR>
</DL><BR><B><A HREF='#134-GrepandMap'>Grep and Map</A><BR>
</B><DL><A HREF='#135-Grep'>Grep</A><BR>
<A HREF='#136-Map'>Map</A><BR>
<A HREF='#137-Writingyourowngrepandmapfunctions'>Writing your own grep and map functions</A><BR>
</DL><BR><B><A HREF='#138-ExternalCommands'>External Commands</A><BR>
</B><DL><A HREF='#139-Somewaysto'>Some ways to...</A><BR>
<A HREF='#140-Exec'>Exec</A><BR>
<A HREF='#141-System'>System</A><BR>
<A HREF='#142-Backticks'>Backticks</A><BR>
<A HREF='#143-Whentouseexternalcalls'>When to use external calls</A><BR>
<A HREF='#144-OpeningaProcess'>Opening a Process</A><BR>
<A HREF='#145-Quoteexecute'>Quote execute</A><BR>
</DL><BR><B><A HREF='#146-Oneliners'>Oneliners</A><BR>
</B><DL><A HREF='#147-Ashortexample'>A short example</A><BR>
<A HREF='#148-Fileaccess'>File access</A><BR>
<A HREF='#149-ModifyingfileswithaonelinerandI'>Modifying files with a oneliner and $^I</A><BR>
</DL><BR><B><A HREF='#150-SubroutinesandParameters'>Subroutines and Parameters</A><BR>
</B><DL><A HREF='#151-Parameters'>Parameters</A><BR>
<A HREF='#152-Namespaces'>Namespaces</A><BR>
<A HREF='#153-VariableScope'>Variable Scope</A><BR>
<A HREF='#154-myVariables'>my Variables</A><BR>
<A HREF='#155-MultipleReturns'>Multiple Returns</A><BR>
<A HREF='#156-Local'>Local</A><BR>
<A HREF='#157-Returningarrays'>Returning arrays</A><BR>
</DL><BR><B><A HREF='#158-Modules'>Modules</A><BR>
</B><DL><A HREF='#159-Anintroduction'>An introduction</A><BR>
<A HREF='#160-FileFindusingamodule'>File::Find -- using a module</A><BR>
<A HREF='#161-ChangeNotify'>ChangeNotify</A><BR>
<A HREF='#162-YourVeryOwnModule'>Your Very Own Module</A><BR>
</DL><BR><B><A HREF='#163-BondageandDiscipline'>Bondage and Discipline</A><BR>
</B><DL><A HREF='#164-w'>-w</A><BR>
<DL><A HREF='#165-Shebang'>Shebang</A><BR>
</DL><A HREF='#166-usestrict'>use strict;</A><BR>
</DL><BR><B><A HREF='#167-Debugging'>Debugging</A><BR>
</B><BR><B><A HREF='#168-LogicalOperators'>Logical Operators</A><BR>
</B><DL><A HREF='#169-or'>or</A><BR>
<A HREF='#170-PrecedenceWhatcomesFirst'>Precedence: What comes First</A><BR>
<A HREF='#171-And'>And</A><BR>
<A HREF='#172-OtherLogicalOperators'>Other Logical Operators</A><BR>
</DL><BR><B><A HREF='#173-Lastwords'>Last words</A><BR>
</B><BR><B><A HREF='#174-Thanksto'>Thanks to...</A><BR>
</B></DL>
<HR WIDTH='30%'>
</TOCHERE>


<BR><A NAME='7-Whatyouneedtoknow'></A> <H2>What you need to know</H2>


<P>
You need to be able to differentiate between a PC and a toaster. No programming
experience is necessary. You do need to understand the basics of PC operation.
If you don't understand what directories and files are then you'll find
this difficult. You might find it difficult even if you do :-)
<P>
You do need to exercise the brain cells, and you need time.

</P>

<h2>What you need to have</h2>
<UL>
<LI>A PC which can run a Win32 operating system.  That's Windows NT 3.5, 3.51, 4.0 or later, or Windows 95 or Windows 98. Not Windows 3.1.  Sorry.  Now, you finally have a reason to upgrade.
<LI>You need to get hold of a copy of Perl, so for that you might need an Internet connection.  But if you can get it some other way, you don't.
</UL>
<P>
<I>Note</I>: You don't even need a Win32 PC if you are comfortable installing Perl under other operating systems like Linux, but not all the information here will be relevant.
<P>
You don't need a complier. Perl is an interpreted language, which means you run code directly, not compile it then run it.
<P>

<BR><A NAME='4-HowtoUse'></A> <H2>How to use this tutorial...</H2>

<P>
Just work through from start to finish. 
</P><P>
Generally, the explanation follows the code sample.  Before you read the explanation, try and work out what the code does.  Then check if you're right.  In this way, you'll derive maximum value from the tutorial and exercise the old grey cells a little.
</P><P>
When you finish, please send me a critique. In fact, send one even if you don't finish. I appreciate <I>all</I> feedback!  <B>Please note</B> -- I am not a source of free technical support.  Do not email me your general Perl problems.  If you want support, ask on Usenet or the ActiveState mailing lists.  That said, I welcome problems <I>related to the tutorial itself</I>.
</P>


<BR><A NAME='6-ConventionsusedinthisTutorial'></A> <H2>Conventions used in this Tutorial</H2>


<P>
The humour is non-conventional.  I think.  Of more importance, the text is coloured strangely in places. My intention is to aid your comprehension, not attempt beautification.  The meaning of the colours:
</P>
<UL>
<LI>Sometimes you'll need to type something in on the command line. These commands will be in green, for example :<BR>
<FONT COLOR="00aa00"><code>perl changeworld.pl parm1 datafile.txt</code></FONT>
<LI>Code that you should load into your editor and run is in blue (don't run this now, it's just an example):<BR>
<FONT COLOR="0000FF"><pre>
while (&lt;DATFILE&gt;) {
	printf "%2s : $_",$.;
}
</pre></FONT>

<LI>when functions are referred to in the text, their names are highlighted in red.  
For example, later we discover an interesting function called <FONT COLOR="FF0000"><code>split</code></FONT>.
</UL>

<P>
All the code examples have been tested, and you can just cut'n'paste (brave statement).
I haven't listed the output of each example. You need to run it and see
for yourself. Consider this course interactive.  Consider it any which way you like.
</P>



<BR><A NAME='8-Useofthisdocument'></A> <H2>Use of this document</H2>



</FONT>
<P>


<BR><A NAME='9-PersonalPrintouts'></A> <H3>Personal Printouts</H3>


Fine by me, feel free print to a copy for your own use.



<BR><A NAME='10-Intranetusage'></A> <H3>Intranet usage</H3>


Just email me and let me know.



<BR><A NAME='11-Mirroring'></A> <H3>Mirroring</H3>


Again, all I ask is an email.



<BR><A NAME='12-Translations'></A> <H3>Translations</H3>


Every so often someone offers to translate the tutorial. Nobody has actually done so.  If you want to, the conditions are:
<UL>
<LI>You don't change the text other than what can be reasonably expected during a translation;
<LI>The content, format and notices authorship remains the same;
<LI>You can add a 'translated by' notice in the intro and at the end, plus your own message;
<LI>Version numbers are respected but the ISO code for your country is added, eg 3.3.2.ES;
<LI>and you need to email me to discuss.
</UL>
<P>
<CENTER>
<B>Remember this document is copyrighted and all associated rights are strictly reserved.</B>
</CENTER>
</P>
<P>--<BR>
<BR><A HREF="/rob/">Robert Pepper</A>
<BR><A HREF="mailto:robert@netcat.co.uk">mailto:Robert@netcat.co.uk</A>
<BR>http://www.netcat.co.uk/rob/perl/win32perltut.html
<P>
<HR width="50%">
</P>




<BR><A NAME='13-AShortIntroductionToPerl'></A> <H1>A Short Introduction To Perl</H1>




<P>
<I>If you already understand what Perl is designed to do, know its features and limitations then you can skip this very small but highly informative section, over which I laboured long and hard for those that didn't know. If you are really sure, jump to the <A HREF="#setup">Setup Section</A></I>.
</P>




<BR><A NAME='14-WhatisPerl'></A> <H2>What is Perl?</H2>




<P>
Perl is a programming language. Perl stands for Practical Report and Extraction
Language. You'll notice people refer to 'perl' and "Perl". "Perl" is the
programming language as a whole whereas 'perl' is the name of the core executable. There is no language called "Perl5" -- that just means "Perl version 5".  Versions of Perl prior to 5 are very old and very unsupported.
</P><P>
Some of Perl's many strengths are:
</P>
<UL>
<LI>
<B>Speed of development.</B> You edit a text file, and just run it. You
can develop programs very quickly like this. No separate compiler needed.
I find Perl runs a program quicker than Java, let alone compare the complete
modify-compile-run-oh-no-forgot-that-semicolon sequence.</LI>
<LI>
<B>Power.</B> Perl's regular expressions are some of the best available.
You can work with objects, sockets...everything a systems administrator
could want. And that's just the standard distribution. Add the wealth of
modules available on CPAN and you have it all. Don't equate scripting languages
with toy languages.</LI>
<LI>
<B>Usuability.</B> All that power and capability can be learnt in easy
stages. If you can write a batch file you can program Perl. You don't have
to learn object oriented programming, but you can write OO programs in
Perl. If autoincrementing non-existent variables scares you, make perl refuse
to let you. There is always more than one way to do it in Perl. You decide
your style of programming, and Perl will accommodate you.</LI>
<LI>
<B>Portability.</B> On the Superhighway to the Portability Panacea, Perl's
Porsche powers past Java's jaded jalopy. Many people develop Perl scripts
on NT, or Win95, then just FTP them to a Unix server where they run. No
modification necessary.</LI>
<LI>
<B>Editing tools</B> You don't need the latest Integrated Development Environment
for Perl. You can develop Perl scripts with any text editor. Notepad, vi,
MS Word 97, or even direct off the console. Of course, you can make things
easy and use one of the many freeware or shareware programmer's file editors.</LI>
<LI>
<B>Price.</B> Yes, 0 guilders, pounds, dmarks, dollars or whatever. And
the peer to peer support is also free, and often far better than you'd
ever get by paying some company to answer the phone and tell you to do
what you just tried several times already, then look up the same reference
books you already own.</LI>
</UL>




<BR><A NAME='15-WhatisActivePerlAretheotherPerlsinactive'></A> <H2>What is ActivePerl?  Are the other Perls inactive?</H2>




<P>
A company named ActiveState exists to provide Perl tools for the Win32 environment. ActiveState used to be ActiveWare, and before that it was sort of a part of Hip Communications. It now appears to be happy with its current name, having not changed it for over a year. Win32 means, at the time of writing, Windows 95, Windows 98 and Windows NT.  It does <I>not</I> mean Windows 3.11, even with Win32s installed.
</P><P>
Prior to Perl version 5.005, there was one version of Perl for Win32, and another for all the other systems.  The other version was known as the "native version". 
</P><P>
The Win32 version was developed by ActiveState, called "Perl for Win32" and typically lagged slightly behind the native version. As of the 5.005 release, Perl for Win32 and the native version have merged -- the native version now supports Win32 directly and doesn't need any tweaking by ActiveState.
</P><P>
ActiveState have dropped "Perl for Win32" and renamed their distribution, which comes with an InstallShield installer, "ActivePerl".
</P><P>
Incidentally, a few months before 5.005 merge the native Perl version was changed so it would run on Win32 directly. This version was best known by the creator's name, "Gurusamy Sarathy". However, there were still quite a few differences between it and Perl for Win32, so many people ran both. The merge brought the best of both worlds together.
</P>




<BR><A NAME='16-CanIrunPerlonmycomputer'></A> <H2>Can I run Perl on my computer?</H2>




<P>
Probably. Perl runs on everything from Amigas to Macintoshes to Unix boxen.  Perl also runs on Microsoft operating systems, namely Windows 95, Windows 98 and Windows NT 3.51 and later.  There are versions of Perl that run on earlier versions of these operating systems but they are no longer developed or supported.  See <A HREF="http://www.perl.com">http://www.perl.com</A> for full details.
</P>




<BR><A NAME='17-WhatcanIdowithPerl'></A> <H2>What can I do with Perl ?</H2>




Just two popular examples :




<BR><A NAME='18-TheInternet'></A> <H3>The Internet</H3>




<P>
Go surf. Notice how many websites have dynamic pages with <code>.pl</code> or similar
as the filename extension? That's Perl. It is the most popular language
for CGI programming for many reasons, most of which are mentioned above.
In fact, there are a great many more dynamic pages written with perl that
may not have a <code>.pl</code> extension.  If you code in Active Server Pages, then you should try using ActiveState's PerlScript.  Quite frankly, coding in PerlScript rather than VBScript or JScript is like driving a car as opposed to riding a bicycle.  Perl powers a good deal of the Internet.
</P>




<BR><A NAME='19-SystemsAdministration'></A> <H3>Systems Administration</H3>




<P>
If you are a Unix sysadmin you'll know about sed, awk and shell scripts.  Perl can do everything they can do and far more besides.  Furthermore, Perl does it much more efficiently and portably. Don't take my word for it, ask around.
</P><P>
If you are an NT sysadmin, chances are you aren't used to programming.
In which case, the advantages of Perl may not be clear. Do you need it? Is it worth it?
</P><P>
After you read this tutorial you will know more than enough to start
using Perl productively. You really need very little knowledge to save
time. Imagine driving a car for years, then realising it has five gears,
not four. That's the sort of improvement learning Perl means to your daily sysadminery. When you
are proficient, you find the difference like realising the same car has
a reverse gear and you don't have to push it backwards. Perl means you can
be lazier. Lazy sysadmins are good sysadmins, as I keep telling my boss.
<P>
A few examples of how I use Perl to ease NT sysadmin life:
<UL>
<LI><B>User account creation</B>. If you have a text file with the user's names in it, that is all you need. Create usernames automatically, generate a unique password for each one and create the account, plus create and share the home directory, and set the permissions.</LI>
<LI><B>Event log munging.</B>  NT has great Event Logging.  Not so great Event Reading.  You can use Perl to create reports on the event logs from multiple NT servers.</LI>
<LI><B>Anything else </B> that you would have used a batch file for, or wished that you could automate somehow.  Now you <I>can</I>.</LI>
</UL>
</P>




<BR><A NAME='20-WhatcantIdowithPerl'></A> <H2>What can't I do with Perl ?</H2>




<P>
The question is, "what shouldn't I do with Perl".  Write office suites is one answer.  Perl, like most scripting languages, is a glue language designed for short and relatively simple tasks.  Just don't equate this philosophy with a lack of power or "serious" features.
</P>

<BR><A NAME='21-Support'></A> <H2>Support</H2>

<P>
See the FAQs at www.perl.com. Of course there are Usenet groups, but also many mailing lists.  Microsoft Windows users will be interested in those hosted by 
<A HREF="http://www.activestate.com/">http://www.activestate.com/</A> which discuss all things Perl and Windows.
</P><P>
<B>Please, before you ask any question, anywhere:</B>
<OL>
<LI><B>Make sure you read the group charter</B>. Many people put time and effort
into the creation of those charter in the interests of efficient discussion, so don't degrade the discussion quality and insult us by ignoring the guidelines.</LI>
<LI><B>Read the FAQs</B> at least twice.  Try and find related FAQs.  Try hard.  You won't be popular if you post a question starting "I've looked at all the FAQs..." and then ask something that actually <I>is</I> in the FAQs.  Or the manual for that matter.  Believe me, it will be patently obvious to all on the list if you haven't done your homework.
<LI><B>Carefully phrase the questions and provide source code</B> because if you do that, you may well end up solving the problem yourself because you have thought it through a little more.
</OL>
<P>
<B>Think to yourself -- honestly -- if I was a busy Perl Professional, would I want to answer my own question?</B></P><P>
Does it clearly state what I want an answer to?  Preferably just one question at a time. Am I being unreasonable, for example asking for someone to code it for me?  Have I shown evidence that I have tried to help myself?  Have I made any mistakes in grammar?  Is it polite?  Is there enough information in there for the answer to be given?
<P>
Why should you care?  Well, if you ask poorly-formed questions or those already answered in the FAQ...let's just say you won't get the answers you want.  If you care about your online reputation and wasting other people's time --  two more reasons.
</P>
<BR>
<HR width="50%">
<A NAME="setup"></A>

<BR><A NAME='22-Setup'></A> <H1>Setup</H1>

</P><P>
There are four stages:
<OL>
<LI>Get the software.</LI>
<LI>Install it.</LI>
<LI>Run a test Script.</LI>
<LI>Celebrate or troubleshoot.</LI>
</OL>
</P>

<BR><A NAME='23-1GettingtheSoftware'></A> <H2>1. Getting the Software</H2>

<P>
<I>An old version of Perl for Win32 is included with the Windows NT Resource
Kit. It is sadly out of date. Follow the steps below to
get a newer version. Having said that, you can complete the tutorial with the Resource Kit version but you should upgrade as soon as you can.</I>
</P><P>
Go to <A HREF="http://www.activestate.com">http://www.activestate.com</A> and follow the links to download ActivePerl.
It will be a single file, and the name will be something like <code>api508e.exe</code>.  The <code>i</code> stands for Intel.  If you have an Alpha, download <code>apaXXXe.exe</code>.  If you're not sure, download the Intel version.
</P><P>
The <code>508e</code> is the version number, so expect this to change quite rapidly. The file size will be just over 5Mb, so it will take a while to download via modem. If you know how to use FTP, try <code>ftp.activestate.com/activeperl/</code>.
</P><P>
When you find ActivePerl, save the file into any directory you please.  I like to organise my downloads into <code>c:\downloads</code> but that is just personal preference. As long as ActivePerl ends up on your hard disk somewhere it doesn't matter.  
</P>
</A>

<BR><A NAME='24-2Installation'></A> <H2>2. Installation</H2>

<P>
So you now have <code>apixxxx.exe</code>.  If you forget where you saved it, don't panic, just run Windows Explorer and search for <code>api*e.exe</code>
</P><P>
<OL>
<LI><B>Double-click the <code>apixxxx.exe</code></B>.  You'll see the fantastic ActivePerl graphic and be advised to close all open applications before proceeding.  The lizard thing is a gecko, which adorns the famous O'Reilly book "Learning Perl on Win32 Systems".  This tutorial is aimed at a more basic level than that book, in terms of the author's knowledge, intended audience and quality of humour.
</LI>
<LI><B>Agree to the license agreement</B> or cancel the install, stop this tutorial and deny yourself any hope of hackership.</LI>
<LI><B>Destination directory</B> is whatever you want.  I usually install Perl in <code>c:\progs\perl</code> rather than <code>c:\program files\perl</code> because many Win32 programs don't properly handle long filenames, let alone those with spaces in.  Or you could accept the default.  Your choice.</LI>
<LI><B>Select Components</B>.  All you'll need for this tutorial is "Perl for Win32 Core", but installing the "Online Help and Documentation" and "Example Files" is highly recommended. If you run Internet Information Server (IIS) 3 or later, or Personal Web Server (PWS), then install "Perl for ISAPI" and "PerlScript" too, although don't try either of these until you are proficient with the basics.  The phrase running before walking comes to mind.</LI>
<LI><B>Select Options</B>. 
<UL>
<LI><B>"Associate '.pl' with Perl.exe"</B>. If you select this option then you can just type in the name of a script at the command line, or double-click it and the script will run.  If you don't, then in order to get a script to execute you'll need to type:<BR>
<code>perl myscript.pl</code><BR>
to execute <code>myscript.pl</code>. Personally, I prefer double-clicking to allow me to edit the file so I do not select this option.  Also, perl has a plethora of command line arguments which are difficult to pass to a script if you run it by association.  For the purposes of this tutorial I'm assuming that you haven't associated <code>.pl</code> with perl.</LI>
<LI><B>"Add the Perl bin directory to your path"</B>.  Do this, otherwise you'll have to specify the full path to perl.exe every time you use it.  Not fun.</LI>
<LI><B>"Standard I/O redirection for IIS"</B>.  If you run IIS or PWS, select this. It is a Good Thing.  Understand it later.</LI>
</UL>
<LI><B>IIS Options</B> If you use IIS or PWS you'll have this screen -- just accept both options.</LI>
<LI><B>Program Folder</B> whatever your preference is. This is just a link to the documentation, to the perl.exe itself.</LI>
<LI><B>Confirmation</B> make sure that what is displayed is what you have selected...
<LI>The install program will now copy files.  At the end it will run a few perl scripts itself,  which briefly appear as DOS boxes.  Don't worry, it is all quite normal.</LI>
<LI><B>Release notes</B>.  Well worth a read.</LI>
<LI><B>Reboot!</B> Just so the path statement takes effect.  In any case, it is always good practice to reboot after a new install.</LI>
</OL>

<BR><A NAME='25-3TestingYourFirstPerlScript'></A> <H2>3. Testing - Your First Perl Script</H2>

</P><P>
So you know what this tutorial is designed to do.  You know what Perl is designed to do, and you have even installed it.  It is now time to start the tutorial proper, and actually hack some code.
</P>
<HR width="80%">

<BR><A NAME='26-TheTutorialTheJourneyBegins'></A> <H1>The Tutorial: The Journey Begins</H1>

<BR><A NAME='27-YourFirstTime'></A> <H2>Your First Time</H2>
<P>
Assuming all has gone to plan, you can now create your first Perl script. Follow these instructions, but before you start read them through once, then begin. That's a good idea with any form of computer-related procedure.  So, to begin:
<P>
<OL>
<LI>Create a new directory for your perl scripts, separate to your data files
and the perl installation. For example, <code>c:\scripts\</code>, which is
what I'll assume you are using in this tutorial.
<LI>Start up whatever text editor you're going to hack Perl with. Notepad.Exe
is just fine.  If you can't find Notepad on your Start menu, press the Start button, then select Run, type in 'notepad' and click OK.
<LI>Type the following in Notepad
<FONT COLOR="0000FF"><pre>print "My first Perl script\n";</PRE></FONT>
<LI>Save the to <code>c:\scripts\myfirst.pl</code>. Be careful!  Notepad will may save files with a <code>.txt</code> extension, so you will end up with <code>myfirst.txt.pl</code> by default.  Perl won't mind, it'll still execute the file.  If your version of Notepad does this, select "All files" before saving or rename the file then load it again.  Better yet, use a decent text editor!
<LI>You don't need to exit Notepad
-- keep it open, as we'll be making changes very soon.
<LI>
Switch to your command prompt.  If you don't know how to start a command prompt, click 'Start' and then 'Run'.  If using Windows 9x, type in 'command' and press enter.  If using NT, type in 'cmd' and press Enter.
<LI>Change to your perl scripts directory, for example <code> cd \scripts </code>.
<LI>Hold your breath, and execute the script:
<FONT COLOR="00AA00"><code>perl myfirst.pl</code></FONT>
</OL>
</P><P>
and you'll see the output. Welcome to the world of Perl ! See what I mean
about it being easy to start ? However, it is difficult to finish with
Perl once you begin :-)
</P><P>
<BR><A NAME='28-Whatifitdoesnt'></A> <H2>What if it doesn't...?</H2>
So you typed in <FONT COLOR="00AA00"><code>perl myfirst.pl</code></FONT> and you didn't see <code>My first Perl script</code> on the screen.  If you saw "bad command or filename" then either you haven't installed Perl or perl.exe is not in your path. Probably the latter. Reboot, then try again.  
</P><P>
If you saw <code>Can't open perl script "xxxx.pl": No such file or directory</code> then perl is defintely installed, but you have either got the name of the script wrong or the script is not in the same directory as where you are trying to run it from.  For example, maybe you saved in script in <code>c:\windows</code> and you are in <code>c:\scripts </code> so of course Perl complains it can't find the script. Could you?  Well, don't expect Perl to then.  You don't have to  run the script from the directory in which it resides, but it is easier.

<BR><A NAME='29-Assumingitsnowallright'></A> <H2>Assuming it's now all right...</H2>
W need to analyse what's going on here a little. First note that
the line ends with a semicolon <FONT COLOR="FF0000"><code> ; </code></FONT>. Almost all lines of code in Perl have to end with semicolons, and those that don't have to will accept semicolons anyway.  The moral is -- use semicolons. Sorry; the moral is; use semicolons.
</P><P>
Oh, one more thing -- if you haven't already done so, continue breathing.
</P><P>
Also note the <FONT COLOR="FF0000"><code> \n </code></FONT>. This is the code to tell Perl
to output a newline. What's a newline?  Delete the <FONT COLOR="FF0000"><code> \n </code></FONT> from the program and run it again:
<FONT COLOR="0000FF">
<pre>print "My first Perl script";</PRE>
</FONT>
and all should become clear.  You have now written your first Perl script.
</P>

<BR><A NAME='30-Shebang'></A> <H2>Shebang</H2>

<P>
Almost every Perl book is written for UN*X, which is a problem for
Win32. This leads to scripts like:

<FONT COLOR="0000FF"><pre>
#!c:/perl/perl.exe

print "I'm a cool Perl hacker\n";
</PRE></FONT>
</P><P>
The function of the 'shebang' line is to tell the shell how to execute
the file. Under UNIX, this makes sense. Under Win32, the system must already
know how to execute the file before it is loaded so the line is not needed.
</P><P>
However, the line is not completely ignored, as it is searched for
any switches you may have given Perl (for example <FONT COLOR="00AA00"><code> -w </code></FONT> to turn on warnings).
</P><P>
You may also choose to add the line so your scripts run directly on UNIX without modification, 
as UNIX boxes probably <I>do</I> need it. Win32 systems do not. We shall continue with the lesson.


<BR><A NAME='31-Variables'></A> <H2>Variables</H2>

<BR><A NAME='32-Scalars'></A> <H3>Scalars</H3>

So Perl is working, and you are working with Perl. Now for something more
interesting than simple printing. Variables. Let's take simple scalar variables
first. A <B>scalar variable is a single value</B>. Like <FONT COLOR="FF0000"><code>$var=10</code></FONT> which
sets the variables <FONT COLOR="FF0000"><code>$var </code></FONT> to the value of 10. Later, we'll look at lists like arrays and hashes, where <FONT COLOR="FF0000"><code> @var </code></FONT> refers to  more than
one value. For the moment, remember that <B>Scalar is Singular</B>.  If weird metaphors help, think of lots of scaly snakes at a singles bar.  If that didn't help, I apologise for putting the thought into your mind.
</P>

<BR><A NAME='33-areGoodThings'></A> <H3>$ % @ are Good Things</H3>

<P>
If you have any experience with other programming languages you might be surprised by the code 
 <FONT COLOR="FF0000"><code>$var=10</code></FONT>.
With most languages, if you want to assign the value 
 <FONT COLOR="FF0000"><code> 10 </code></FONT>
 to a variable called 
<FONT COLOR="FF0000"><code> var </code></FONT> you'd write <FONT COLOR="FF0000"><code>var=10</code></FONT>.
</P><P>
Not so in Perl. This is a Feature. All variables are prefixed with a
symbol such as <FONT COLOR="FF0000"><code> $ @ % </code></FONT>. This has certain advantages, like making programs easier to read.  Honestly, I'm serious!  It just takes some getting used to.
The prefixes mean that you can <B>see where the variables are</B> quite easily.
And not only that, what <B>sort of variable</B> it is. The human language German
has a similar principle (except nouns are capitalised, not prefixed with
<FONT COLOR="FF0000"><code> $ </code></FONT> and Perl is easier to pronounce). You'll agree later, I think.
</P><P>So, ever onwards. Time to try some more variables:
<FONT COLOR="0000FF"><pre>
$string="perl";
$num1=20;
$num2=10.75;
print "The string is $string, number 1 is $num1 and number 2 is $num2\n";
</PRE></FONT>

<BR><A NAME='34-Typing'></A> <H3>Typing</H3>
<P>
A closer look...notice you don't have to say what <B>type of variable</B> you
are declaring. In other languages you need to say if the variable is a string,
array, what sort of number it is and so on. You might even have to declare what type of number
it is. As an example, in Java you'd been saying things like <code>int var=10</code>
which defines the variable var as an integer, with the value 10. 
</P><P>
So, why do these other programming languages force you to declare exactly what your variables are?  Wouldn't it be easier if we could just not bother?
</P><P>
For short programs, yes.  For really big projects with many programmers working on the same application, no.  That's because forcing variable type declaration also forces a certain discipline and rigour which is what you need on big projects.  
</P><P>
As you know, Perl is not designed for gigantic software engineering efforts. It is all about small, quick programs.  For these purposes you don't need the rigour of variable controls as much, so Perl doesn't bother.
</P><P>
This idea of forcing a programmer to declare what sort of variable is being created is called <B>typing</B>.  As Perl doesn't by default enforce any rules on typing, it is said to be a <B>loosely typed</B> language, as opposed to something like C++ which is <B>strongly typed</B>.
</P>

<BR><A NAME='35-VariableInterpolation'></A> <H3>Variable Interpolation</H3>

<P>
We still haven't finished learning from that humble bit of code.  To refresh your memory, here it is again:
<FONT COLOR="0000FF"><pre>
$string="perl";
$num1=20;
$num2=10.75;
print "The string is $string, number 1 is $num1 and number 2 is $num2\n";
</PRE></FONT>
Notice the way the variables are used in the string. Sticking variables
inside of strings has a technical term - <B>"variable interpolation"</B>.
Now, if we didn't have the handy <FONT COLOR="FF0000"><code> $ </code></FONT>
prefix for we'd have to do
something like the example below, which is pseudocode. Pseudocode is code
to demonstrate a concept, not designed to be run. Like certain Microsoft
software.
</P><P>
<code>print "The string is ".string." and the number is ".num."\n";</code>
</P><P>
which is much more work. Convinced about those prefixes yet ?
</P><P>
Try running the following code:
<FONT COLOR="0000FF"><pre>
$string="perl";
$num=20;
print "Doubles: The string is $string and the number is $num\n";
print 'Singles: The string is $string and the number is $num\n';
</PRE></FONT>
</P><P>
Double quotes allow the aforementioned variable interpolation. Single quotes
do not. Both have their uses as you will see later, depending on whether
you wish to interpolate anything.
</P>


<BR><A NAME='36-ChangingVariables'></A> <H3>Changing Variables</H3>

<BR><A NAME='37-Autodeincrements'></A> <H4>Auto(de|in)crements</H4>
<P>
If you want to add 1 to a variable you can, logically, do this; 
<FONT COLOR="FF0000"><code> $num=$num+1 </code></FONT>.
There is a shorter way to do this, which is <FONT COLOR="FF0000"><code>$num++</code></FONT>. This is an autoincrement. Guess what this is; <FONT COLOR="FF0000"><code> $num-- </code></FONT>. Yes, an autodecrement.
</P><P>
This example illustrates the above:
<FONT COLOR="0000FF"><pre>
$num=10;
print "\$num is $num\n";

$num++;
print "\$num is $num\n";

$num--;
print "\$num is $num\n";

$num+=3;
print "\$num is $num\n";
</PRE></FONT>
<P>
The last example demonstrates that it doesn't have to be just 1 you can
add or decrease by.
</P><P>

<BR><A NAME='38-Escaping'></A> <H2>Escaping</H2>

There's something else new in the code above. The <FONT COLOR="FF0000"><code> \ </code></FONT>. You can
see what this does -- it <B>'escapes'</B> the special meaning of <FONT COLOR="FF0000"><code> $ </code></FONT>.
</P><P>
Escaping means that just the <FONT COLOR="FF0000"><code> $ </code></FONT> symbol is printed instead of it referring
to a variable. 
</P><P>
Actually <FONT COLOR="FF0000"><code> \ </code></FONT>has a deeper meaning -- <B>it escapes all of Perl's special characters</B>, 
not just <FONT COLOR="FF0000"><code> $ </code></FONT>. Also, it turns some
non-special characters into something special. Like what ? Like <FONT COLOR="FF0000"><code> n </code></FONT>. Add the magic <FONT COLOR="FF0000"><code> \ </code></FONT> and the humble 'n' becomes the mighty NewLine ! 
The <FONT COLOR="FF0000"><code> \ </code></FONT> character can also escape itself. So if you want to print a single <FONT COLOR="FF0000"><code> \ </code></FONT> try:

<FONT COLOR="0000FF"><pre>
print "the MS-DOS path is c:\\scripts\\";
</pre></font>

<P>
Oh, '\' is also used for other things like references. But that's not even
covered here.
</P><P>
There is a technical term for these 'special characters' such as <FONT COLOR="FF0000"><code> @ $ %</code></FONT>. They are called <B>metacharacters. </B>Perl uses plenty of metacharacters.  In  fact, you'll wear your keyboard pretty evenly during a night's perl hacking.  I think it is safe to say that Perl uses every possible keystroke and shifted keystroke on a standard US PC keyboard.
</P><P>
You'll be working with all sorts of obscure characters in your Perl hacking career, and I also mean those on your keyboard.  This has earned perl a reputation for being difficult to understand.  That's entirely true.  Perl <I>does</I> have such a reputation, no doubt about it.
</P><P>
Is the reputation justified?  In my opinion, Perl does have a short but steep learning curve to begin with simply because it is so different.  However, once you learn the character meanings reading perl code becomes much <B>easier precisely because of all these strange characters</B>.
</P><P>

<BR><A NAME='39-ContextAboutPerland'></A> <H2>Context: About Perl and @^$%&~`/?</H2>

Perl uses so many weird characters that there aren't enough to go round.  So sometimes the <B>same character has two or more meanings, depending on its context.</B> As an example, the humble dot <FONT COLOR="FF0000"><code> . </code></FONT> can join two variables together, act as a wildcard or become a range operator if there are two of them together.  The caret
<FONT COLOR="FF0000"><code> ^ </code></FONT> has different effects in 
<FONT COLOR="FF0000"><code> [^abc] </code></FONT> as opposed to 
<FONT COLOR="FF0000"><code> [a^bc] </code></FONT>.
</P><P>
If this sounds crazy, think about the English language.
What do the following mean to you ?
<UL>
<LI>MEAN</LI>
<LI>POLISH</LI>
<LI>LIKE</LI>
</UL>
</P><P>
Mean is, in one context, is a word to used describe the purpose of something. 
It is also another word for average. Furthermore, it describes a nasty person, or a person who doesn't like spending
money, and is used in slang to refer to something impressive and good. 
</P><P>
That's five different uses for 'mean', and you don't have any trouble understanding which one I <joke>mean</joke> due to context.
</P><P>
Polish, when capitalised, can either mean pertaining to the country
Poland, or the act of making something shiny. And 'like' can mean similar
to, or affection for.
</P><P>
So, when you speak or write English (think of two, to and too) you know
what these words mean by their context. It is exactly the same way with
Perl. Just don't assume a given metacharacter always means what you first
thought it did.
</P><P>
To finish off this section, try the following:

<BR><A NAME='40-StringsandIncrements'></A> <H2>Strings and Increments</H2>

<FONT COLOR="0000FF"><pre>
$string="perl";
$num=20;
$mx=3;

print "The string is $string and the number is $num\n";

$num*=$mx;
$string++;
print "The string is $string and the number is $num\n";
</PRE></FONT>
Note the easy shortcut <FONT COLOR="FF0000"><code> *= </code></FONT> meaning 'multiply $num by $mx' or, 
<FONT COLOR="FF0000"><code> $num=$num*$mx </code></FONT>.
Of course Perl supports the usual <FONT COLOR="FF0000"><code> + - * / ** % </code></FONT>operators. The
last two are exponentiation (to the power of) and modulus (remainder of
x divided by y). Also note the way you can increment a string ! Is this
language flexible or what ?

<BR><A NAME='41-PrintAListOperator'></A> <H2>Print: A List Operator</H2>

The <FONT COLOR="FF0000"><code> print </code></FONT> function is a <B>list operator</B>.  That means it accepts a list of things to print, separated by commas.  As an example:
<FONT COLOR="0000FF"><pre>
print "a doublequoted string ", $var, 'that was a variable called var', $num," and a newline \n";
</pre></FONT>
Of course, you just put all the above inside a single doublequoted string:
<FONT COLOR="0000FF"><pre>
print "a doublequoted string $var that was a variable called var $num and a newline \n";
</pre></FONT>
to achieve the same effect.  The advantage of using the <FONT COLOR="FF0000"><code> print </code></FONT> function in
list context is that expressions are evaluated before being printed.  For example, try this:
<FONT COLOR="0000FF"><pre>
$var="Perl";
$num=10;
print "Two \$nums are $num * 2 and adding one to \$var makes $var++\n";
print "Two \$nums are ", $num * 2," and adding one to \$var makes ", $var++,"\n";
</pre></FONT>
<P>
You might have been slightly surprised by the result of that last experiment.  In particular, what happened to our variable
<FONT COLOR="FF0000"><code> $var </code></FONT> ?  It should have been incremented by one, resulting in <code>Perm</code>. The reason being that 'm' is the next letter after 'l' :-)
</P><P>
Actually, it <I>was</I> incremented by 1.  We are <B>postincrementing</B> <FONT COLOR="FF0000"><code> $var++</code></FONT> the variable, rather than <B>preincrementing</B> it.
</P><P>
The difference is that with postincrements, the value of the variable is returned, then the operation is performed on it.  So in the example above, the current value of <FONT COLOR="FF0000"><code> $var </code></FONT> was returned to the <FONT COLOR="FF0000"><code> print </code></FONT> function, then 1 was added.  You can prove this to yourself by adding the line
<FONT COLOR="0000FF"><code> print "\$var is now $var\n"; </code></FONT> to the end of the example above.
</P><P>
If we want the operation to be performed on <FONT COLOR="FF0000"><code> $var</code></FONT> before the value is returned to the print function, then preincrement is the way to go. <FONT COLOR="FF0000"><code> ++$var</code></FONT> will do the trick.
</P>

<BR><A NAME='42-SubroutinesAFirstLook'></A> <H2>Subroutines -- A First Look</H2>


<P>
Let's take a another look at the example we used to show how the autoincrement
system works. Messy, isn't it ? This is Batch File Writing Mentality. Notice
how we use exactly the same code four times. Why not just put it in a subroutine?
</P>
<FONT COLOR="0000FF"><pre>
$num=10;		# sets $num to 10
&amp;print_results;		# prints variable $num

$num++;
&amp;print_results;

$num*=3;
&amp;print_results;

$num/=3;
&amp;print_results;

sub print_results {
        print "\$num is $num\n";
}
</PRE></FONT>
<P>
Easier and neater. The subroutine can go anywhere in your script, at the
beginning, end, middle...makes no difference. Personally I put all mine
at the bottom and reserve the top part for setting variables and main program
flow.
</P><P>
A subroutine is just some code you want to use more than once in the same script.  In Perl, a subroutine is a user-defined function.  There is no difference.  For the purposes of clarity I'll refer to them as subroutines.
</P><P>
A subroutine is defined by starting with <FONT COLOR="FF0000"><code> sub </code></FONT> then the name.
After that you need a curly left bracket <FONT COLOR="FF0000"><code> { </code></FONT>, then 
all the code for your subroutine. Finish it off with a closing brace <FONT COLOR="FF0000"><code> } </code></FONT>. <B>The area between the two braces is called a block. </B>Remember this. There are such things as anonymous subroutines but not here. Everything here has a name.
</P><P>
Subroutines are usually called by prefixing their name with an ampersand, that is one of these -- <FONT COLOR="FF0000"><code> &amp; </code></FONT>, like
so <FONT COLOR="FF0000"><code> &amp;print_results; </code></FONT>. It used to be cool to omit the 
<FONT COLOR="FF0000"><code> &amp; </code></FONT> prefix but all perl hackers are now encouraged to use it to avoid ambiguity.  Ambiguity can hurt you if you don't avoid it.
</P><P>
If you are worrying about variable visibility, don't. All the variables
we are using so far are visible everywhere. You can restrict visibility
quite easily, but that's not important right now. If you weren't worrying
about variable visibility, please don't start. I'd tell you it's not important but that'll only make you worried. (paranoid ?)  We'll cover it later.
</P><P>


<BR><A NAME='43-Comments'></A> <H2>Comments</H2>


Did you see a <FONT COLOR="FF0000"><code> # </code></FONT> crept in there. That's a <B>comment.</B> Everything after
a <FONT COLOR="FF0000"><code> # </code></FONT> is ignored. You can't continue it onto a newline however,
so if your comment won't fit on one line start a new one with <FONT COLOR="FF0000"><code> # </code></FONT>.
There are ways to create Plain Old Documentation (POD) and more ways to
comment but they are not detailed here.
</P>


<BR><A NAME='44-Comparisons'></A> <H1>Comparisons</H1>


<BR><A NAME='45-Aniffystart'></A> <H2>An iffy start</H2>

An <FONT COLOR="FF0000"><code> if </code></FONT> statement is simple. 
<code>if the day is Sunday, then lie in bed</code>. A simple
test, with two outcomes. Perl conversion (don't run this):
<PRE>
if ($day eq "sunday") {
	&amp;lie_in_bed;
}
</PRE>
You already know that <FONT COLOR="FF0000"><code>&amp;lie_in_bed </code></font>is a call to a subroutine.
We assume <FONT COLOR="FF0000"><code>$day </code></FONT> is set earlier in the program. If 
<FONT COLOR="FF0000"><code>$day </code></FONT> is
not equal to 'Sunday' <FONT COLOR="FF0000"><code>&amp;lie_in_bed </code></FONT>
is not executed (pity). You don't need to say anything else. Try this:
<FONT COLOR="0000FF"><pre>
$day="sunday";

if ($day eq "sunday") {
        print "Zzzzz....\n";
}
</PRE></FONT>
Note the syntax. The <FONT COLOR="FF0000"><code> if </code></FONT> statement requires something to test for
Truth. This expression must be in (parens), then you have the braces to
form a block.


<BR><A NAME='46-TheTruthAccordingtoPerl'></A> <H2>The Truth According to Perl</H2>


<P>There are many Perl functions which test for Truth. Some are 
<FONT COLOR="FF0000"><code> if, while, unless </code></FONT>. So it is important you know what truth is, as defined
by Perl, not your tax forms. There are three main rules:
<OL>
<LI>Any string is true except for <FONT COLOR="FF0000"><code>""</code></FONT> and <FONT COLOR="FF0000"><code>"0"</code></FONT>.</LI>
<LI>Any number is true except for <FONT COLOR="FF0000"><code>0</code></FONT>. This includes negative numbers.</LI>
<LI>Any undefined variable is false.  A undefined variable is one which doesn't have a value, ie has not been assigned to.
</OL>
Some example code to illustrate the point:
<FONT COLOR="0000FF"><pre>
&amp;isit;                   # $test1 is at this moment undefined

$test1="hello";         # a string, not equal to "" or "0"
&amp;isit;

$test1=0.0;             # $test1 is now a number, effectively 0
&amp;isit;

$test1="0.0";           # $test1 is a string, but NOT effectively 0 !
&amp;isit;

sub isit {
        if ($test1) {                           # tests $test1 for truth or not
                print "$test1 is true\n";
        } else {                                # else statement if it is not true
                print "$test1 is false\n";
        }
}</PRE></FONT>

The first test fails because <FONT COLOR="FF0000"><code> $test1 </code></FONT> is undefined. 
This means it has not been created by assigning a value to it. So according to Rule 3
it is false. The last two tests are interesting.  Of course, 0.0 is the
same as 0 in a <I>numeric</I> context. But it is <I>not</I> the same as
0 in a string context, so in that case it is true.
</P><P>
So here we are testing single variables. What's more useful is testing
the result of an expression. For example, this is an expression; 
<FONT COLOR="FF0000"><code> $x * 2 </code></FONT>and so is this; 
<FONT COLOR="FF0000"><code> $var1 + $var2 </code></FONT>. It is the <B>end result
of these expressions that is evaluated for truth.</B>
</P><P>
An example demonstrates the point:
<FONT COLOR="0000FF"><pre>
$x=5;
$y=5;

if ($x - $y) {
        print '$x - $y is ',$x-$y," which is true\n";
} else {
        print '$x - $y is ',$x-$y," which is false\n";
}
</PRE></FONT>
<P>
The test fails because 5-5 of course is 0, which is false.  The
<FONT COLOR="FF0000"><code> print </code></FONT> statement might look a little strange.  Remember that <FONT COLOR="FF0000"><code> print </code></FONT> is a list operator?  So we hand it a list. First item, a single-quoted string.  It is single quoted because it we do not want to perform variable interpolation on it.  Next item is an <B>expression</B> which is evaluated, and the result printed.  Finally, a double-quoted string is used because we want to print a newline, and without the doublequotes the <FONT COLOR="FF0000"><code> \n </code></FONT> won't be interpolated.
</P><P>
What is probably more useful than testing a specific variable for truth is equality testing.  For example, has your lucky number been drawn?

<FONT COLOR="0000FF"><pre>
$lucky=15;
$drawnum=15;

if ($lucky == $drawnum) {
        print "Congratulations!\n";
} else {
        print "Guess who hasn't won!\n";
}
</PRE></FONT>
<P>
The important point about the above code is the equality operator,
<FONT COLOR="FF0000"><code> == </code></FONT>. 
</P><P>


<BR><A NAME='47-EqualityandPerl'></A> <H2>Equality and Perl</H2>

Now pay close attention, otherwise you'll end up posting an annoying
question somewhere. This is a FAQ, as in a Frequently Asked Question.
</P><P>
The symbol <FONT COLOR="FF0000"><code> = </code></FONT> is an 
<B>assignment operator, <I>not</I> a comparison operator.</B> Therefore:
<UL>
<LI><FONT COLOR="FF0000"><code>if ($x = 10)</code></FONT> is always true, because 
<FONT COLOR="FF0000"><code>$x </code></FONT> has been <I>assigned</I> the value 10 successfully.</LI>
<LI><FONT COLOR="FF0000"><code>if ($x == 10) </code></FONT><I>compares</I> the two values, which might not be equal.</LI>
</UL>
<P>
So far we have been testing numbers, but there is more to life than numbers.  There are strings too, and these need testing too.
</P><P>
<FONT COLOR="0000FF"><pre>
$name	 = 'Mark';

$goodguy = 'Tony';

if ($name == $goodguy) {
        print "Hello, Sir.\n";
} else {
        print "Begone, evil peon!\n";
}
</PRE></FONT>
</P><P>
Something seems to have gone wrong here. Obviously Mark is different to Tony, so why does perl consider them equal?
</P><P>
Mark and Tony <I>are</I> equal -- numerically.  We should be testing them as strings, not as numbers.  To do this, simply substitute <FONT COLOR="FF0000"><code> == </code></FONT> for
<FONT COLOR="FF0000"><code> eq </code></FONT> and everything will work as expected.
</P><P>

<BR><A NAME='48-AllEqualityisNotEqualNumericversusString'></A> <H3>All Equality is Not Equal: Numeric versus String</H3>

There are two types of comparison operator; <B>numeric</B> and <B>string</B>.
You've already seen two, <FONT COLOR="FF0000"><code>== </code></FONT>and 
<FONT COLOR="FF0000"><code>eq</code></FONT>. Run this:

<FONT COLOR="0000FF"><pre>
$foo=291;
$bar=30;

if ($foo &lt; $bar) { 
        print "$foo is less than $bar (numeric)\n"; 
}

if ($foo lt $bar) { 
        print "$foo is less than $bar (string)\n"; 
}
</PRE></FONT>
</P><P>
The <FONT COLOR="FF0000"><code>lt</code></FONT> operator compares in a string context, and of course
<FONT COLOR="FF0000"><code> &lt; </code></FONT> compares in a numeric context.
</P><P>
Alphabetically, that is in a string context, 291 comes before 30. It is
actually decided by the ASCII value, but alphabetically is close enough.
Change the numbers around a little. Notice how Perl doesn't care whether
it uses a string comparison operator on a numeric value, or vice versa.
<B>This is typical of Perl's flexibility.</B> 
</P><P>
Bondage and discipline are pretty much 
alien concepts to Perl (and the author). This flexibility does have a drawback. If you're
on a programming precipice, threatening suicide by jumping off, Perl won't
talk you out of your decision but will provide several ways of jumping,
stepping or falling to your doom while silently watching your early conclusion.
So be careful.
</P><P>

<BR><A NAME='49-AninterludeThePerlMotto'></A> <H2>An interlude -- The Perl Motto</H2>

<B>The Perl Motto is; "There is More Than One Way to Do It"</B> or
TIMTOWTDI. Pronounced 'Tim-Toady'. This tutorial doesn't try and mention
all possible ways of doing everything, mainly because the author is far too lazy. 
Write your Perl programs the way you want to.
</P><P>

<BR><A NAME='50-TheComparisonOperatorsListed'></A> <H2>The Comparison Operators Listed</H2>

The rest of the operators are:
<TABLE BORDER=1 CELLSPACING=4 CELLPADDING=4>
<TR>
<TD><I>Comparison</I></TD>
<TD><I>Numeric</I></TD>
<TD><I>String</I> </TD>
</TR>

<TR>
<TD>Equal</TD>
<TD ALIGN=CENTER>==</TD>
<TD ALIGN=CENTER>eq </TD>
</TR>

<TR>
<TD>Not equal</TD>
<TD ALIGN=CENTER>!=</TD>
<TD ALIGN=CENTER>ne </TD>
</TR>

<TR>
<TD>Greater than</TD>
<TD ALIGN=CENTER>&gt;</TD>
<TD ALIGN=CENTER>gt </TD>
</TR>

<TR>
<TD>Less than</TD>
<TD ALIGN=CENTER>&lt;</TD>
<TD ALIGN=CENTER>lt </TD>
</TR>

<TR>
<TD>Greater than or equal to</TD>
<TD ALIGN=CENTER>&gt;=</TD>
<TD ALIGN=CENTER>ge </TD>
</TR>

<TR>
<TD>Less than or equal to</TD>
<TD ALIGN=CENTER>&lt;=</TD>
<TD ALIGN=CENTER>le </TD>
</TR>
</TABLE>
<P>

<BR><A NAME='51-TheGoldenRuleofComparisons'></A> <H3>The Golden Rule of Comparisons</H3>

They may be odious, but remember the following:
<UL>
<LI>if you are testing a value <B>as a string</B> there should be only <B>letters</B>
in your comparison operator.</LI>

<LI>if you are testing a value <B>as a number</B> there should only be <B>non-alpha</B>
characters in your comparison operator</LI>

<LI>note 'as a' above. You can test numbers as string and vice versa. Perl
never complains.</LI>
</UL>

<BR><A NAME='52-MoreAboutIfMultiples'></A> <H2>More About If: Multiples</H2>


<P>More about <FONT COLOR="FF0000"><code> if </code></FONT> statements. Run this:
<FONT COLOR="0000FF"><pre>
$age=25;
$max=30;

if ($age > $max) {
        print "Too old !\n";
} else {
        print "Young person !\n";
}
</PRE></FONT>
It is easy to see what <FONT COLOR="FF0000"><code> else </code></FONT> does. If the expression is false then
whatever is in the  <FONT COLOR="FF0000"><code>else </code></FONT> block is evaluated
(or carried out, executed, whatever term you choose to use). 
Simple. But what if you want another test ? Perl can do that too.



<BR><A NAME='53-elsif'></A> <H3>elsif</H3>



<FONT COLOR="0000FF"><pre>

$age=25;
$max=30;
$min=18;

if ($age > $max) {
        print "Too old !\n";
} elsif ($age &lt; $min) { 
        print "Too young !\n"; 
} else { 
        print "Just right !\n"; 
}
</PRE></FONT>

If the first test fails, the second is evaluated. This carries on until
there are no more <FONT COLOR="FF0000"><code> elsif </code></FONT> statements, or an 
<FONT COLOR="FF0000"><code> else </code></FONT> statement is reached. An 
<FONT COLOR="FF0000"><code> else </code></FONT>statement is optional, and no
<FONT COLOR="FF0000"><code> elsif </code></FONT> statements should come after it. Logical, really.
</P><P>
There is a big difference between the above example the one below:
<P>
<FONT COLOR="0000FF"><pre>
if ($age &gt; $max) {
        print "Too old !\n";
} 

if ($age &lt; $min) {
        print "Too young !\n";
}
</PRE></FONT>
</P><P>
If you run it, it will return the same result - in this case. However, it is Bad Programming
Practice. In this case we are testing a number, but suppose we were testing
a string to see if it contained R or S. It is possible that a string could
contain <I>both</I> R and S. So it would pass both 'if' tests. Using an
<FONT COLOR="FF0000"><code> elsif </code></FONT> avoids this. As soon as the first statement is true, no
more <FONT COLOR="FF0000"><code> elsif </code></FONT> statements (and no <FONT COLOR="FF0000"><code> else </code></FONT> statement) are executed.

<P>You don't need to take up a whole three lines:
<BR>
<FONT COLOR="0000FF"><pre>
print "Too old\n" if     $age &gt; $max;
print "Too old\n" unless $age &lt; $max;
</pre></font>
</P><P>
I added some whitespace there for aesthetic beauty.  There are other
operators that you can use instead of <FONT COLOR="FF0000"><code> if </code></FONT> and 
<FONT COLOR="FF0000"><code> unless </code></FONT>, but that's for later on.
</P><P>
Incidentally, the two lines of code above do not do exactly the same thing. Consider a maximum age of 50 and input age of 50.  Therefore, you should be very careful about your logic when writing code (nice obvious statement there).
</P><P>
For those that were wondering, Perl has no case statement.  This is all explained in the FAQ, which is located at http://www.perl.com/.
</P>


<BR><A NAME='54-UserInput'></A> <H1>User Input</H1>

<BR><A NAME='55-STDINandotherfilehandles'></A> <H2>STDIN and other filehandles</H2>

Sometimes you have to interact with the user. It is a pain, but sometimes
necessary, especially for the live ones. To ask for input and do something
with it try this:

<FONT COLOR="0000FF"><pre>
print "Please tell me your name: ";
$name=&lt;STDIN&gt;;
print "Thanks for making me happy, $name !\n";
</PRE></FONT>
New things to learn here. Firstly, 
<FONT COLOR="FF0000"><code> &lt;STDIN&gt; </code></FONT>. STDIN is a filehandle. Filehandles are what you use to interact with things such as files, console input, socket connections and more.
</P><P>
You could say STDIN is the standard source for input.  Guess what STDIN stands for. In this case the STDIN filehandle is reading from the console.
</P><P>
The angle brackets 
<FONT COLOR="FF0000"><code> &lt;&gt; </code></FONT> read data from a filehandle. Exactly how much is dependent on what you do, but in this case it is whatever was input at the prompt.
</P><P>
So we are reading from the STDIN filehandle. The value is assigned to
<FONT COLOR="FF0000"><code> $name </code></FONT> and printed. Any idea why the ! ends up on a new line ?
on a <I>new line</I> on a <B>newline</B> ????
</P><P>
As you pressed Enter, you of course included a newline with your name.
The easy way to get rid of it is to <FONT COLOR="FF0000"><code> chop </code></FONT> it off:


<BR><A NAME='56-Chop'></A> <H2>Chop</H2>

<FONT COLOR="0000FF"><PRE>
print "Please tell me your name: ";
$name=&lt;STDIN&gt;;
chop $name
print "Thanks for making me happy, $name !\n"
</PRE></FONT>
and that fails with a syntax error. Can you spot why?  Look at the error code, look at the line number and see where the syntax is wrong.  The answer is a missing semicolon (<code> ; </code>) on the end of the last two lines.
</P><P>
If you add a <code> ; </code> to the end of line 3, but not to the last line, then the program works as it should.  This is because Perl doesn't need a semicolon to end the last statement of a block.  However, I'd advise ending all your statements with semicolons because you may well be adding more code to them and it is only one little keystroke.
</P><P>
When you add the semicolon(s), the program runs correctly. The <FONT COLOR="FF0000"><code> chop </code></FONT> function removes the last character of whatever it is given to chop, in this case removing the newline for us. In fact, that can be shortened:
<FONT COLOR="0000FF">
<PRE>
print "Please tell me your name: ";
chop ($name=&lt;STDIN&gt;);
print "Thanks for making me happy, $name !";
</PRE>
</FONT>
</P><P>
The parentheses <FONT COLOR="FF0000"><code> ( ) </code></FONT>
 force <FONT COLOR="FF0000"><code> chop </code></FONT>to act on the result of what is
inside them. So <FONT COLOR="FF0000"><code> $name=&lt;STDIN&gt; </code></FONT> is evaluated first, then the
result from that, which is <FONT COLOR="FF0000"><code> $name </code></FONT>, is chopped.  Try it without.
</P><P>
You can read from STDIN as much as you like.  For your entertainment I have created a sophisticated multinational greeting machine:

<FONT COLOR="0000FF">
<PRE>
print "Please tell me your name: ";
chop ($name=&lt;STDIN&gt;);

print "Please tell me your nationality: ";
chop ($nation=&lt;STDIN&gt;);

if ($nation eq "British" or $nation eq "New Zealand") {
	print "Hallo $name, pleased to meet you!\n";

} elsif ($nation eq "Dutch" or $nation eq "Flemish") {
	print "Hoi $name, hoe gaat het met u vandaag?!\n";

} else {
	print "HELLO!!!  SPEAKEEE ENGLIEESH???\n";
}
</PRE></FONT>
</P><P>
Aside from demonstrating the native English speaker's linguistic talents, this script also introduces the <FONT COLOR="FF0000"><code> or </code></FONT> logical operator.  We'll cover 
<FONT COLOR="FF0000"><code> or </code></FONT> and its associates in more detail later on. First, a word of warning.
</P><P>
Chopping is dangerous, as my friend One Hand Harold will tell you. Everyone
is concerned about various forms of safety these days, and your perl code should be no
exception.
</P><P>

<BR><A NAME='57-SafeChoppingwithChomp'></A> <H3>Safe Chopping with Chomp</H3>

Rather than just wantonly remove the last character regardless
of whatever it is, without a care in the world, just simply consigning the poor little thing to the Great Bit Bucket in the Sky, you can remove the last character only if it is a newline
with <FONT COLOR="FF0000"><code> chomp </code></FONT>:
<FONT COLOR="0000FF"><pre>
chomp ($name=&lt;STDIN&gt;);</CODE></FONT>
</pre></font>
<P>At this point the perl gurus are screaming "I found an error !". 
Well, <FONT COLOR="FF0000"><code> chomp </code></FONT> doesn't always remove the last character if it is a newline
but if it doesn't, you have set a special variable, namely <FONT COLOR="FF0000"><code> $/ </code></FONT>, to something
different.  I presume that if you do set <FONT COLOR="FF0000"><code> $/ </code></FONT> you know what it does.
It is explained later in this very document. Of course, being a good pupil, you wouldn't experiment
with the unknown, blindly changing things just for the hell of it to see what happens.
</P><P>
If you don't, you'll never learn anything useful.
</P>

<BR><A NAME='58-Arrays'></A> <H1>Arrays</H1>


<BR><A NAME='59-Listsherdswhatarearrays'></A> <H2>Lists, herds -- what are arrays?</H2>

<P>
Perl has two types of array, associative arrays (hashes) and arrays. Both
types are lists. A list is just a collection of variables referred to as the collection, not as individual elements.
</P><P>
You can think of Perl's lists as a herd of animals.  List context refers to the entire herd, scalar context refers to a single element.  A list is a herd of variables.  The variables don't have to be all of the same type -- you might have a herd of ten sheep, three lions and two wolves. It would probably be just three lions and one wolf before long, but bear with me.  In the same way, you might have a Perl list of three scalar variables, two array elements and ten hash elements.
</P><P>
Certain types of lists are known by certain names.  Just as a herd of sheep is called a flock, a herd of lions is called a pride, a herd of wolves is called a pack and a herd of managers a confusion, some types of Perl list have a special names.
</P><P>

<BR><A NAME='60-BasicArrayWork'></A> <H3>Basic Array Work</H3>

For example, an <B>array is an ordered list of scalar variables</B>. This list can
be referred to as a whole, or you can refer to individual elements in the
list. The program below defines a an array, called <FONT COLOR="FF0000"><code> @names  </code></FONT>. It puts five values into the array.
<PRE>
<FONT COLOR="0000FF">
@names=("Muriel","Gavin","Susanne","Sarah","Anna");

print "The elements of \@names are @names\n";
print "The first element is $names[0] \n";
print "The third element is $names[2] \n";
print 'There are ',scalar(@names)," elements in the array\n";
</FONT>
</PRE>
</P><P>
Firstly, notice how we define <FONT COLOR="FF0000"><code> @names </code></FONT>. <B>As it is in a list context,
we are using parens.</B> Each value is <B>comma separated, which is Perl's
default list delimiter.</B> The double quotes are not necessary, but as
these are string values it makes it easier to read and change later on.
</P><P>
Next, notice how we print it. Simply refer to it as a whole, that is
in <B>list context.</B>. List context means referring to more than one
element of a list at a time. The code 
<FONT COLOR="FF0000"><code> print @names; </code></FONT> will work
perfectly well too. But....
</P><P>
I usually learn something about Perl every time I work with it.  When running a course, 
a student taught me this trick which he had discovered:
<PRE><FONT COLOR="0000FF">
@names=("Muriel","Gavin","Susanne","Sarah","Anna","Paul","Trish","Simon");

print @names;
print "\n";
print "@names";
</PRE></font>
When a list is placed inside doublequotes, it is space delimited when interpolated.  Useful.
</P><P>
If we want to do anything with the array as a <B>list</B>,
that is doing something with <B>more than one value</B>, then refer to the array
as <FONT COLOR="FF0000"><code> @array </code></FONT>. That's important. The
<FONT COLOR="FF0000"><code> @ </code></FONT> prefix is used when you want to refer to more than one element of a list. 
</P><P>
When you refer to more than one, but not all elements of an array that is known as a <B>slice </B>. Cake analogies are appropriate. Pie analogies are probably
healthier but equally accurate.
</P><P>

<BR><A NAME='61-ElementsofArrays'></A> <H2>Elements of Arrays</H2>

Arrays are not much use unless we can get to individual elements. Firstly,
we are dealing with a single element of the list, so we cannot use <FONT COLOR="FF0000"><code> @ </code></FONT> which refers to multiple elements of the array. <B>It is a single,
scalar variable, so <FONT COLOR="FF0000"><code> $ </code></FONT> is used.</B> Secondly, we must specify which
element we want. That's easy - <FONT COLOR="FF0000"><code> $array[0] </code></FONT> for the first,
<FONT COLOR="FF0000"><code> $array[1] </code></FONT>
for the second and so forth. Array indexes start at 0, unless you do something
which is so highly deprecated ('deprecated' means allowed, usually for backwards
compatibility, but disapproved of because there are better ways) I'm not
even going to mention it.
</P><P>
Finally, we force what is normally list context (more than one element)
into scalar context (single element) to give us the amount of elements
in the array. Without the <FONT COLOR="FF0000"><code> scalar </code></FONT>, it would be the same as the
second line of the program.

<BR><A NAME='62-Howtorefertoelementsofanarray'></A> <H3>How to refer to elements of an array</H3>

<P>Please understand this:
<P>
<FONT COLOR="0000FF"><pre>
$myvar="scalar variable";
@myvar=("one","element","of","an","array","called","myvar");

print $myvar;        # refers to the contents of a scalar variable called myvar
print $myvar[1];     # refers to the second element of the array myvar
print @myvar;        # refers to all the elements of array myvar

</pre></font>

<P>The two variables <FONT COLOR="FF0000"><code> $myvar </code></FONT> and  
<FONT COLOR="FF0000"><code> @myvar </code></FONT>
are not, in any way, related.  Not even distantly. Technically, they are in different <B>namespaces.</B>
<P>
Going back to the animal analogy, it is like having a dog named 'Myvar' and a goldfish called 'Myvar'.  You'll never get the two mixed up because when you call 'Myvar !!!!' or open a can of dog food the 'Myvar' dog will come running and goldfish won't.  Now, you couldn't have two dogs called 'Myvar' and in the same way you can't have two Perl variables in the same namespace called 'Myvar'.
<BR> 

<BR><A NAME='63-Morewaystoaccessarrays'></A> <H2>More ways to access arrays</H2>

The element number can be a variable.

<FONT COLOR="0000FF"><pre>
print "Enter a number :";
chomp ($x=&lt;STDIN&gt;);

@names=("Muriel","Gavin","Susanne","Sarah","Anna");

print "You requested element $x who is $names[$x]\n";

print "The index number of the last element is $#names \n";

</PRE></FONT>

This is useful. Notice the last line of the example. It returns the index
number of the last element. Of course you could always just do this 
<FONT COLOR="FF0000"><code> $last=scalar(@names)-1; </code></FONT>
but this is more efficient. It is an easy way to get the last element,
as follows:

<PRE><FONT COLOR="0000FF">
print "Enter the number of the element you wish to view :";
chomp ($x=&lt;STDIN&gt;);

@names=("Muriel","Gavin","Susanne","Sarah","Anna","Paul","Trish","Simon");

print "The first two elements are @names[0,1]\n";
print "The first three elements are @names[0..2]\n";
print "You requested element $x who is $names[$x-1]\n";		# starts at 0
print "The elements before and after are : @names[$x-2,$x]\n";
print "The first, second, third and fifth elements are @names[0..2,4]\n";

print "a) The last element is $names[$#names]\n";	# one way
print "b) The last element is @names[-1]\n";		# different way 

</PRE></font>

It looks complex, but it is not. Really. Notice you can have multiple values separated
by a comma. As many as you like, in whatever order. The range operator
<FONT COLOR="FF0000"><code> .. </code></FONT> gives you everything between and including the values. And
finally look at how we print the last element - remember  <FONT COLOR="FF0000"><code> $#names </code></FONT> gives
us a number ? Simply enclose it inside square brackets and you have the
last element.

<P>Do also note that because element accesses such as <FONT COLOR="FF0000"><code> [0,1] </code></FONT> are more than
one variable, we cannot use the scalar prefix, namely the <FONT COLOR="FF0000"><code> $ </code></FONT> symbol. <B>We
are accessing the array in list context, so we use the <FONT COLOR="FF0000"><code> @ </code></FONT> symbol.</B> Doesn't
matter that it is not the entire array. Remember, accessing more than one
element of an array but not the entire array is called a slice.  I won't go over the food analogies again.
<P>

<BR><A NAME='64-ForLoops'></A> <H2>For Loops</H2>

<BR><A NAME='65-AforLoopdemonstrated'></A> <H3>A for Loop demonstrated</H3>

All well and good, but what if we want to load each element of the array
in turn ? Well, we could build a for loop like this:
<FONT COLOR="0000FF"><PRE>
@names=("Muriel","Gavin","Susanne","Sarah","Anna","Paul","Trish","Simon");

for ($x=0; $x &lt;= $#names; $x++) {
        print "$names[$x]\n"; 
}
</PRE></FONT>
which sets <FONT COLOR="FF0000"><code> $x </code></FONT> to 0, runs the loop once, then adds one to 
<FONT COLOR="FF0000"><code> $x </code></FONT>, checks it
is less than <FONT COLOR="FF0000"><code> $#names </code></FONT>, if so carries on. By the way, that was your introduction
to <FONT COLOR="FF0000"><code> for </code></FONT> loops. Just to go into a little detail there, the 
<FONT COLOR="FF0000"><code> for </code></FONT> loop has three parts to it:
<UL>
<LI>Initialisation</LI>
<LI>Test Condition</LI>
<LI>Modification</LI>
</UL>
In this case, the variable <FONT COLOR="FF0000"><code> $x </code></FONT> is initialised to 0. It is immediately tested to see
if it is smaller than, or equal to <FONT COLOR="FF0000"><code> $#names </code></FONT>.  If that is true, then the block is executed once.  Critically, if it is <I>not</I> true the block is <I>not</I> executed at all.
<P>
Once the block has been executed, the modification expression is evaluated.  That's 
<FONT COLOR="FF0000"><code> $x++ </code></FONT>.  Then, the test condition is checked to see if the block should be executed or not.




<BR><A NAME='66-Forloopswiththerangeoperator'></A> <H3>For loops with .. , the range operator</H3>



<P>There is a another version:
<FONT COLOR="0000FF"><pre>
for $x (0 .. $#names) {
        print "$names[$x]\n";
}
</PRE></font>
which takes advantage of the range operator <FONT COLOR="FF0000"><code> .. </code></FONT> (two dots together).
This simply gives <FONT COLOR="FF0000"><code> $x </code></FONT> the value of 0, then increments 
<FONT COLOR="FF0000"><code> $x </code></FONT> by 1 until it is equal to <FONT COLOR="FF0000"><code> $#names</code></FONT> .



<BR><A NAME='67-foreach'></A> <H3>foreach</H3>



<P>For true beauty we must use <FONT COLOR="FF0000"><code> foreach </code></FONT>.
<FONT COLOR="0000FF"><PRE>
foreach $person (@names) {
        print "$person";
}
</PRE></FONT>
This goes through each element ('iterates', another good technical word to use) of 
<FONT COLOR="FF0000"><code> @names </code></FONT>, and assigns each element in turn to the variable
<FONT COLOR="FF0000"><code> $person </code></FONT>. 
Then you can do what you like with the variable. Much easier. You can use
<FONT COLOR="0000FF"><PRE>
for $person (@names) {
        print "$person";
}
</PRE></FONT>
if you want. Makes no difference at all, aside from a little clarity.





<BR><A NAME='68-Theinfamous_'></A> <H3>The infamous $_</H3>




<P>In fact, that gets shorter. And now I need to introduce you to <FONT COLOR="FF0000"><code> $_ </code></FONT>, 
which is the <B>Default Input and Pattern Searching Variable.</B>

<FONT COLOR="0000FF"><PRE>
foreach (@names) {
        print "$_";
}
</PRE></FONT>
If you don't specify a variable to put each element into, <FONT COLOR="FF0000"><code> $_ </code></FONT> is
used instead as it is the default for this operation, and many, many others
in Perl. Including the <FONT COLOR="FF0000"><code> print </code></FONT> function :
<FONT COLOR="0000FF"><PRE>
foreach (@names) {
        print ;
}
</PRE></FONT>
As we haven't supplied any arguments to <FONT COLOR="FF0000"><code> print </code></FONT>, 
<FONT COLOR="FF0000"><code> $_ </code></FONT> is printed as default. You'll
be seeing a lot of <FONT COLOR="FF0000"><code> $_ </code></FONT> in Perl. Actually, that statement is not exactly true. 
You will be seeing lot of places where <FONT COLOR="FF0000"><code> $_ </code></FONT> is used, but quite often when
it is used, it is not actually written.  In the above example, you
don't actually see <FONT COLOR="FF0000"><code> $_ </code></FONT> but you know it is there.





<BR><A NAME='69-APrematureEndtoyourloop'></A> <H3>A Premature End to your loop</H3>




A loop, by its nature, continues.  If that didn't make sense, start reading this sentence again.
</P><P>
The old jokes are the best, aren't they?  
</P><P>
The joke above is a loop. You continue re-reading the sentence until you realise I'm trying to be funny.  Then you exit the loop.  Or maybe somebody doesn't exit it.  Whatever, loops always run until the expression they are testing returns false.  In the case of the examples above, a false value is returned when all the elements of the array have been cycled through, and the loop ends.
</P><P>
If you want an everlasting loop, just test an condition you know will always be true:
<FONT COLOR="0000FF"><PRE>
while (1) {
	$x++;
        print "$x:  Did you know you can press CTRL-C to interrupt a perl program?\n";
}
</PRE></FONT>
Another way to exit a loop is a simple <FONT COLOR="FF0000"><code> foreach </code></FONT> over the elements, as we have seen.  But if we don't know when we want to exit a loop? For example, suppose we want to print out a list of names but stop when we find one with a particular title?  You are throwing a huge party, someone is allergic to vodka, and this person has drunk from the punch bowl despite being assured by someone holding two empty bottles of Absolut that he was just using the bottles to convey yet more orange juice into said punch bowl.  So you need a doctor, and so you write a Perl script to find one from the list of attendees, wanting the doctor's name to be the last item printed:
<FONT COLOR="0000FF"><PRE>
@names=('Mrs Smith','Mr Jones','Ms Samuel','Dr Jansen','Sir Philip');

foreach $person (@names) {
	print "$person\n";
	last if $person=~/Dr /;
}
</PRE></FONT>
The <FONT COLOR="FF0000"><code> last </code></FONT> operator is our friend.  Don't worry about the <code> /Dr /</code> business -- that is a regular expression which we cover next.  All you need to know is that it returns true if the name begins with 'Dr '.  When it does return true, 
<FONT COLOR="FF0000"><code> last </code></FONT> is operated and the loop ends early.
</P><P>


<BR><A NAME='70-AlittlemorecontrolovertheprematureendingLabels'></A> <H4>A little more control over the premature ending: Labels</H4>




So that's easy enough.  But wait!  We need a medical, human-fixer type doctor, not just anyone with a PhD.  So, the same principle applies in this example here:
<FONT COLOR="0000FF"><PRE>
@names  =('Mrs Smith','Mr Jones','Ms Samuel','Dr Jansen','Sir Philip');
@medics =('Dr Black','Dr Waymour','Dr Jansen','Dr Pettle');

foreach $person (@names) {
	print "$person\n";
	if ($person=~/Dr /) {
		foreach $doc (@medics) {
			print "\t$doc\n";
			last if $doc eq $person;
		}
	}
}
</PRE></FONT>
Aside from showing one way to indent your code, this also demonstrates a nested loop.  A nested loop is a loop within a loop.  What happens is that the <code>@names</code> array is searched for a 'Dr ', and if it is found then the <code>@medics</code> array is searched to make sure the doctor is a human-fixing doctor not a professor of physics or something.  The regular expression has been shifted into an <FONT COLOR="FF0000"><code> if </code></FONT> statement, where it works nicely as it only returns true or false.
</P><P>
The problem with the code is that after we find our medical doctor we want it to stop.  But it doesn't.  It only stops the loop it is in, so Dr Pettle never gets printed.  However, the code just carries on with Sir Philip who is terribly sorry old chap, but can't be of any bally use at all, what ho!  What we need is a way to break out of the entire loop from within a nest.  Like so:
<FONT COLOR="0000FF"><PRE>
@names  =('Mrs Smith','Mr Jones','Ms Samuel','Dr Jansen','Sir Philip');
@medics =('Dr Black','Dr Waymour','Dr Jansen','Dr Pettle');

LBL: foreach $person (@names) {
	print "$person\n";
	if ($person=~/Dr /) {
		foreach $doc (@medics) {
			print "\t$doc\n";
			last LBL if $doc eq $person;
		}
	}
}
</PRE></FONT>
Only two changes here.  We have defined a label, namely <code>LBL</code>.  Instead of breaking out from the current loop, which is the default, we specify a label to break out to, which is in the outer loop.  This works with as many nested loops as your brain can handle.  You don't have to use uppercase names but for namespace reasons it is recommended, and you can call your labels whatever you please.  I was just being unimaginative with the name of LBL, feel free to invent labels called DORIS or MATILDA if that's what floats your personal boat.
</P>

<BR><A NAME='71-ChangingtheElementsofanArray'></A> <H2>Changing the Elements of an Array</H2>


So we have <FONT COLOR="FF0000"><code> @names </code></FONT>. We want to change it. Run this:
<FONT COLOR="0000FF"><PRE>
print "Enter a name :";
chomp ($x=&lt;STDIN&gt;);

@names=("Muriel","Gavin","Susanne","Sarah");

print "@names\n";

push (@names, $x);

print "@names\n";
</PRE></FONT>
Fairly self explanatory. The <FONT COLOR="FF0000"><code> push </code></FONT> function just adds a value on to the end of the
array. Of course, Perl being Perl, it doesn't have to be just the one value:

<FONT COLOR="0000FF"><PRE>
print "Enter a name :";
chop ($x=&lt;STDIN&gt;);

@names=("Muriel","Gavin","Susanne","Sarah");
@cities=("Brussels","Hamburg","London","Breda");

print "@names\n";

push (@names, $x, 10, @cities[2..4]);

print "@names\n";
</PRE></font>
This is worth looking at in more detail.  It appears there is no fifth element of 
<FONT COLOR="FF0000"><code> @cities </code></FONT>, as referred to by 
<FONT COLOR="FF0000"><code> @cities[2..4] </code></FONT>.  
<P>
Actually, there is a fifth element.  Add this to the end of the example :
<FONT COLOR="0000FF"><PRE>
print "There are ",scalar(@names)," elements in \@names\n";
</PRE></font>
There appear to be 8 elements in <FONT COLOR="FF0000"><code> @names </code></FONT>.  However, we have just proved there are in fact 9.  The reason there are 9 is that we referred to non-existent elements of <FONT COLOR="FF0000"><code> @cities </code></FONT>, and Perl has quite happily extended <FONT COLOR="FF0000"><code> @names </code></FONT> to suit. The array
<FONT COLOR="FF0000"><code> @cities </code></FONT> remains unchanged. Try <FONT COLOR="FF0000"><code>pop</code></FONT>ing the array if you don't believe me.

<P>
So that's <FONT COLOR="FF0000"><code> push </code></FONT>. Now for some...

<BR><A NAME='72-JiggerypokerywithArrays'></A> <H2>Jiggerypokery with Arrays</H2>

<FONT COLOR="0000FF"><PRE>
@names=("Muriel","Gavin","Susanne","Sarah");
@cities=("Brussels","Hamburg","London","Breda");

&amp;look;

$last=pop(@names);
unshift (@cities, $last);

&amp;look;

sub look {
        print "Names : @names\n";
        print "Cities: @cities\n";
}
</PRE></FONT>
Now we have two arrays. The <FONT COLOR="FF0000"><code> pop </code></FONT> 
function removes the last element of an array
and returns it, which means you can do something like assign the returned
value to a variable. The <FONT COLOR="FF0000"><code> unshift </code></FONT> function adds a value 
to the beginning of the array. Hope you didn't forget that 
<FONT COLOR="FF0000"><code> &amp;subroutinename </code></FONT>calls a subroutine.  Presented below are the functions you can use to work with arrays:



<BR><A NAME='73-Atableofarrayhackingfunctions'></A> <H3>A table of array hacking functions</H3>



<P> 
<TABLE BORDER CELLPADDING=3 >
<TR>
<TD>push</TD>
<TD>Adds value to the end of the array </TD>
</TR>

<TR>
<TD>pop</TD>
<TD>Removes and returns value from end of array </TD>
</TR>

<TR>
<TD>shift</TD>
<TD>Removes and returns value from beginning of array </TD>
</TR>

<TR>
<TD>unshift</TD>
<TD>Adds value to the beginning of array </TD>
</TR>
</TABLE>
<P>
Now, accessing other elements of arrays. May I present the <FONT COLOR="FF0000"><code>splice </code></FONT> function ?





<BR><A NAME='74-Splice'></A> <H3>Splice</H3>

<FONT COLOR="0000FF"><PRE>
@names=("Muriel","Sarah","Susanne","Gavin");

&amp;look;

@middle=splice (@names, 1, 2);

&amp;look;

sub look {
        print "Names : @names\n";
        print "The Splice Girls are: @middle\n";
}
</PRE></FONT>
The first argument for <FONT COLOR="FF0000"><code> splice </code></FONT> is an array. Then second is the offset.
The offset is the index number of the list element to begin splicing at. In this
case it is 1. Then comes the number of elements to remove, which is sensibly
1 or more in this case. You can set it to 0 and perl, in true perl style,
won't complain. Setting to 0 is handy because <FONT COLOR="FF0000"><code> splice </code></FONT> can add elements
to the middle of an array, and if you don't want any deleted 0 is the number
to use. Like so:

<FONT COLOR="0000FF"><PRE>
@names=("Muriel","Gavin","Susanne","Sarah");
@cities=("Brussels","Hamburg","London","Breda");

&amp;look;

splice (@names, 1, 0, @cities[1..3]);

&amp;look;

sub look {
        print "Names : @names\n";
        print "Cities: @cities\n";
}
</PRE></FONT>

Notice how the assignment to <FONT COLOR="FF0000"><code> @middle </code></FONT> has gone -- it is no longer relevant. 
</P><P>
If you assign the result of a <FONT COLOR="FF0000"><code> splice </code></FONT> to a scalar then:
</P>
<FONT COLOR="0000FF"><PRE>
@names=("Muriel","Sarah","Susanne","Gavin");

&amp;look;

$middle=splice (@names, 1, 2);

&amp;look;

sub look {
        print "Names : @names\n";
        print "The Splice Girls are: $middle\n";
}
</PRE></FONT>
then the scalar is assigned the last element removed, or undef if it doesn't work at all.
</P><P>
The
<FONT COLOR="FF0000"><code> splice </code></FONT> function
 is also a way to delete elements from an array. In fact, a
discussion of :





<BR><A NAME='75-DeletingVariables'></A> <H1>Deleting Variables</H1>




is in order. Suppose we want to delete Hamburg from the following array.
How do we do it ? Perhaps:

<FONT COLOR="0000FF"><PRE>
@cities=("Brussels","Hamburg","London","Breda");

&amp;look;

$cities[1]="";

&amp;look;

sub look {
	print "Cities: ",scalar(@cities), ": @cities\n";
}
</PRE></FONT>

<P>would be appropriate. Certainly Hamburg is removed. Shame, such a great
lake. But note, the array element still exists. There are still four elements
in <FONT COLOR="FF0000"><code> @cities</code></FONT>. So what we need is the appropriate 
<FONT COLOR="FF0000"><code> splice </code></FONT> function, which removes
the element entirely.

<FONT COLOR="0000FF"><PRE>
splice (@cities, 1, 1);
</pre></FONT>

<P>Now that's all well and good for arrays. What about ordinary variables,
such as these:

<FONT COLOR="0000FF"><PRE>
$car ="Porsche 911";
$aircraft="G-BBNX";

&amp;look;

$car="";

&amp;look;

sub look {
	print "Car :$car: Aircraft:$aircraft:\n";
	print "Aircraft exists !\n" if $aircraft;
	print "Car exists !\n" if $car;
}
</PRE></FONT>
<P>
It looks like we have deleted the <FONT COLOR="FF0000"><code> $car </code></FONT> variable. Pity. But think about
it. It is not deleted, it is just set to the null string "". As you recall
(hopefully) from previous ramblings, the null string evaluates to false
so the <FONT COLOR="FF0000"><code> if </code></FONT> test fails.




<BR><A NAME='76-FalsevaluesversusExistenceItistherefore'></A> <H3>False values versus Existence: It is, therefore...</H3>



<P>Just because something is false doesn't mean to say it doesn't exist.
A wig is false hair, but a wig exists. Your variable is still there. Perl
does have a function to test if something exists. Existence, in Perl terms,
means defined. So:

<FONT COLOR="0000FF"><PRE>
print "Car is defined !\n" if defined $car;
</PRE></FONT>

<P>will evaluate to true, as the <FONT COLOR="FF0000"><code> $car </code></FONT> variable does in fact exist.

<P>This begs the question of how to really wipe variables from the face
of the earth, or at least your Perl script. Simple.

<FONT COLOR="0000FF"><PRE>
$car 	 ="Porsche 911";
$aircraft="G-BBNX";

&amp;look;

undef $car; # this undefines $car

&amp;look;

sub look {
	print "Car :$car: Aircraft:$aircraft:\n";
	print "Aircraft exists !\n"  if $aircraft;
	print "Car exists !\n" 	     if defined $car;
}
</PRE></FONT>

<P>This variable <FONT COLOR="FF0000"><code> $car</code></FONT> is eradicated, deleted, killed,
destroyed.
<P>
And now for something completely different....
<BR>




<BR><A NAME='77-BasicRegularExpressions'></A> <H1>Basic Regular Expressions</H1>








<BR><A NAME='78-Anintroduction'></A> <H2>An introduction</H2>




Or <B>regex</B> for short. These can be a little intimidating. But I'll
bet you have already used some regex in your computing life so far. Have
you even said "I'll have any Dutch beer ?" That's a regex which will match
a Grolsch or Heineken, but not a Budweiser, orange juice or cheese toastie.
What about <TT>dir *.txt </TT>? That's a regular expression too, listing
any files ending in <TT>.txt.</TT>

<P>Perl's regex often look like this:

<FONT COLOR="0000FF"><PRE>
$name=~/piper/
</PRE></FONT>

<P>That is saying "If 'piper' is inside <FONT COLOR="FF0000"><code> $name</code></FONT>, then True." 
<P>
The regular expression itself is between <FONT COLOR="FF0000"><code> / / </code></FONT>
slashes, and the <FONT COLOR="FF0000"><code> =~ </code></FONT> operator assigns the target for the search.

<P>An example is called for. Run this, and answer it with 'the faq'. Then
try 'my tealeaves' and see what happens.
<FONT COLOR="0000FF"><PRE>
print "What do you read before joining any Perl discussion ? ";
chomp ($_=&lt;STDIN&gt;);

print "Your answer was : $_\n";

if ($_=~/the faq/) {
        print "Right !  Join up !\n";
} else {
        print "Begone, vile creature !\n";
}
</PRE></FONT>

So here <FONT COLOR="FF0000"><code> $_ </code></FONT> is searched for 'the faq'. Guess what we don't need ! The <FONT COLOR="FF0000"><code> =~ </code></FONT>. This works just as well:

<FONT COLOR="0000FF"><PRE>
if (/the faq/) {
</PRE></FONT>

because if you don't specify a variable, then perl searches <FONT COLOR="FF0000"><code> $_ </code></FONT> by default.
In this particular case, it would be better to use <FONT COLOR="0000FF"><PRE> if ($_ eq "the faq") { </PRE></FONT> as we are testing for exact matches.





<BR><A NAME='79-Senstivityregexesintouchwiththeirinnerchild'></A> <H2>Senstivity -- regexes in touch with their inner child</H2>




<P>But what if someone enters 'The FAQ' ? It fails, because the regex is case sensitive. We can easily fix that:

<FONT COLOR="0000FF"><PRE>
if (/the faq/i) {
</PRE></FONT>

with the <FONT COLOR="FF0000"><code> /i </code></FONT> switch, which specifies case-insensitivity. Now it works for
all variations, such as "the Faq" and "the FAQ".  
<P>
Now you can appreciate why a regular expression is better in this situation than a simple test using <FONT COLOR="FF0000"><code> eq </code></FONT>.  As the regex searches one string for another string, a response of "I would read the FAQ first !" will also work, because "the FAQ" will match the regex.

<P>
Study this example just to clarify the above. Tabs and spaces have been added for aesthetic beauty:
<FONT COLOR="0000FF"><PRE>
$_="perl for Win32";                            # sets the string to be searched

if ($_=~/perl/) { print "Found perl\n" };       # is 'perl' inside $_ ?  $_ is "perl for Win32".
if (/perl/)     { print "Found perl\n" };       # same as the regex above.  Don't need the =~ as we are testing $_
if (/PeRl/)     { print "Found PeRl\n" };       # this will fail because of case sensitivity
if (/er/)       { print "Found er\n" };         # this will work, because there is an 'er' in 'perl'
if (/n3/)       { print "Found n3\n" };         # this will work, because there is an 'n3' in 'Win32'
if (/win32/)    { print "Found win32\n" };      # this will fail because of case sensitivity
if (/win32/i)   { print "Found win32 (i)\n" };  # this will *work* because of case insensitivity (note the /i)

print "Found!\n"  if      / /;                  # another way of doing it, this time looking for a space

print "Found!!\n" unless $_!~/ /;		# both these are the same, but reversing the logic with unless and !
print "Found!!\n" unless    !/ /;		# don't do this, it will always never not confuse nobody :-)
						# the ~ stays the same, but = is changed to ! (negation)

$find=32;                                       # Create some variables to search for
$find2=" for ";                                 # some spaces in the variable too

if (/$find/)  { print "Found '$find'\n" };      # you can search for variables like numbers
if (/$find2/) { print "Found '$find2'\n" };     # and of course strings !

print "Found $find2\n" if /$find2/;           # different way to do the above
</PRE></FONT>
As you can see from the last example, you can embed a variable in the regex
too. Regular expressions could fill entire books (and they have done, see
the book critiques at http://www.perl.com/) but here are some useful tricks:




<BR><A NAME='80-CharacterClasses'></A> <H2>Character Classes</H2>




<FONT COLOR="0000FF"><PRE>
@names=qw(Karlson Carleon Karla Carla Karin Carina Needanotherword);

foreach (@names) {                      # sets each element of @names to $_ in turn
        if (/[KC]arl/) {                # this line will be changed a few times in the examples below
                print "Match !  $_\n";
        } else {
                print "Sorry.   $_\n";
        }
}
</PRE></FONT>
This time <FONT COLOR="FF0000"><code> @names </code></FONT> is initialised using whitespace as a delimiter
instead of a comma. <FONT COLOR="FF0000"><code> qw </code></FONT> refers to 'quote words', which means split
the list by words. A word ends with whitespace (like tabs, spaces, newlines etc).

<P>The square brackets enclose <B>single characters to be
matched</B>. Here either <FONT COLOR="FF0000"><code> Karl </code></FONT> or 
<FONT COLOR="FF0000"><code> Carl </code></FONT> must be in each element. It doesn't
have to be two characters, and you can use more than one set. Change Line
4 in the above program to:

<FONT COLOR="0000FF"><PRE>
if (/[KCZ]arl[sa]/) {
</pre></FONT>

<P>matches if something begins with K, C, or Z, then arl, then either s
or a. It does <I>not</I> match KCZarl. Negation is possible too, so try
this :
<FONT COLOR="0000FF"><PRE>
if (/[KCZ]arl[^sa]/) {</PRE>
</pre></FONT>

which returns things beginning with <B>K</B>, <B>C</B> or <B>Z</B>, then <B>arl</B>, and then anything
EXCEPT <B>s</B> or <B>a</B>. The caret <FONT COLOR="FF0000"><code> ^ </code></FONT> has to be the first 
character, otherwise it doesn't work as the negation. Having said <FONT COLOR="FF0000"><code> [ ] </code></FONT> 
defines single characters only, I should mention than these two are the same :
<FONT COLOR="0000FF"><PRE>
/[abcdeZ]arl/;
/[a-eZ]arl/;
</pre></FONT>

if you use a hyphen then you get the list of characters including the start
and finish characters. And if you want to match a special character (metacharacter),
you must escape it:
<FONT COLOR="0000FF"><PRE>
/[\-K]arl/;
</FONT></PRE>
matches <B>Karl</B> or <B>-arl</B>. Although the <FONT COLOR="FF0000"><code> - </code></FONT> character is 
<I>represented</I> by two characters, it is just the one character to match.


<BR><A NAME='81-Matchingatspecificpoints'></A> <H2>Matching at specific points</H2>


<P>If you want to match at the end of the line, make sure a <FONT COLOR="FF0000"><code> $ </code></FONT> is
the last character in the regex. This one pulls out all those names ending
in a. Slot it into the example above :

<FONT COLOR="0000FF"><PRE>
if (/a$/) {
</PRE></FONT>

<P>And there is a corresponding character, the caret <FONT COLOR="FF0000"><code> ^ </code></FONT>, which in this context
matches at the <B>beginning</B> of the string. Yes, the caret also negates a character
class like this <FONT COLOR="FF0000"><code> [^KCZ]arl </code></FONT> but in this case it <B>anchors </B>the
match to the beginning of the string.

<PRE><FONT COLOR="0000FF">
if (/n/i)  {
if (/^n/i) {
</PRE></FONT>
The first one is true if the word contains an 'n' anywhere in it. The second
specifies that the 'n' must be at the beginning of the string to be matched.  Use this anchor where you can, because it
makes the whole regex faster, and safer if you know what the first character must be.




<BR><A NAME='82-Negatingtheregex'></A> <H2>Negating the regex</H2>




<P>If you want to negate the entire regex change <FONT COLOR="FF0000"><code> =~ </code></FONT> to 
<FONT COLOR="FF0000"><code> !~ </code></FONT>
(Remember <FONT COLOR="FF0000"><code> ! </code></FONT> means 'not equal to'.)
<FONT COLOR="0000FF"><PRE>
if ($_ !~/[KC]arl/) {
</PRE></FONT>

Of course, as we are testing <FONT COLOR="FF0000"><code> $_ </code></FONT>  this works too:

<FONT COLOR="0000FF"><PRE>
if (!/[KC]arl/) {
</PRE></FONT>






<BR><A NAME='83-ReturningtheMatch'></A> <H2>Returning the Match</H2>





Now things get interesting. What if we want pull something out of a string
? So far all we have done is test for truth, that is say yea or nay if a string matches, but
not return what we found. Run this:

<FONT COLOR="0000FF"><PRE>
$_='My email address is &lt;Robert@NetCat.co.uk&gt;.';

/(&lt;robert\@netcat.co.uk&gt;)/i;

print "Found it ! $1\n";
</PRE></FONT>

Firstly, note the single quotes when <FONT COLOR="FF0000"><code> $_ </code></FONT> is assigned. 
<B>If there were double quotes, we'd need <FONT COLOR="FF0000"><code> \@ </code></FONT> instead of 
<FONT COLOR="FF0000"><code> @ </code></FONT></B>. Remember, double quotes 
<FONT COLOR="FF0000"><code> "" </code></FONT> allow
variable interpolation, so Perl looks for an array called 
<FONT COLOR="FF0000"><code> @NetCat </code></FONT> which does not exist.

<P>Secondly, look at the parens around the entire regex. If you use parens,
a side effect is that the first match is put into a variable called 
<FONT COLOR="FF0000"><code> $1 </code></FONT>.

We'll get to the main effect later. The second match goes into 
<FONT COLOR="FF0000"><code> $2 </code></FONT> and so
on. Also note that the <FONT COLOR="FF0000"><code> \@ </code></FONT> has been escaped, so perl 
doesn't think it is an array. Remember <FONT COLOR="FF0000"><code> \ </code></FONT> either escapes 
a special character, or gives a special meaning. Think of it as Superman's telephone box. Imagine Clark
Kent walking around with his magic partner Back Slash.

<P>
Notice how we specify in the regex case-<B>in</B>sensitivity with
<FONT COLOR="FF0000"><code> /i </code></FONT> and the regex
returns the case-<B>sensitive</B> string - that is, exactly what it found.

<P>
Try the regex without parens. Then try this one:
<FONT COLOR="0000FF"><PRE>
/&lt;(robert)\@netcat.co.uk&gt;/i;
</PRE></FONT>
You can put the parens anywhere. More or less. Now, run this :
<FONT COLOR="0000FF"><PRE>
$_='My email address is &lt;Robert@NetCat.co.uk&gt;.';

/&lt;(robert)\@(netcat.co.uk)&gt;/i;

print "Found it ! $1 at $2\n";
</PRE></FONT>
See, you can have more than one ! Look at the above regex. Looks easy now,
don't you think ? What about five minutes ago ? It would have looked like a typing mistake
! Well, there are some hairier regex to come, but you'll have a good barber.






<BR><A NAME='84-regexesbecomelinenoise'></A> <H2>* + -- regexes become line noise</H2>




<P>
What if we didn't know what the email address was going to be ?
<FONT COLOR="0000FF"><PRE>
$_='My email address is &lt;webslave@work.com&gt;.';

print "Found it ! :$1:" if /(&lt;.*&gt;)/i;
</PRE></FONT>
When you see an <FONT COLOR="FF0000"><code> if </code></FONT> statement like this, read it right to left.  The
<FONT COLOR="FF0000"><code> print </code></FONT> statement is only executed if code on the right of the expression
is true.  
<P>
We'll discuss this. Firstly, we have the opening parens <FONT COLOR="FF0000"><code> ( </code></FONT>. So
everything from <FONT COLOR="FF0000"><code> ( </code></FONT> to 
<FONT COLOR="FF0000"><code> ) </code></FONT> will be put into <FONT COLOR="FF0000"><code> $1 </code></FONT> 
if the match is successful. Then the first character of what we are searching for, 
<FONT COLOR="FF0000"><code> &lt; </code></FONT>. Then we have
a dot, or period <FONT COLOR="FF0000"><code> . </code></FONT>. For this regex, we can assume 
<FONT COLOR="FF0000"><code> . </code></FONT> matches <B>any character at all</B>.

<P>So we are now matching <FONT COLOR="FF0000"><code> &lt; </code></FONT> followed by any character. The 
<FONT COLOR="FF0000"><code> * </code></FONT> means 0 or more of the previous character.  The regex finishes
by requiring <FONT COLOR="FF0000"><code> &gt; </code></FONT>.

<P>This is important. Get the basics right and all regex are easy (I read
somewhere once). An example best illustrates the point. Slot this regex
in instead:
<FONT COLOR="0000FF"><PRE>
$_='My email address is &lt;webslave@work.com&gt;.';

print "Found it ! :$1:" if /(&lt;*&gt;)/i;

</PRE></FONT>
What's happening here ?  

<P>The regex starts, logically, at the start of the string. This doesn't mean it starts a 'M', it starts just before M. There is a 'nothing' between the string start and 'M'.
<P>
The regex is searching for <FONT COLOR="FF0000"><code> &lt;* </code></FONT>, which is 0 or more
<FONT COLOR="FF0000"><code> &lt; </code></FONT>.
<P>
The first thing it finds is not 
<FONT COLOR="FF0000"><code> &lt; </code></FONT>, but the nothing in between the start of the string and the 'M' from 'My email...".  Does this match ?
<P>
As the regex is looking for "0 or more" <FONT COLOR="FF0000"><code> &lt; </code></FONT>, we can certainly say that there are
0 <FONT COLOR="FF0000"><code> &lt; </code></FONT> at the start of the string.  So the match is, so far, successful.  We have dealt with <FONT COLOR="FF0000"><code> &lt;* </code></FONT>.
<P>
However, the next item to match is <FONT COLOR="FF0000"><code> &gt; </code></FONT>. Unfortunately, the next item in the string is 'M', from 'My email..".  The match fails at this point.  Sure, it matched 
<FONT COLOR="FF0000"><code> &lt; </code></FONT> without any problem, but the <B>complete</B> match has to work.
<P>
The only two characters that can match successfully at this point are 
<FONT COLOR="FF0000"><code> &lt; </code></FONT> or 
<FONT COLOR="FF0000"><code> &gt; </code></FONT>.  The 'point' being that <FONT COLOR="FF0000"><code> &lt;* </code></FONT> has been matched successfully, and we need either
<FONT COLOR="FF0000"><code> &gt; </code></FONT> to complete the match or more of
<FONT COLOR="FF0000"><code> &lt; </code></FONT> to continue the '0 or more' match denoted by 
<FONT COLOR="FF0000"><code> * </code></FONT>.
<P>
'M' is neither of them, so it fails at this point, when it has matched 
<P>
Quick clarification - the regex cannot successfully match <FONT COLOR="FF0000"><code> &lt; </code></FONT>, then skip on ahead through the string until it matches
<FONT COLOR="FF0000"><code> &gt; </code></FONT>.  <B>The characters in the string between 
<FONT COLOR="FF0000"><code> &lt; &gt; </code></FONT> also need to match the regex,</B> and they don't in this case.
<P>
All is not lost. Regexes are hardy little beasts and don't give up easily.  An attempt is made to match the regex wherever possible. The regex system keeps trying the match at every possible place in the string, working towards the end.
<P>
Let's look at the match when it reaches the 'm' in 'work.com'.
<P>
Again, we have here 0 <FONT COLOR="FF0000"><code> &lt; </code></FONT>. So the match works as before.  After success on 
<FONT COLOR="FF0000"><code> &lt;* </code></FONT> the next character is analysed - it is a 
<FONT COLOR="FF0000"><code> &gt; </code></FONT>, so the match is successful.
<P>
But, be warned.  The match may be successful but your job is not done.  Assuming the objective of was to return the email address within the angle brackets then that regex is a miserable failure. Watch for traps of this nature when regexing.

<P>
That's <FONT COLOR="FF0000"><code> * </code></FONT> explained. Just to consolidate, a quick look at:
<FONT COLOR="0000FF"><PRE>
$_='My email address is &lt;webslave@work.com&gt;.';
print "Match 1 worked :$1:" if /(&lt;*)/i;

$_='&lt;My email address is &lt;webslave@work.com&gt;.';
print "Match 2 worked :$1:" if /(&lt;*)/i;

$_='My email address is &lt;webslave@work.com&lt;&lt;&lt;&lt;&gt;.';
print "Match 3 worked :$1:" if /(&lt;*&gt;)/i;

</PRE></FONT>
Match 1 is true.  It doesn't return anything, but it is true because there are 0
<FONT COLOR="FF0000"><code> &lt; </code></FONT> at the very start of the string.
<P>
Match 2 works. After the 0 <FONT COLOR="FF0000"><code> &lt; </code></FONT> at the start of the
string, there is 1 <FONT COLOR="FF0000"><code> &lt; </code></FONT> so the regex can match that too.
<P>
Match 3 works.  After the failing on the first <FONT COLOR="FF0000"><code> &lt; </code></FONT>, it jumps to the 
second. After that, there are plenty more to match right up until the required ending.


<P>Glad you followed that. Now, pay even closer attention ! Concentrate
fully on the task at hand ! This should be straightforward now:
<FONT COLOR="0000FF"><PRE>
$_='HTML &lt;I&gt;munging&lt;/I&gt; time !.';

/&lt;I&gt;(.*)&lt;\/I&gt;/i;

print "Found it ! $1\n";
</PRE></FONT>
Pretty much the same as the above, except the parens are moved so we return
what's only inside the tags, not including the tags themselves. Also note
how <FONT COLOR="FF0000"><code> / </code></FONT> is escaped like so; <FONT COLOR="FF0000"><code> \/ </code></FONT>
otherwise Perl thinks that's the end of the regex.

<P>Now, suppose we change <FONT COLOR="FF0000"><code> $_ </code></FONT> to :

<FONT COLOR="0000FF"><PRE>
$_='HTML &lt;I&gt;munging&lt;/I&gt; time is here &lt;I&gt;again&lt;/I&gt; !.';

</PRE></FONT>
and run it again. Interesting effect, eh ? This is known as Greedy Matching.
What happens is that when Perl finds the initial match, that is <FONT COLOR="FF0000"><code> &lt;I&gt; </code></FONT> 
it jumps right to the end of the string and works back from there to find a match,
so the longest string matches. This is fine unless you want the shortest
string. And there is a solution:

<FONT COLOR="0000FF"><PRE>
/&lt;I&gt;(.*?)&lt;\/I&gt;/i;
</PRE></FONT>

Just add a question mark and Perl does stingy matching. No nationalistic
jokes. I have Dutch and Scottish friends I don't want to offend.
</P><P>
<BR><A NAME='85-TheDifferenceBetweenand'></A> <H2>The Difference Between + and *</H2>
You know what <FONT COLOR="FF0000"><code> * </code></FONT> means, namely match 0 or more.  If you want to match 1 or more, then use <FONT COLOR="FF0000"><code> + </code></FONT>.  The difference is important.
<FONT COLOR="0000FF"><PRE>
$_='The number is 2200 and the day is Monday';

($star)=/([0-9]*)/;

($plus)=/([0-9]+)/;

print "Star is '$star' and Plus is '$plus'\n";
</PRE></FONT>
You'll note that <code>$star</code> has no value. The match was successful though.  It managed to match 0 or more characters from 0 to 9 at the very start of the regex.
</P><P>
The second regex with <code>$plus</code> worked a little better, because we are matching one or more characters from 0 to 9.  Therefore, unless one 0 to 9 is found the match will fail.  Once a 0-9 is found, the match continues as long as the next character is 0-9, then it stops.
</P><P>
Now we know this, there is another way to remove an email address from within angle brackets:
<FONT COLOR="0000FF"><PRE>
$_='My email address is &lt;robert@netcat.co.uk&gt; !.';

/&lt;([^&gt;]+)/i;

print "Found it ! $1\n";
</PRE></FONT>
This regex matches <code>&lt;</code>.  Then the capturing parens start.  They have no effect on this regex other than to capture the match.  After that, there is a character class, containing one character.  As <code> ^ </code> is the first character is the class, it negates the class.  That's why we are using a character class with only one character in it, because it can be negated.
</P><P>
So far we have matched <code>&lt;</code> and anything that is not <code>&gt;</code>.  The
<code>+</code> ensures we match as many characters that are not <code>&lt;</code>'s as we can.  This has the same effect as <code>.*?</code> but is more efficient.  It may also suit your purposes, as 
<code>.*?</code> relies on you knowing what you want to match up to, whereas
<code>[^&gt;]+</code> simply contines matching until it finds something that fails its criteria.  Just make sure you understand the difference because it is a crucial part of regexery.
</P>

<BR><A NAME='86-Reusingthematch11'></A> <H2>Re-using the match -- \1, $1...</H2>




<P>Suppose we didn't know what HTML tag we had to match ? It could be B,
I, EM or whatever, and we want everything that is in between. Well, HTML
container tags like B and EM have end tags which are the same as the start
tag, except for the / . So what we could do is:
<UL>
<LI>find out what is inside &lt; &gt;</LI>
<LI>search for exactly the same tag, but with the closing /</LI>
<LI>
return whatever is in between.</LI>
</UL>

Can this be done ?  Of course.  This is perl, all things are possible.  
Now, remember the side effect of parens.  I promise I'll explain the primary effect at some point.  If whatever is in (parens) matches, the result is stored in a variable called <FONT COLOR="FF0000"><code> $1 </code></FONT>.  
So we can use <FONT COLOR="FF0000"><code>  &lt;(.*?)&gt; </code></FONT> which will find us 
<FONT COLOR="FF0000"><code> &lt; </code></FONT> then as many anythings 
(the <FONT COLOR="FF0000"><code> . </code></FONT> and <FONT COLOR="FF0000"><code> * </code></FONT>) up to the next, 
not last <FONT COLOR="FF0000"><code> &gt; </code></FONT> (the <FONT COLOR="FF0000"><code> ? </code></FONT> forces stingy matching).
<P>
The result is stored in <FONT COLOR="FF0000"><code> $1 </code></FONT> because we used parens. Next, we need everything
up to the closing tag. That's easy : 
<FONT COLOR="FF0000"><code> (.*?) </code></FONT> matches everything
up until the next character or set of characters. And how exactly do we
define where to stop ?

<P>We can use <FONT COLOR="FF0000"><code> $1 </code></FONT> even in the same regex it was found in. 
However, it is not referred to within a regex as <FONT COLOR="FF0000"><code> $1 </code></FONT>, but 
<FONT COLOR="FF0000"><code> \1 </code></FONT>.
<P>
So we want to match <FONT COLOR="FF0000"><code> &lt;/$1&gt; </code></FONT>
which in perl code is <FONT COLOR="FF0000"><code> &lt;\/\1&gt; </code></FONT>.
The <FONT COLOR="FF0000"><code> / </code></FONT> must be escaped because it is the end of the regex, and 
<FONT COLOR="FF0000"><code> 1 </code></FONT> is escaped
so it refers to <FONT COLOR="FF0000"><code> $1 </code></FONT> instead of matching the number 1.

<P>Still here ? This is what it looks like:

<FONT COLOR="0000FF"><PRE>
$_='HTML &lt;I&gt;munging&lt;/I&gt; time is here &lt;I&gt;again&lt;/I&gt; !.';
/&lt;(.*?)&gt;(.*?)&lt;\/\1&gt;/i;

print "Found it ! $2\n";
</PRE></FONT>
If you want to know how to return all the matches above, read on. But before
that:





<BR><A NAME='87-HowtoAvoidMakingMountainswhileEscapingSpecialCharacters'></A> <H2>How to Avoid Making Mountains while Escaping Special Characters</H2>





<P>You want to match this; <code>http://language.perl.com/faq/ </code>. That's
a real (useful) URL by the way. Hint. To match it, you need to do this:

<FONT COLOR="0000FF"><PRE>
/http:\/\/language\.perl\.com\/faq\//;
</pre></FONT>

which should make the awful metaphor above clearer, if not funnier.  
The slash, <FONT COLOR="FF0000"><code> / </code></FONT>, is not normally a metacharacter but as it is being used for 
the regular expression delimiters, it needs to be escaped.  We already know that 
<FONT COLOR="FF0000"><code> . </code></FONT> is special.
<P>
Fortunately for our eyes, Perl allows you to pick your delimiter if you prefix it with 'm' as this
example shows.  We'll use a <code>#</code>:

<FONT COLOR="0000FF"><PRE>
m#http://language\.perl\.com/faq/#; 
</pre></FONT>

Which is a huge improvement, as we change 
<FONT COLOR="FF0000"><code> / </code></FONT>
to <FONT COLOR="FF0000"><code> # </code></FONT>.
We can go further with readability by quoting everything:

<FONT COLOR="0000FF"><PRE>
m#\Qhttp://language.perl.com/faq/\E#;
</PRE></FONT>

The <FONT COLOR="FF0000"><code>  \Q </code></FONT>escapes everything up until 
<FONT COLOR="FF0000"><code> \E </code></FONT> or the regex delimiter
(so we don't really need the \E above). In this case 
<FONT COLOR="FF0000"><code> # </code></FONT>  will not be escaped,
as it delimits the regex. 
<P>
Someone once posted a question about this to
the Perl-Win32-Users mailing list and I was so intrigued about this apparently
undocumented trick I spent the next twenty minutes figuring it out by trial
and error, and posted a reply. Next day I found lots of messages telling
the poster to read the manual because it was clearly documented. &lt;face
colour='red' intensity='high'> My excuse was I didn't have the docs to
hand....moral of the story - RTFM and RTF FAQs !




<BR><A NAME='88-SubsitutionandYetMoreRegexPower'></A> <H1>Subsitution and Yet More Regex Power</H1>








<BR><A NAME='89-Basicchanges'></A> <H2>Basic changes</H2>




Suppose you want to replace bits of a string. For example, 'us' with 'them'.
<FONT COLOR="0000FF"><PRE>
$_='Us ? The bus usually waits for us, unless the driver forgets us.';

print "$_\n";

s/Us/them/;   # operates on $_, otherwise you need $foo=~s/Us/them/;

print "$_\n";
</PRE></FONT>
What happens here is that the string 'Us' is searched for, and when
a match is found it is replaced with the right side of the expression,
in this case 'them'. Simple. 

<P>You'll notice that only one substitution was made.

To match globally use <FONT COLOR="FF0000"><code> /g </code></FONT> which runs through the entire 
string, changing wherever it can. Try:
<FONT COLOR="0000FF"><PRE>
s/Us/them/g;

</PRE></FONT>
which fails.  This is because regexes are not, by default, case-sensitive.  So:
<FONT COLOR="0000FF"><PRE>
s/us/them/ig;

</PRE></FONT>
would be a better bet.  Now, everything is changed. A little too much, but one problem at a time. 
Everything you have learn about regex so far can be used with <FONT COLOR="FF0000"><code> s/// </code></FONT>, like parens, 
character classes <FONT COLOR="FF0000"><code> [ ]  </code></FONT>, greedy
and stingy matching and much more. Deleting things is easy too. Just specify
nothing as the replacement character, like so 
<FONT COLOR="0000FF"><code> s/Us//; </code></FONT>.
<P>
So we can use some of that knowledge to fix this problem.  We need to make sure that a space precedes the 'us'.  
What about:
<FONT COLOR="0000FF"><PRE>
s/ us/them/g;

</PRE></FONT>
An small improvement. The first 'Us' is now no longer changed, but one problem at a time !  We'll first consider the problem of the regex changing 'usually' and other words with 'us' in them.
<P>
What we are looking for is a space, then 'us', then a comma, period or space.  We know how to specify one of a number of options - the character class.
<FONT COLOR="0000FF"><PRE>
s/ us[. ,]/them/g;

</PRE></FONT>
Another tiny step. Unfortunately, that step wasn't really in the right direction, more on the slippery slope to Poor Programming Practice.  Why ?  Because we are limiting ourselves.  Suppose someone wrote ' send it to us; when we get it'.  
<P>
You can't think of all the possible permutations.  It is often easier, and safer, to simply state what must <I>not</I> follow the match.  In this case, it can be anything except a letter.  We can define that as a-z.  So we can add that to the regex.
<FONT COLOR="0000FF"><PRE>
s/ us[^a-z]/ them/g;

</PRE></FONT>
the caret <FONT COLOR="FF0000"><code> ^ </code></FONT> negates the character class, and 
<FONT COLOR="FF0000"><code> a-z </code></FONT> represents every alphabet from a to z inclusive.  A space
has been added to the substitution part - as the original space was matched, it should be replaced to maintain readability.
<P>




<BR><A NAME='90-w'></A> <H2>\w</H2>




What would be more useful is to use <FONT COLOR="FF0000"><code> a-zA-Z </code></FONT> instead.  If we 
weren't using <FONT COLOR="FF0000"><code> /i </code></FONT> we'd need that.  As 
<FONT COLOR="FF0000"><code> a-zA-Z </code></FONT> is such a common construct, Perl provides an easy shorthand:
<FONT COLOR="0000FF"><PRE>
s/ us[^\w]/ them/g;

</PRE></FONT>
The <FONT COLOR="FF0000"><code> \w </code></FONT> construct actually means 'word' - equivalent to
<FONT COLOR="FF0000"><code> a-zA-Z_0-9 </code></FONT>.  So we'll use that instead.
<P>
To negate any construct, simply capitalise it:
<FONT COLOR="0000FF"><PRE>
s/ us[\W]/ them/g;

</PRE></FONT>
and of course we don't need the negating caret now.  In fact, we don't even need the character class !
<FONT COLOR="0000FF"><PRE>
s/ us\W/ them/g;

</PRE></FONT>
So far, so good.  Matching the first 'us' is going to be difficult though.  Fortunately, there is an easy solution. 
We've seen Perl's definition of a word - <FONT COLOR="FF0000"><code> \w </code></FONT>.  Between each word is a boundary. 
You can match this with <FONT COLOR="FF0000"><code> \b </code></FONT>.
<FONT COLOR="0000FF"><PRE>
s/\bus\W/ them/g;

</PRE></FONT>
(that's <FONT COLOR="FF0000"><code> \b </code></FONT> followed by 'us', not 'bus' :-)<BR>
Now, we require a word boundary before 'us'.  As there is a 'nothing' at the start of the string, we have a match.  There is a space after the first 'Us', so the match is successful. You might notice an extra space has crept in - that's the space we added earlier.  The match doesn't include the space any more - it matches on the word boundary, that is just before the word begins.  The space doesn't count.
<P>
Did you notice the final period and the comma are replaced ?  They are part of the match - it is the




<BR><A NAME='91-Replacingwithwhatwasfound'></A> <H2>Replacing with what was found</H2>




<FONT COLOR="FF0000"><code> \W </code></FONT> that matches them. We can't avoid that.  We can however put back that
part of the match. 
<FONT COLOR="0000FF"><PRE>
s/\bus(\W)/them\1/g;

</PRE></FONT>
We start with capturing whatever the <FONT COLOR="FF0000"><code> \W </code></FONT> matches, using parens.  Then, we add it
to the replacement string.  The capture is of course in <FONT COLOR="FF0000"><code> $1 </code></FONT>, but as it is in a
regex we refer to it as <FONT COLOR="FF0000"><code> \1 </code></FONT>.
<P>
The final problem is of course capitalising the replacement string when appropriate.  Which in old versions of the tutorial I left as an exercise to the reader, having run out of motivation.  A reader by the name of Paul Trafford duly solved the problem, and I have just inserted his excellent explanation for the elucidation of all concerned:
<P>
<PRE>
#         Solution to the us/them problem...
#
#   The program works through the text assigning the 
#   variable $1 to 'U' or 'u' for any words where this 
#   letter is followed by 's' and then by non 'word' 
#   characters.   The latter is assigned to variable $2.
#
#   For each such matching occurrence, $1 is replaced by 
#   the letter that precedes it in the alphabet using 
#   operations 'ord' and 'chr' that return the ASCII value 
#   of a character and the character corresponding to a 
#   given natural number.  After this 'hem' is tacked on 
#   followed by $2, to retain the shape of the original 
#   sentence.  The '/e' switch is used for evaluation.
#
#   NOTES
#   1. This solution will not replace US (short for 
#   United States) with Them or them.
#
#   2. If a 'magical' decrement operator '--' existed for 
#   strings then the solution could be simplified for we 
#   wouldn't need to use the 'chr' and 'ord' operators.
</PRE>
<P>
<FONT COLOR="0000FF"><PRE>
$_='Us ? The bus usually waits for us, unless the driver forgets us.';

print "$_\n";

s/\b([Uu])s(\W)/chr(ord($1)-1).hem.$2/eg;

print "$_\n";
</PRE></FONT>
<P>
An excellent solution, thanks Paul.

<P>
There are several more constructs. We'll take a quick look at <FONT COLOR="FF0000"><code> \d </code></FONT> which
means anything that is a digit, that is <FONT COLOR="FF0000"><code> 0-9 </code></FONT>. First we'll use the negated
form, <FONT COLOR="FF0000"><code> \D </code></FONT>, which is anything <I>except</I> 
<FONT COLOR="FF0000"><code> 0-9 </code></FONT>:
<FONT COLOR="0000FF"><PRE>
print "Enter a number :";
chop ($input=&lt;STDIN&gt;);

if ($input=~/\D/) {
        print "Not a number !!!!\n";
} else {
        print 'Your answer is ',$input x 3,"\n";

}
</PRE></FONT>
this checks that there are no non-number characters in <FONT COLOR="FF0000"><code> $x </code></FONT>. It's not perfect
because it'll choke on decimal points, but it's just an example. Writing your own number-checker is actually quite
difficult, but it is an interesting exercise.  Try it, and see how accurate yours is.  
<P>




<BR><A NAME='92-x'></A> <H2> x </H2>




I hope you trusted me and typed the above in exactly as it is show (or pasted
it), because the <FONT COLOR="FF0000"><code> x </code></FONT> is not a mistake, it is a feature. If you were
too smart and changed it to a <FONT COLOR="FF0000"><code> * </code></FONT> or something change it back and see what it does.

<P>Of course, there is another way to do it :
<FONT COLOR="0000FF"><PRE>
unless ($input=~/\d/) {
        print 'Your answer is ',$input x 3,"\n";
} else {
        print "Not a number !!!!\n";
}
</PRE></FONT>
which reverses the logic with an <FONT COLOR="FF0000"><code> unless </code></FONT> statement.




<BR><A NAME='93-MoreMatching'></A> <H3>More Matching</H3>




Assume we have:
<FONT COLOR="0000FF"><PRE>
$_='HTML &lt;I&gt;munging&lt;/I&gt; time is here &lt;I&gt;again&lt;/I&gt; !.';
</PRE></FONT>
and we want to find all the italic words. We know that 
<FONT COLOR="FF0000"><code> /g </code></FONT> will match globally, so surely this will work :
<FONT COLOR="0000FF"><PRE>
$_='HTML &lt;I&gt;munging&lt;/I&gt; time is here &lt;I&gt;again&lt;/I&gt; ! What &lt;EM&gt;fun&lt;/EM&gt; !';

$match=/&lt;i&gt;(.*?)&lt;\/i&gt;/ig;

print "$match\n";
</PRE></FONT>
except it returns 1, and there were definitely two matches. The match operator
returns true or false, not the number of matches. So you can test it for
truth with functions like <FONT COLOR="FF0000"><code>  if, while, unless </code></FONT>
Incidentally, the <FONT COLOR="FF0000"><code> s/// </code></FONT> operator does return the number of substitutions.

<P>
To return what is matched, you need to supply a list.
<FONT COLOR="0000FF"><PRE>
($match) = /&lt;i&gt;(.*?)&lt;\/i&gt;/i;
</PRE></FONT>
which handily puts all the first match into <FONT COLOR="FF0000"><code> $match </code></FONT>. Note that an <code> = </code> is used (for assignment), as opposed to <code> =~ </code> (to point the regex at a variable other than <code> $_</code>.
</P><P>The parens force a list context in this case. There is just the one element in the
list, but it is still a list. The entire match will be assigned to the
list, or whatever is in the parens. Try adding some parens:
<FONT COLOR="0000FF"><PRE>
$_='HTML &lt;I&gt;munging&lt;/I&gt; time is here &lt;I&gt;again&lt;/I&gt; ! What &lt;EM>fun&lt;/EM&gt; !';

($word1, $word2) = /&lt;i&gt;(.*?)&lt;\/i&gt;/ig;

print "Word 1 is $word1 and Word 2 is $word2\n";
</PRE></FONT>
In the example above notice <FONT COLOR="FF0000"><code> /g </code></FONT> has been added so a <B>global</B> 
replacement is done - this means perl carries on matching even after it finds the first match.
Of course, you might not know how many matches there will be, so you can
just use an array, or any other type of list:
<FONT COLOR="0000FF"><PRE>
$_='HTML &lt;I&gt;munging&lt;/I&gt; time is here &lt;I&gt;again&lt;/I&gt; ! What &lt;EM>fun&lt;/EM&gt; !';

@words = /&lt;i&gt;(.*?)&lt;\/i&gt;/ig;

foreach $word (@words) {
        print "Found $word\n";
}
</PRE></FONT>
and <FONT COLOR="FF0000"><code> @words </code></FONT> will be grown to the appropriate size for the matches.  You really can supply what you like to be assigned to:
<FONT COLOR="0000FF"><PRE>
($word1, @words[2..3], $last) = /&lt;i&gt;(.*?)&lt;\/i&gt;/ig;
</PRE></FONT>
you'll need more italics for that last one to work.  It was only a demonstration.

<P>There is another trick worth knowing. Because a regex returns true
each time it matches, we can test that and do something every time it returns
true. The ideal function is <FONT COLOR="FF0000"><code> while </code></FONT> which means 'do something as long
the condition I'm testing is true'. In this case, we'll print out the match
every time it is true.
<FONT COLOR="0000FF"><PRE>
$_='HTML &lt;I&gt;munging&lt;/I&gt; time is here &lt;I&gt;again&lt;/I&gt; ! What &lt;EM>fun&lt;/EM&gt; !';

while (/&lt;(.*?)&gt;(.*?)&lt;\/\1&gt;/g) {
        print "Found the HTML tag $1 which has $2 inside\n";
}
</PRE></FONT>
So the while operator runs the regex, and if it is true, carries out the
statements inside the block.

<P>Try running the program above without the <FONT COLOR="FF0000"><code> /g </code></FONT>. Notice how it loops forever
? That's because the expression always evaluates to true. By using the
<FONT COLOR="FF0000"><code> /g </code></FONT> we force the match to move on until it eventually fails.

<P>Now we know this, an easy way to find the number of matches is:
<FONT COLOR="0000FF"><PRE>
$_='HTML &lt;I&gt;munging&lt;/I&gt; time is here &lt;I&gt;again&lt;/I&gt; ! What &lt;EM>fun&lt;/EM&gt; !';

$found++ while /&lt;i&gt;.*?&lt;\/i&gt;/ig;

print "Found $found matches\n";
</PRE></FONT>
You don't need braces in this case as nothing apart from the expression
to be evaluated follows the <FONT COLOR="FF0000"><code> while </code></FONT> function.




<BR><A NAME='94-ParenthesesAgainOR'></A> <H2>Parentheses Again: OR</H2>




The real use for them. Precedence. Try this, and yes you can try it at home:
<FONT COLOR="0000FF"><PRE>
$_='One word sentences ? Eliminate. Avoid clichs like the plague.  They are old hat.';

while (/o(rd|ne|ld)/gi) {
        print "Matched $1\n";
}
</PRE></FONT>
Firstly, notice the subtle introduction of the <FONT COLOR="FF0000"><code> or </code></FONT> operator, in this case
<FONT COLOR="FF0000"><code> | </code></FONT>, the pipe. What I really want to explain however, is that this regex matches o followed by rd, ne or ld. Without the parens it would be 
<FONT COLOR="FF0000"><code> /ord|ne|ld/ </code></FONT>
which is definitely not what we want. That matches just plain ord,
or ne or ld.
</P><P>




<BR><A NAME='95-OREfficiency'></A> <H3>(?: OR Efficiency)</H3>





In the interests of efficiency, consider this:
<FONT COLOR="0000FF"><PRE>
print "Give me a name :";
chop($_=&lt;STDIN&gt;);

print "Good name\n" if /Pe(tra|ter|nny)/;
</PRE></FONT>
The code above functions correctly.  If you were wondering what a good name is, Petra, Peter and Penny qualify. The regex is not as efficient as it could be though.  Think about what Perl is doing with the regex, that you are just ignoring.  Simply throwing away casually. Without consideration as to the effort that has gone into creating it for you.  The resources squandered.  The little bytes of memory whose sole function in life is to store this information, which will never be used.
</P><P>
What's happening is that because parens are used, perl is creating <code>$1</code> for your usage and abusage.  While this may not seem important, a fair amount of resources go into creating <code>$1</code>, <code>$2</code> and so on.  Not so much the memory used to store them, more the CPU effort involved.  So, if you aren't going to use the parens for capturing purposes, why bother capturing the match?
<FONT COLOR="0000FF"><PRE>
print "Give me a name :";
chop($_=&lt;STDIN&gt;);

print "Good name\n" if /Pe(?:tra|ter|nny)/;

print "The match is :$1:\n";
</PRE></FONT>
The second print statement demonstrates that nothing is captured this time.  You get the benefits of the paren's precedence-changing capabilities, but without the overhead of the capturing.  This benefit is especially worthwhile if you are writing CGI programs which use parens in regex -- with CGI, every little of bit efficiency counts.
</P>




<BR><A NAME='96-Matchingspecificamountsof'></A> <H2>Matching specific amounts of...</H2>




<P>Finally, take a look at this :
<FONT COLOR="0000FF"><PRE>
$_='I am sleepy....zzzz....DING ! Wake Up!';

if (/(z{5})/) {
        print "Matched $1\n";
} else {
        print "Match failed\n";
}
</PRE></FONT>
The braces <FONT COLOR="FF0000"><code> { } </code></FONT> specify how many of the preceding character to match. So
<FONT COLOR="FF0000"><code> z{2} </code></FONT>matches exactly two 'z's and so on. Change 
<FONT COLOR="FF0000"><code> z{5} </code></FONT> to <FONT COLOR="FF0000"><code> z{4} </code></FONT>
and see how it works. And there's more...
<P>
<TABLE BORDER CELLPADDING=2 CELLSPACING=3>
<TR>
<TD>/z{3}/</TD>
<TD>3 z only </TD>
</TR>

<TR>
<TD>/z{3,}/</TD>
<TD>At least 3 z </TD>
</TR>

<TR>
<TD>/z{1,3}/</TD>
<TD>1 to 3 z </TD>
</TR>

<TR>
<TD>/z{4,8}/</TD>
<TD>4 to 8 z</TD>
</TR>
</TABLE>
<P>
To any of the above you may suffix an question mark, the effect of which is demonstrated in the following program. Run it a couple of times, inputting 2, 3 and 4:

<FONT COLOR="0000FF"><PRE>
print "How many letters do you want to match ? ";
chomp($num=&lt;STDIN&gt;);

# we assign and print in one smooth move
print $_="The lowest form of wit is indeed sarcasm, I don't think.\n";

print "Matched \\w{$num,} : $1 \n"  if /(\w{$num,})/;

print "Matched \\w{$num,?}: $1 \n"  if /(\w{$num,}?)/;
</PRE></FONT>
<P>
The first match is 'match any word (that's <code>a-Z0-9_</code>) equal to or longer than
<FONT COLOR="FF0000"><code> $num </code></FONT> character, and return it.'  So if you enter 4, then 'lowest' is returned.  The word 'The' doesn't match.
<P>
The second match is exactly the same, but the <FONT COLOR="FF0000"><code> ? </code></FONT> forces a minimal match, so only the part actually matched is returned.
<P>
Just to clear this up, amend the program thus:
<P>
<FONT COLOR="0000FF"><PRE>
print "\nMatched \\w{$num,} :";
print "$1 " while /(\w{$num,})/g;

print "\nMatched \\w{$num,?} :";
print "$1 " while /(\w{$num,}?)/g;
</PRE></FONT>
<P>
Note the addition of <FONT COLOR="FF0000"><code> /g </code></FONT>.  Try it without - notice how the match never moves on ?
<P>




<BR><A NAME='97-PrePostandMatch'></A> <H2>Pre, Post, and Match</H2>




And now on the Regex Programme Today, we have guest stars Prematch, Postmatch and Match.  All of whom are going to slow our entire programme down, but are useful anyway :

<FONT COLOR="0000FF"><PRE>
$_='I am sleepy....snore....DING ! Wake Up!';

/snore/;	# look, no parens !

print "Postmatch: $'\n";
print "Prematch: $`\n";
print "Match: $&amp;\n";

</PRE></FONT>
If you are wondering what the difference between match and using parens
is you should remember than you can move the parens around, but you can't
vary what <FONT COLOR="FF0000"><code> $&amp; </code></FONT> and its ilk
return. Also, using any of the above three operators
does slow your entire program, whereas using parens will just slow the
particular regex you use them for. However, once you've used one of the
three matches you might as well use them all over the place as you've paid
the speed penalty.  Use parens where possible.



<BR><A NAME='98-RHSExpressions'></A> <H2>RHS Expressions</H2>


<BR><A NAME='99-e'></A> <H3>/e</H3>

RHS means Right Hand Side.  Suppose we have an HTML file, which contains:

<PRE>
&lt;FONT SIZE=2&gt; &lt;FONT SIZE=4&gt; &lt;FONT SIZE=6&gt
</PRE>
and we wish to double the size of each font so 2 becomes 4 and 4 becomes
8 etc. What about :
<FONT COLOR="0000FF"><PRE>
$data="&lt;FONT SIZE=2&gt; &lt;FONT SIZE=4&gt; &lt;FONT SIZE=6&gt;";

print "$data\n";

$data=~s/(size=)(\d)/\1\2 * 2/ig;

print "$data\n";
</PRE></FONT>
which doesn't really work out. What this does is match <code>size=x</code>,
where <code>x</code> is any digit. The first match, <code>size=</code>, goes into 
<FONT COLOR="FF0000"><code> $1 </code></FONT> and
the second match, whatever the digit is, goes into <FONT COLOR="FF0000"><code> $2 </code></FONT>. 
The second part of the regex simply prints <FONT COLOR="FF0000"><code> $1 </code></FONT> and 
<FONT COLOR="FF0000"><code> $2 </code></FONT> (referred to as <FONT COLOR="FF0000"><code> \1 </code></FONT> and 
<FONT COLOR="FF0000"><code> \2 </code></FONT>), and attempts
to multiply <FONT COLOR="FF0000"><code> $2 </code></FONT> by 2. Remember <FONT COLOR="FF0000"><code> /i </code></FONT> means case insensitive matching.

<P>
What we need to do is evaluate the right hand side of the regex as an
expression - that is not just print out what it says, but actually evaluate
it. That means work it through, not blindly treat it as string. Perl can do this:
<FONT COLOR="0000FF"><PRE>
$data=~s/(size=)(\d)/$1.($2 * 2)/eig;
</PRE></FONT>
A little explanation....the LHS is the same as before. We add <FONT COLOR="FF0000"><code> /e </code></FONT> so
Perl evaluates the RHS as an expression. So we need to change <FONT COLOR="FF0000"><code> \1 </code></FONT> into 
<FONT COLOR="FF0000"><code> $1 </code></FONT> and so on. The parens are there to ensure that 
<FONT COLOR="FF0000"><code> $2 * 2 </code></FONT> is evaluated, <B>then</B> joined to 
<FONT COLOR="FF0000"><code> $1 </code></FONT>. And that's it ! 
</P><P>



<BR><A NAME='100-ee'></A> <H3>/ee</H3>



It is even possible to have more than one <FONT COLOR="FF0000"><code> /e </code></FONT>. For example:
<FONT COLOR="0000FF"><PRE>
$data='The function is &lt;5funcA&gt;';

$funcA='*2+4';

print "$data\n";

$data=~s/&lt;(\d)(\w+)&gt;/($1+2).${$2}/;	# first time
# $data=~s/&lt;(\d)(\w+)&gt;/($1+2).${$2}/e;	# second time
# $data=~s/&lt;(\d)(\w+)&gt;/($1+2).${$2}/ee;	# third time

print "$data\n";

</PRE></FONT>
To properly appreciate this you need to run it three times, each time commenting out a different line. Only one regex line should be uncommented when the program is run.
</P><P>
The first time round the regex is a dumb variable interpolation.  Perl just searches the string for any variables, finds <code>$1</code> and <code>$2</code>, and replaces them.
</P><P>
Second time round the expression is evaluated, as opposed to just plain variable-interpolated.  This means that <code>$1+2</code> is evaluated.  <code>$1</code> has a value of 5, pl, plus 2 == 7.  The other part of the replacement, <code>${$2}</code> is evaluated only so far as working out that the variable named <code>$2</code> should be placed in the string.
</P><P>
Third time round and Perl now makes a second pass through the string, looking for things to do. After the first pass, and just before that second pass the string looks like this; <code> 7*2+4 </code>.  Perl evaluates this, and prints the result.
</P><P>
So the more <FONT COLOR="FF0000"><code> /e </code></FONT>'s you add on the end of the regex, the more passes Perl makes through the replacement string trying to evaluate the code.  
</P><P>
This is fairly advanced stuff here, and it is probably not something you will use every day.  But knowing it is there is handy.
</P>
<BR><A NAME='101-AWorkedExampleDateChange'></A> <H2>A Worked Example: Date Change</H2>
Imagine you have a list of dates which are in the US format of month, day, year as opposed to the rest of the world's logical notion of day, month year.  We need a regex to transpose the day and month.  The dates are:
<PRE>
@dates=(
'01/22/95',
'05/15/87',
'8-13-96',
'5.27.78',
'6/16/1993'
);
</PRE>
The task can be split into steps such as:
<OL>
<LI>Match the first digit, or two digits. Capture this result.
<LI>Match the delimiter, which appears to be one of <code>/ - .</code>
<LI>Match the second two digits, and capture that result
<LI>Rebuild the string, but this time reversing the day and month.
</OL>
That may not be all the steps, but it is certainly enough for a start.  Planning regex is important.  So, first pass:
<FONT COLOR="0000FF"><PRE>
@dates=(
'01/22/95',
'5/15/87',
'8-13-96',
'5.27.78',
'6/16/1993'
);

foreach (@dates) {
	print;
	s#(\d\d)/(\d\d)#$2/$1#;
	print " $_\n";
}
</PRE></FONT>
Hmm.  This hasn't worked for the dates delimited with <code> - . </code>, and the last date hasn't worked either. The first problem is pretty easy; we are just matching <code> / </code>, nothing else.  The second problem arises because we are matching two digits.  Therefore, 5/15/87 is matched on the 15 and 87, not the 5 and 15.  The date 6/16/1993 is matched on the 16 and the 19 of 1993.
</P><P>
We can fix both of those.  First, we'll match either 1  or 2 digits.  There are a few ways of doing this, such as <code>\d{1,2}</code> which means either 1 or two of the preceding character, or perhaps more easily <code>\d\d?</code> which means match one <code>\d</code> and the other digit is optional, hence the question mark. If we used <code>\d+</code> then that would match 19988883 which is not a valid date, at least not as far as we are concerned.
</P><P>
Secondly, we'll use a character class for all the possible date delimiters.  Here is just the loop with those amendments:
<FONT COLOR="0000FF"><PRE>
foreach (@dates) {
	print;
	s#(\d\d?)[/-.](\d\d?)#$2/$1#;
	print " $_\n";
}
</PRE></FONT>
which fails.  Examine the error statement carefully.  The key word is 'range'.  What range?  Well, the range between / and . because <code>-</code> is the range operator within a character class.  That means it is a special character, or a metacharacter.  And to negate the special meaning of metacharacters we have to use a backslash.
</P><P>
But wait!  I don't hear you cry.  Surely <code> . </code> is a metacharacter too?  It is, but not within a character class so it doesn't need to be escaped.
</P>
<FONT COLOR="0000FF"><PRE>
foreach (@dates) {
	print;
	s#(\d\d?)[/\-.](\d\d?)#$2/$1#;
	print " $_\n";
}
</PRE></FONT>
Nearly there.  However, we are always replacing the delimiter with <code>/</code> which is messy. That's an easy fix:
<FONT COLOR="0000FF"><PRE>
foreach (@dates) {
	print;
	s#(\d\d?)([/\-.])(\d\d?)#$3$2$1#;
	print " $_\n";
}
</PRE></FONT>
so that fixes that.  In case you were wondering, the <code> . </code> dot does not act as '1 of anything' inside a character class.  It would defeat the object of the character class if it did.  So it doesn't need escaping.  There is a further improvement you can make to this regex:
<FONT COLOR="0000FF"><PRE>
$m='/.-';

foreach (@dates) {
	print;
	s#(\d\d?)([$m])(\d\d?)#$3$2$1#;
	print " $_\n";
}
</PRE></FONT>
which is good practice because you are bound to want to change your delimiters at some point, and putting them inside the regex is hardcording, and we all know that ends in tears.  You can also re-use the <code>$m</code> variable elsewhere, which is good pratice.
</P><P>
Did you notice the difference between what we assign to <code>$m</code> and what we had before? 
<PRE>
    /\-.
$m='/.-';
</PRE>
The difference is that the <code> - </code> is no longer escaped.  Why not?  Logic. Perl knows <code> - </code> is the range operator.  Therefore, there must be a character to the immediate left and immediate right of it in order for it to work, for example <code>e-f</code>.  When we assign a string to <code>$m</code>, the range operator is the last character and therefore has no character to the right of it, so Perl doesn't interpret as a range operator.  Try this:
<PRE>
$m='/-.';
</PRE>
and watch it fail.
</P><P>
Something else that causes heartache is matching what you don't mean to.  Try this:
<FONT COLOR="0000FF"><PRE>
@dates=(
'01/22/95',
'5/15/87',
'8-13-96',
'5.27.78',
'/16/1993',
'8/1/993',
);

$m='/.-';

foreach (@dates) {
	print;
	s#(\d\d?)([$m])(\d\d?)#$3$2$1# or print "Invalid date! ";
	print " $_\n";
}
</PRE></FONT>
The two invalid dates at the end are let through.  If you wanted to check the validity of every possible date since the start of the modern calendar then you might be better off with a database rather than a regex, but we can do some basic checking.  The important point is that we know the limitations of what we are doing.
</P><P>
What we can do is make sure of two things; that there are three sets of digits seperated by our chosen delimiters, and that the last set of digits is either two digits, eg 99, 98, 87, or four digits, eg 1999, 1998, 1987.
</P><P>
How can we do this?  Extend the match. After the second digit match we need to match the delimter again, then either 2 digits or four digits.  How about:
<FONT COLOR="0000FF"><PRE>
$m='/.-';

foreach (@dates) {
	print;
	s#(\d\d?)([$m])(\d\d?)[$m](\d\d|\d{4})#$3$2$1$2# or print "Invalid date! ";
	print " $_\n";
}
</PRE></FONT>
which doesn't really work out.  The problem is it lets 993 through. This is because \d\d will match on the front of 993. Furthermore, we aren't fixing the year back on to the end result.
</P><P>
The delimiter match is also faulty.  We could match / as the first delimiter, and - as the second.  So, three problems to fix:
<FONT COLOR="0000FF"><PRE>
foreach (@dates) {
	print;
	s#(\d\d?)([$m])(\d\d?)\2(\d\d|\d{4})$#$3$2$1$2$4# or print "Invalid!";
	print " $_\n";
}
</PRE></FONT>
This is now looking like a serious regex.  Changes:
<OL>
<LI>We are re-using the second match, which is the delimiter, further on in the regex. That's what the <code> \2 </code> is.  This ensures the second delimiter is the same as the first one, so 5/7-98  gets rejected.
<LI>The <code>$</code> on the end means end of string. Nothing allowed after that.  So the regex now has to find either 2 or 4 digits at the end of the string, or it fails.
<LI>Added the match of the year (<code>$4</code>) to the rebuild section of the regex.
</OL>
Regex can be as complex as you need.  The code above can be improved still further. We could reject all years that don't begin with either 19 or 20 if they are four-digit years.  The other problem with the code so far is that it would reject <code>a date like 02/24/99 which is valid</code> because there are characters after the year. Both can be fixed:
<FONT COLOR="0000FF"><PRE>
@dates=(
'01/22/95',
'5/15/87',
'8-13-96',
'5.27.78',
'/16/1993',
'8/1/993',
'3/29/1854',
'! 4/23/1972 !',
);

$m='/.-';

foreach (@dates) {
	print;
	s#(\d\d?)([$m])(\d\d?)\2(\d\d|(?:19|20)\d{2})(?:$|\D)#$3$2$1$2$4# or print "Invalid!";
	print " $_\n";
}
</PRE></FONT>
We have now got a nested OR, and the inner OR is non-capturing for reasons of efficiency and readability.  At the end we alternate between letting the regex match either an end of line or any non-digit, symbolised with <code>\D</code>.
</P><P>
We could go on.  It is often very difficult to write a regex that matches anything of even minor complexity with absolute certainity.  Think about IP addresses for example.  What is important is to build the regex carefully, and understand what it can and cannot do.  Catching anything supposedly invalid is a good idea too.  Test your regex with all sorts of invalid data, and you'll understand what it can do.

<BR><A NAME='102-SplitandJoin'></A> <H1>Split and Join</H1>



<BR><A NAME='103-Splitting'></A> <H2>Splitting</H2>
While you are in the regex mood, a quick look at <FONT COLOR="FF0000"><code> split </code></FONT> and 
<FONT COLOR="FF0000"><code> join </code></FONT>.  
Destruction is always easier (just ask your car mechanic), so lets start with <FONT COLOR="FF0000"><code> split </code></FONT>.

<FONT COLOR="0000FF"><PRE>
$_='Piper:PA-28:Archer:OO-ROB:Antwerp';

@details=split /:/, $_;

foreach (@details) {
        print "$_\n";
}
</PRE></FONT>
Here we give <FONT COLOR="FF0000"><code> split </code></FONT> is given two arguments. The first one is 
a regex specifying what to split on. The next is what to split. Actually, I could leave
<FONT COLOR="FF0000"><code> $_ </code></FONT> out because as usual it is the default if nothing is specified.

<P>
The assignment can either be a scalar variable or a list like an array
(or hash, but at this time 'hash' to you means what you think the Dutch
do or a silly drinking event spoilt by some running). If it's a scalar
variable you get the number of elements the split has splut. Should that
be 'the split has splittered' or 'the split has splat'. Hmmm. Probably
'the split has split'. You know what I mean. I think I just generated a
Fatal Error in English.dll. Whoops.  In any case, splitting to a scalar variable is not always a Good Thing, as we'll see later.

<P>If the assignment is an array, then as you can see in the
above example the array is created with the relevant elements in order.
You can also assign to scalars, for example :
<FONT COLOR="0000FF"><PRE>
$_='Piper:PA-28:Archer:OO-ROB:Antwerp';

($maker,$model,$name,$reg,$location) = split /:/, $_;
(@aircraft[0..1],$aname,@regdetails) = split /:/, $_;

$number=split /:/ ;             # not bothering with the $_ at the end, as it is the default

print "Using the first 'split'\n";
print "$reg is a $maker $model $name based in $location\n";
print "There are $number details available on this aircraft\n\n";

print "Using the second 'split'\n";
print "You can find $regdetails[0], an $aircraft[1], $regdetails[1]\n";

</PRE></FONT>
This demonstrates that a list can be a list of scalar variables (which
is basically what an array is anyway), and that you can easily see how
many elements the expression can be split into.

<P>The example below adds a third parameter to split, which is how many
elements you want returned. If you don't want the extra stuff at the end
<FONT COLOR="FF0000"><code> pop </code></FONT> it.
<FONT COLOR="0000FF"><PRE>
$_='Piper:PA-28:Archer:OO-ROB:Antwerp';

@details=split /:/, $_, 3;

foreach (@details) {
        print "$_\n";
}
</PRE></FONT>
In the example below we <FONT COLOR="FF0000"><code> split </code></FONT> on <B>whitespace</B>. Whitespace, in perl terms, is a space, tab, newline, formfeed or carriage return. Instead of writing 
<FONT COLOR="FF0000"><code> \t\n\f\r</code></FONT> for each of the above, you can simply use
<FONT COLOR="FF0000"><code> \s </code></FONT>, or the negated version <FONT COLOR="FF0000"><code> \S </code></FONT> which means anything <B>except</B> whitespace.  Think of whitespace as anything you know is there, but you can't see.
<P>
The whitespace <FONT COLOR="FF0000"><code> split </code></FONT> is specially
optimised for speed. I've used spaces, double spaces, a tab and a newline
in the list below. Also note the <FONT COLOR="FF0000"><code> + </code></FONT>, which means one or more of the preceding
character, so it will <FONT COLOR="FF0000"><code> split </code></FONT> on any combination of whitespace. And I think
the final <FONT COLOR="FF0000"><code> split </code></FONT> is useful to know.  The 
<FONT COLOR="FF0000"><code> split </code></FONT> function does not return the delimiter, so in this case the whitespace
will not be returned.
<FONT COLOR="0000FF"><PRE>
$_='Piper       PA-28  Archer           OO-ROB
Antwerp';

@details=split /\s+/, $_;

foreach (@details) {
        print "$_\n";
}

@chars=split //, $details[0];

foreach $char (@chars) {
        print "$char !\n";
}
</PRE></FONT>




<BR><A NAME='104-AveryFAQ'></A> <H2>A very FAQ</H2>




The following question has come up at least three times in the Perl-Win32-Users mailing list.  Can you answer it ?
<PRE>
"My data is delimited by |, for example:
name|age|sex|height|
Why doesn't
@array=split /|/, $line;
work ?"
</PRE>
Why indeed.  If you don't already know the answer, some simple troubleshooting steps can be applied.  First, create a sample program and run it.
<FONT COLOR="0000FF"><PRE>
$line='name|age|sex|height';

@array=split /|/,$line;

foreach (@array) { print "$_\n" }
</PRE></FONT>
The effect is to <FONT COLOR="FF0000"><code> split </code></FONT> each character.  The
<FONT COLOR="FF0000"><code> | </code></FONT> is returned.  As it is the delimiter, 
<FONT COLOR="FF0000"><code> | </code></FONT> should be ignored, not returned.
<P>
At this point you should be thinking 'metacharacter'.  A little research (looking at the documentation) will
reveal that <FONT COLOR="FF0000"><code> | </code></FONT> is indeed a metacharacter, which means 'or', when inside a regex.  So, in effect,
the regex <FONT COLOR="FF0000"><code> /|/ </code></FONT> means 'nothing, or nothing'.  The 
<FONT COLOR="FF0000"><code> split </code></FONT> is therefore performed on 'nothings', and there are 'nothings' in between
each character.  The solution is easy ; <FONT COLOR="FF0000"><code> /\|/ </code></FONT>.
<FONT COLOR="0000FF"><PRE>
$line='name|age|sex|height';

@array=split /\|/,$line;

foreach (@array) { print "$_\n" }
</PRE></FONT>
<P>
So that's the fun stuff, destruction. Now to put it back together again
with <FONT COLOR="FF0000"><code> join </code></FONT>.





<BR><A NAME='105-WhatHumptyDumptyneedsJoin'></A> <H2>What Humpty Dumpty needs : Join</H2>




<FONT COLOR="0000FF"><PRE>
$w1="Mission critical ?";
$w2="Internet ready modems !";
$w3="J(insert your cool phrase here)";	# anything prefixed by 'J' is now cool ;-)
$w4="y2k compatible.";
$w5="We know the Web.";
$w6="...the leading product in an emerging market.";

$cool=join ' ', $w1,$w2,$w3,$w4,$w5,$w6;

print $cool;
</PRE></FONT>
Join takes a 'glue' operator, which is <I>not</I> a regular expression.
It can be a scalar variable however. In this case it is a space. Then it
takes a list, which can either be a list of scalar variables, an array
or whatever as long as its a list. And you can see what the result is.
You could assign it to an array, but you'd end up with everything in the
first element of the array.

<P>The example below adds an array into the list, and demonstrates use
of a variable as the delimiter.
<FONT COLOR="0000FF"><PRE>
$w1="Mission critical ?";
$w2="Internet ready modems !";
$w3="J(insert your cool phrase here)"; 	# anything prefixed by 'J' is now cool ;-)
$w4="y2k approved, tested and safe !";
$w5="We know the Web.";
$w6="...the leading product in an emerging market.";
@morecool=("networkable","compatible");

$sep=" ";

$cool=join $sep, $w1,$w2,$w3,@morecool,$w4,$w5,$w6;

print $cool;
</PRE></FONT>




<BR><A NAME='106-Arecapbutwithsomenewfunctions'></A> <H1>A recap, but with some new functions</H1>





<BR><A NAME='107-Randomness'></A> <H2>Randomness</H2>



Aren't you wishing you could mix and match randomly so you too could get
a job marketing vapourware ? Heh.
<FONT COLOR="0000FF"><PRE>
@cool=(
"networkable directory services",
"legacy systems compatible",
"Mission critical, Business Ready",
"Internet ready modems !",
"J(insert your cool phrase here)",
"y2k approved, tested and safe !",
"We know the Web. Yeah.",
"...the leading product in an emerging market."
);

srand;

print "How many phrases would you like (max ",scalar(@cool),") ?";
while (1) {
        chop ($input=&lt;STDIN&gt;);
        if ($input &lt;= scalar(@cool) and $input &gt; 0) {
                last;
        }
        print 'Sorry, invalid input, try again :';
}

for (1..$input) {
        $index=int(rand $#cool);
        print "$cool[$index] ";
        splice @cool, $index, 1;
}
</PRE></FONT>
A few things to explain. Firstly, <FONT COLOR="FF0000"><code> while (1) { </code></FONT>. We want an everlasting
loop, and this one way to do it. 1 is always true, so round it goes. We
could test <FONT COLOR="FF0000"><code> $input </code></FONT> directly, but that wouldn't allow 
<FONT COLOR="FF0000"><code> last </code></FONT> to be demonstrated.

<P>Everlasting loops aren't useful unless you are a politician being interviewed. We need
to break out at some point. This is done by the <FONT COLOR="FF0000"><code> last </code></FONT> function.
When <FONT COLOR="FF0000"><code> $input </code></FONT> is between 1 and the number of elements in
<FONT COLOR="FF0000"><code> @cool </code></FONT> then 
out we go. (You can also break out to labels, in case you were wondering.  And break out in a sweat. Don't start now if you weren't.)

<P>The <FONT COLOR="FF0000"><code> srand </code></FONT> operator initialises the random number generator.
Works ok for us, but CGI programmers should think of something different
because their programs are so frequently run (they hope :-).

<P><FONT COLOR="FF0000"><code> rand </code></FONT> generates a random number between 0 and 1, or 0 and a
number it is given. In this case, the number of elements of <FONT COLOR="FF0000"><code> @cool </code></FONT> -1, so from 0 to 7.  There is no point generating numbers between 1 and 8 because the array elements run from 0 to 7.
</P><P>
The <FONT COLOR="FF0000"><code> int </code></FONT> function makes sure it is an integer, that is no messy bits after the decimal point.

<P>The <FONT COLOR="FF0000"><code> splice </code></FONT> function removes the printed element from the array
so it won't appear again. Don't want to stress the point.





<BR><A NAME='108-Concatenation'></A> <H2>Concatenation</H2>





There is another joining operator, this time the humble dot, or period: 
<FONT COLOR="FF0000"><code> . </code></FONT>.  This <B>concatanates</B> (joins) variables:

<FONT COLOR="0000FF"><PRE>
$x="Hello";
$y=" World";
$z="\n";

print "$x\n";           # print $x and a newline

$prt=$x.$y.$z;          # make a new var $prt out of $x, $y and $z

print $prt;

$x.=$y." again ".$z;    # add stuff to $x

print $x;
</PRE></FONT>





<BR><A NAME='109-Files'></A> <H1>Files</H1>








<BR><A NAME='110-Opening'></A> <H2>Opening</H2>




Perl is very good at handling files.  Create, in your perl scripts directory <code>c:\scripts</code>, a file called <code>stuff.txt</code>.  Copy the following into it :</PRE>

<FONT COLOR="0000FF"><PRE>
The Main Perl Newsgroup:comp.lang.perl.misc
The Perl FAQ:http://www.perl.com/faq/
Where to download perl:http://www.activestate.com/
</PRE></FONT>

Now, to open and do things with this file. First, we must open the file and assign it to a <B>filehandle</B>.  All
operations will be done on the file via the filehandle.  Earlier, we used 
<FONT COLOR="FF0000"><code> &lt;STDIN&gt; </code></FONT> as a filehandle - we read from it.
<FONT COLOR="0000FF"><PRE>
$stuff="c:\scripts\stuff.txt";

open STUFF, $stuff;

while (&lt;STUFF&gt;) {
        print "Line number $. is : $_";
}
</PRE></FONT>
What this script does is fail. What is <I>should</I> do is open the file
defined in <FONT COLOR="FF0000"><code> $stuff </code></FONT>, assign it to the filehandle <FONT COLOR="FF0000"><code> STUFF </code></FONT> and then, while there
are still lines left in the file, print the line number <FONT COLOR="FF0000"><code> $. </code></FONT>
and the current line.
<P>




<BR><A NAME='111-Anunforgivableerror'></A> <H2>An unforgivable error</H2>




It fails. That's not so bad, everything fails sometimes. What is unforgivable
is NOT CHECKING THE ERROR CODE !
<P>
This is a better version:
<FONT COLOR="0000FF"><PRE>
open STUFF, $stuff or die "Cannot open $stuff for read :$!";
</PRE></FONT>
If the <FONT COLOR="FF0000"><code>open </code></FONT> operation fails, the <FONT COLOR="FF0000"><code> or </code></FONT> means that the code on the RHS (right hand side) is evaluated. Perl dies. This means it exits the script, performs a post-mortem which it writes up into <FONT COLOR="FF0000"><code> $!</code></FONT>  and tells you the line number at which it died.  Just because <FONT COLOR="FF0000"><code> $! </code></FONT> contains useful information doesn't mean to say it is automagically printed, in true perl fashion.  Usually you will wish to avail yourself of the information inside as it is of great help when working out why something is not going according to plan.  The moral of the chapter is:

<P><B>Always check your return codes !</B>



<BR><A NAME='112-orinpathnamesyourchoice'></A> <H2>\\ or / in pathnames -- your choice</H2>



<P>The problem should now be apparent. The backslashes, being escape characters,
are not displayed. There are two ways to fix this:
<UL>
<LI>Escape the backslashes, like so <FONT COLOR="FF0000"><code>$stuff="c:\\scripts\\stuff.txt";</code></FONT>
<LI>Convert backslashes into forward slashes : <FONT COLOR="FF0000"><code>$stuff="c:/scripts/stuff.txt";</code></FONT>
</UL>

The forward slashes are the preferred option, even under Win32, because you can then port the script direct to Unix or other platforms (assuming you don't use drive letters), and it is less typing.  If you wish to use Perl to start external processes then you must use the <FONT COLOR="FF0000"><code> \\ </code></FONT> method, but this variable will be used only in a Perl program, not as a parameter to start an external program.
Changing the <FONT COLOR="FF0000"><code> $stuff </code></FONT> variable results in a working script. 
<B>Always check your return codes !</B>



<BR><A NAME='113-Readingafile'></A> <H2>Reading a file</H2>



<FONT COLOR="0000FF"><PRE>
$stuff="c:/scripts/stuff.txt";

open STUFF, $stuff or die "Cannot open $stuff for read :$!";

while (&lt;STUFF&gt;) {
        print "Line $. is : $_";
}
</PRE></FONT>
A little more detail on what is happening here. The file is opened for
read. You can append and write too. You don't <I>have</I> to use a variable,
but I always do because it is then easy to change and easy to insert into
the  <FONT COLOR="FF0000"><code> or die  </code></FONT>section, and it is easy to change later on.
Hardcoding things is not the best way to write a maintainable and flexible program.  Just ask the
Year 2000 people about code that lived a little longer than the authors imagined :-).

<FONT COLOR="0000FF"><PRE>
open STUFF, "c:/scripts/stuff.txt" or die "Cannot open stuff.txt for read :$!";
</PRE></FONT>
is just as good but more work if you want to change anything.
<P>The line input operator (that's the angle brackets 
<FONT COLOR="FF0000"><code> &lt;&gt; </code></FONT>
reads from the beginning of the file up until and including the first newline. The
read data goes into <FONT COLOR="FF0000"><code> $_ </code></FONT>, and you can do what you want with it there. On
the next iteration of the loop data is read from where the last read left
off, up to the next newline. And so on until there is no more data. When
that happens the condition is false and the loop terminates. That's the
default behaviour, but we can change this.

<P>This means that you can open a 200Mb file in perl and run through it
without having to load the entire file into memory. 200Mb of memory is
quite a bit. If you really want to load the entire 200Mb file into one
variable, Perl lets you. Limits are not the Perl Way.

<P>The special variable <FONT COLOR="FF0000"><code> $. </code></FONT>is the current line number, starting at 1.

<P>As usual, there is a quicker way to do the previous program.
<FONT COLOR="0000FF"><PRE>
$STUFF="c:/scripts/stuff.txt";

open STUFF or die "Cannot open $STUFF for read :$!";

while (&lt;STUFF&gt;) {
        print "Line $. is : $_";
}
</PRE></FONT>
This saves a little bit of typing, but does tie your filehandle to the variable name. 
In fact, that entire program could be compressed further, but that's for later.
</P><P>
If you are really into shortness, try this:
<FONT COLOR="0000FF"><PRE>
$STUFF="c:/scripts/stuff.txt";

open STUFF or die "Cannot open $STUFF for read :$!";

print "Line $. is : $_" while (&lt;STUFF&gt;);
        

</PRE></FONT>






<BR><A NAME='114-WritingtoaFile'></A> <H2>Writing to a File</H2>








<BR><A NAME='115-Asimplewrite'></A> <H3>A simple write</H3>




<FONT COLOR="0000FF"><PRE>
$out="c:/scripts/out.txt";

open OUT, ">$out" or die "Cannot open $out for write :$!";

for $i (1..10) {
        print OUT "$i : The time is now : ",scalar(localtime),"\n";
}
</PRE></FONT>
Note the addition of <FONT COLOR="FF0000"><code> &gt; </code></FONT> to the filename. This opens it for writing.
If we want to print to the file we now just specify the filehandle
name. You print to the filehandle, which is a gateway to the file.
</P><P>
Filehandles don't have to be capitalised, but it is wise. All Perl
functions are lowercase, and Perl is case-sensitive. <B>So if you choose
uppercase names they are guaranteed not to conflict with current or future
function words.</B>
</P><P>
And a neat way to grab the date sneaked in there too. You should be aware that writing to a file <b>overwrites the file</b>.  It does not <B>append</B> data!  However, you may append:





<BR><A NAME='116-Appending'></A> <H3>Appending</H3>





<FONT COLOR="0000FF"><PRE>
$out="c:/scripts/out.txt";

&amp;printfile;

open OUT, ">>$out" or die "Cannot open $out for append :$!";

print OUT 'The time is now : ',scalar(localtime),"\n";

close OUT;

&amp;printfile;

sub printfile {
        open IN, $out or die "Cannot open $out for read :$!";
        while (&lt;IN&gt;) {
                print;
        }
        close IN;
}
</PRE></FONT>
This script demonstrates subroutines again, and how to append to a file,
that is write additional data at the end. The 
<FONT COLOR="FF0000"><code> close </code></FONT> function is
introduced here. This, well, closes a filehandle. You don't have to close
a filehandle - just leave it open until the script finishes, or the next
open command to the same filehandle will close it for you.





<BR><A NAME='117-ARGVCommandLineArguments'></A> <H3>@ARGV: Command Line Arguments</H3>




<P>Perl has a special array called <FONT COLOR="FF0000"><code> @ARGV </code></FONT>. This is the list of arguments
passed along with the script name on the command line. Run the following
perl script as:
<FONT COLOR="00AA00"><pre>
perl myscript.pl hello world how are you</FONT>

<FONT COLOR="0000FF">
foreach (@ARGV) {
        print "$_\n";
}
</PRE></FONT>
Another useful way to get parameters into a program -- this time without
user input. The relevance to filehandles is as follows. Run the following
perl script as:
<FONT COLOR="00AA00"><pre>
perl myscript.pl stuff.txt out.txt
</FONT><FONT COLOR="0000FF">
while (&lt;&gt;) {
        print;
}
</PRE></FONT>
Short and sweet ? If you don't specify anything in the angle brackets,
whatever is in <FONT COLOR="FF0000"><code> @ARGV </code></FONT> is used instead. And after it finishes with the first
file, it will carry on with the next and so on. You'll need to remove non-file
elements from <FONT COLOR="FF0000"><code> @ARGV </code></FONT> before you use this.
<P>
It can be shorter still:
<FONT COLOR="00AA00"><pre>
perl myscript.pl stuff.txt out.txt
</FONT><FONT COLOR="0000FF">
print while &lt;&gt;;
</PRE></FONT>
Read it right to left. It is possible to shorten it even further !
<FONT COLOR="00AA00"><pre>
perl myscript.pl stuff.txt out.txt
</FONT><FONT COLOR="0000FF">
print <>;
</PRE></FONT>
This takes a little explanation.  As you know, many things in Perl, including filehandles, can be evaluated in list or scalar context.  The result that is returned depends on the context.
<P>
If a filehandle is evaluated in scalar context, it returns the first line of whatever file it is reading from.  If it is evaluated in list context, it returns a list, the elements of which are the lines of the files it is reading from.
<P>
The <FONT COLOR="FF0000"><code> print </code></FONT> function is a list operator, and therefore evaluates everything it is given in list context.  As the filehandle is evaluated in list context, it is given a list !
<P>
Who said short is sweet?  Not my girlfriend, but that's another story. The shortest scripts are not usually the easiest to understand, and not even always the quickest.  Aside from knowing what you want to achieve with the program from a functional point of view, you should also know wheter you are coding for maximum performance, easy maintenance or whatever -- because chances those goals may be to some extent mutually exclusive.


<BR><A NAME='118-ModifyingaFilewithI'></A> <H3>Modifying a File with $^I</H3>




<P>One of the most frequent Perl tasks is to open a file, make some changes
and write it back to the original filename. You already have enough knowledge
to do this. The steps would be:
<OL>
<LI>Make a backup copy of the file</LI>
<LI>Open the file for read</LI>
<LI>Open a new temporary file for write</LI>
<LI>Go through the read file, and write it and any changes to the temp file</LI>
<LI>When finished, close both files</LI>
<LI>Delete the original file</LI>
<LI>Rename the temp file to the original filename</LI>
</OL>
If you have managed to get this far and assiduously work through the examples, the above will be child's play.  Play if you want, but there is a Better Way.
<P>
Make sure you have data in <FONT COLOR="FF0000"><code> c:\scripts\out.txt </code></FONT> then run this:

<FONT COLOR="0000FF"><PRE>
@ARGV="c:/scripts/out.txt";

$^I=".bk";              # let the magic begin

while (&lt;&gt;) {
        tr/A-Z/a-z/;    # another new function sneaked in
        print;          # this goes to the temp filehandle, ARGVOUT, 
			# not STDOUT as usual, so don't mess with it !
}
</PRE></FONT>
So, what's happening?  First, we load up <code>@ARGV</code> with the name of a file.  It doesn't matter how <code>@ARGV</code> is loaded.  We could have 
<FONT COLOR="FF0000"><code>shift</code></FONT>ed the code from the command line.
<P>
The <FONT COLOR="FF0000"><code> $^I </code></FONT> is a special variable. You knew that just by looking at it.  It's name is the Inplace Edit variable, and when it has a value the effects are:
<OL>
<LI>The name of the file to be in-placed edited is taken from the first element of <code>@ARGV</code>. In this case, that is <code>c:/scripts/out.txt</code>.  The file is renamed to its existing name plus the value of <FONT COLOR="FF0000"><code>$^I</code></FONT>, ie <code>out.txt.bk</code>.
<LI>The file is read as usual by the diamond operator 
<FONT COLOR="FF0000"><code>&lt;&gt;</code></FONT>, placing a line at a time into 
<FONT COLOR="FF0000"><code>$_</code></FONT>.
<LI>A new filehandle is opened, called <FONT COLOR="FF0000"><code>ARGVOUT</code></FONT>, and no prizes for guessing it is opened on a file called <code>out.txt</code>.  The original <code>out.txt</code> is renamed.
<LI>The <FONT COLOR="FF0000"><code> print </code></FONT> prints automatically to <code>ARGVOUT</code>, not <code>STDOUT</code> as it would usually.
</OL>
At the end of the operation you have neatly edited the file and made a backup. If you don't want a backup, assign a null string to <FONT COLOR="FF0000"><code> $^I </code></FONT> but don't go crying on any mailing lists if you lose data.
<P>
The usual method of in-place editing would involve just printing everything back where it came from until your regex finds whatever needs changing.  You could of course slurp the whole file into memory and play with it there, which could be a lot easier but if you are dealing with files of more than a few megabytes this is probably not a feasible approach.
<P>
Now take a look at <FONT COLOR="FF0000"><code> out.txt </code></FONT>. Notice how all capital letters have
been <B>transliterated</B> into lowercase. This is the <FONT COLOR="FF0000"><code> tr </code></FONT> operator at
work, <B>which is more efficient than regex for changing single characters</B>.  But that's only a small part of the <FONT COLOR="FF0000"><code> tr </code></FONT> function's value to the world.  More later.
<P>
You should also have an <FONT COLOR="FF0000"><code> out.txt.bk </code></FONT> file. And finally, notice the
way <FONT COLOR="FF0000"><code> @ARGV </code></FONT> has been created. You don't have to create it from the command
line arguments -- it can be treated like an ordinary array, for that is what it is.
<P>




<BR><A NAME='119-Changingwhatisreadinto_'></A> <H3>$/ -- Changing what is read into $_</H3>




On a different note, what if your input file is doesn't look like this:
<PRE>
Beer
Wine
Pizza
Catfood
</PRE>
which is nicely delimited with a newline each time, but like this:
<PRE>
shorts
t-shirt
blouse

pizza
beer
wine
catfood

Viz
Private Eye
The Independent
Byte

toothpaste
soap
towel
</PRE>
which is delimited by TWO newlines, not one. You don't have to save the above as <code>shop.txt</code>, but if you don't, the examples will be difficult to follow.
<P>
Now, if you want each set
of items as elements in an array you'll have to do something like this:
<FONT COLOR="0000FF"><PRE>
$SHOP="shop.txt";
$x=0;

open SHOP or die "Can't open $SHOP for read: $!\n";

while (&lt;SHOP&gt;) {
        if (/^\n/) {            # does line begin with newline ?
                $x++;           # if so, increment $x.  Rest of if statement not executed.
        } else {
                $list[$x].=$_;  # glue $_ on the end of whatever is in $list[$x], using a .
        }               
}

foreach (@list) {
        print "Items are:\n$_\n\n";
}
</PRE></FONT>
which works, but there is a much easier way to do it. You knew I was going
to say that.
<FONT COLOR="0000FF"><PRE>
$SHOP="shop.txt";
$/="\n\n";

open SHOP or die "Can't open $SHOP for read: $!\n";

while (&lt;SHOP&gt;) {
        push (@list, $_);
}

foreach (@list) {
        print "Items are:\n$_\n\n";
}
</PRE></FONT>
The <FONT COLOR="FF0000"><code> $/ </code></FONT> variable is a special variable (it even looks special).
It is the <B>Default Input Record Separator.</B> Remember the operation
of the angle brackets being to read a file in up until the next newline
? Time to come clean. What the angle bracket actually do is read up until
whatever <FONT COLOR="FF0000"><code> $/ </code></FONT> is set to. It is set to a newline by default. 
<P>
So if we set it to two newlines, as above, then it reads up until it finds two consecutive
newlines, then puts the data into <FONT COLOR="FF0000"><code> $_ </code></FONT> This makes the program a lot shorter
and quicker. You can set <FONT COLOR="FF0000"><code> $/ </code></FONT> to just about anything, not just a newline.
If you want to hack this list for example:
<PRE>Tea:Beer:Wine:Pizza:Catfood:Coffee:Chicken:Salmon:Icecream</PRE>
you could just leave <FONT COLOR="FF0000"><code> $/ </code></FONT> as a newline and slurp it into memory in one
go, but imagine the above items are a list of clothes that your girlfriend
wants to buy or a list of clothes your boyfriend should have thrown away
by now. Either are going to be really big files, and you might not want
to read it all into memory in one go. So set <FONT COLOR="FF0000"><code> $/=":"; </code></FONT> and all will
be well. There are also <FONT COLOR="FF0000"><code> read </code></FONT>and 
<FONT COLOR="FF0000"><code> seek </code></FONT> functions, but
they aren't covered here.  Those are useful for files where you read in a precise number of bytes.

<P>
We'll go back to the last example for a moment. It is useful to know
how to read just one line (well, up to <FONT COLOR="FF0000"><code> $/ </code></FONT>) at a time:
<FONT COLOR="0000FF"><PRE>
$SHOP="shop.txt";
$/="\n\n";

open SHOP or die "Can't open $SHOP for read: $!\n";

$clothes=&lt;SHOP&gt;;        # everything up until the first occurrence of $/ into $clothes

$food=&lt;SHOP&gt;;   # everything from first occurrence of $/ to the second into $food

print "We need...\n",$clothes,"...and\n",$food;
</PRE></FONT>
And now we know that, there is a even quicker way to achieve the aim of
the original program :
<FONT COLOR="0000FF"><PRE>

$SHOP="shop.txt";
$/="\n\n";

open SHOP or die "Can't open $SHOP for read: $!\n";

@list=&lt;SHOP&gt;;   # dumps *all* of $SHOP into @list, not just one line.

foreach (@list) {
        print "Items are:\n$_\n\n";
}
</PRE></FONT>
and you don't need to grab it <I>all</I> : 
<FONT COLOR="0000FF"><PRE>
@list[0..2]=&lt;SHOP&gt; 
</PRE></FONT>.
We haven't mentioned list context for a while. Whether the line input
operator <FONT COLOR="FF0000"><code> &lt;&gt; </code></FONT> returns a single value or a list depends on the
context you use it in. When you supply <FONT COLOR="FF0000"><code> @xxxxx </code></FONT> then this must be
a list. If you supply <FONT COLOR="FF0000"><code> $xxxxx </code></FONT> then that's a scalar variable. You
can force it into list context by using parens. 
<P>
The two lines below are provided so you can paste them into the above program.  They demonstrate how parens
force list context.  Remember to replace the <FONT COLOR="FF0000"><code> foreach </code></FONT> with something
that prints the variables.
<FONT COLOR="0000FF"><PRE>
($first, $second) = &lt;SHOP&gt;;
$first,  $second  = &lt;SHOP&gt;;
</PRE></FONT>
</P>




<BR><A NAME='120-HEREDocs'></A> <H3>HERE Docs</H3>




The problem:
<FONT COLOR="0000FF"><PRE>
print "This is a long line of text which might be too long to fit on just one line\n";
print "and I was right, it was too long to fit on one line.  In fact, it looks like it\n";
print "might very well take up to FOUR, yes FOUR lines to print.  That's four print\n";
print "statements, which takes up even more room.  But wait! I'm wrong!  It will take\n";
print "FIVE lines to print this statement!  Or is that six lines? I'm not sure....\n";
</PRE></FONT>
The solution:
<FONT COLOR="0000FF"><PRE>
$var='variable interpolated';

print &lt;&lt;PRT;
This is a long line of text which might be too long to fit on just one line
and I was right, it was too long to fit on one line.  In fact, it looks like
it might very well take up to FOUR, yes FOUR lines to print.  

That's four print statements, which takes up even more room.  But wait! I'm 
wrong!  It will take FIVE lines to print this statement!  Or maybe six lines? 
I'm not sure....but anyway, just to prove this can be $var.
PRT
</PRE></FONT>
That's called a 'here' document and you don't need to use <code>PRT</code>, you can use whatever you like within reason.  You don't need to put in explicit newlines, although if you do they perform as usual. Now you know about here docs you can stop wearing the
<FONT COLOR="FF0000"><code> print </code></FONT> function out by calling it every couple of lines.  You don't have to use here docs to print to files, just anywhere you'd normally put a more than one <FONT COLOR="FF0000"><code> print </code></FONT> statement. 

<BR><A NAME='121-ReadingDirectories'></A> <H1>Reading Directories</H1>

<BR><A NAME='122-Globbing'></A> <H2>Globbing</H2>


For this exercise, I suggest creating another directory where you have at least two text files and two or more binary files. Copy a couple of .dll files from your WINDIR directory if you need to, those will do for the binaries, and save a couple of random text files. Size doesn't matter, in this case.
</P><P>
Then run this, giving the directory as the command line argument:
<FONT COLOR="0000FF"><PRE>
$dir=shift;	# shifts @ARGV, the command line arguments after the script name

chdir $dir or die "Can't chdir to $dir:$!\n" if $dir;

while (&lt;*&gt;) {
	print "Found a file: $_\n" if -T;
}
</PRE></FONT>
</P><P>
The <FONT COLOR="FF0000"><code> chdir </code></FONT> function changes perl's working directory.  You should, as ever, test to see if it worked or not.  In this case we only try and change directory if <code>$dir</code> is true.
</P><P>
The <code> &lt;*&gt; </code> construct reads all files from a given directory, and prints if it passes the file test <FONT COLOR="FF0000"><code> -T </code></FONT>, which returns true if the file is a non-binary, ie text file.  You can be more specific:
<FONT COLOR="0000FF"><PRE>
$dir =shift;
$type='txt';

chdir $dir or die "Can't chdir to $dir:$!\n" if $dir;

while (&lt;*.$type&gt;) {
	print "Found a file: $_\n";
}
</PRE></FONT>
like so. But, there is a better way to read from directories.  The method above is rather slow and inflexible.  

<BR><A NAME='123-readdirHowtoreadfromdirectories'></A> <H2>readdir : How to read from directories</H2>

Instead, there is <FONT COLOR="FF0000"><code> readdir </code></FONT>. Another version of the previous example:
<FONT COLOR="0000FF"><PRE>
$dir= shift || '.';

opendir DIR, $dir or die "Can't open directory $dir: $!\n";

while ($file= readdir DIR) {
	print "Found a file: $file\n";
}
</PRE></FONT>
The first difference is the first line, which essentially says if 
<FONT COLOR="FF0000"><code> shift </code></FONT> is false, then <code>$dir = .</code>, which is of course the current directory.  Then, the directory is opened and we have the chance to trap the error.  It is assigned a filehandle.  The <FONT COLOR="FF0000"><code> readdir </code></FONT> 
function reads each file into <code>$file</code>.  There is no 
<FONT COLOR="FF0000"><code> while (&lt;WDIR&gt;) { </code></FONT> construct.
</P><P>
We can also apply the text file test.  Run this, once without entering a directory and the second time with entering a directory path other than the one the script is in:
<FONT COLOR="0000FF"><PRE>
$dir= shift || '.';

opendir DIR, $dir or die "Can't open directory $dir: $!\n";

while ($file= readdir DIR) {
	print "Found a file: $file\n" if -T $file ;
}
</PRE></FONT>
Firstly, because the filename is now not in
<code>$_</code> we have to explicitly apply the 
<FONT COLOR="FF0000"><code> -T </code></FONT> test to it with <code> -T $file</code>.
</P><P>
Why did this not work the second time?  Look at the code carefully.  You are testing <code>$file</code>.  If perl doesn't get a fully qualified pathname, it assumes you are still in the directory the script was run from, or that of the last successful 
<FONT COLOR="FF0000"><code> chdir </code></FONT>.  Not necessarily where you are
<FONT COLOR="FF0000"><code> readdir</code></FONT>'ing from.  So, to fix it:
<FONT COLOR="0000FF"><PRE>

        print "Found a file: $dir/$file\n" if -T "$dir/$file" ;

</PRE></FONT>
where we now specify the pathname, both in the printout and in the file test itself.  The "" are used because otherwise perl tries to divide <code>$file</code> by <code>$dir</code>.
</P><P>
Try running this on a directory with only a few files in it:
<FONT COLOR="0000FF"><PRE>
$dir= shift || '.';

opendir DIR, $dir or die "Can't open directory $dir: $!\n";

while ($file= readdir DIR) {
	print "Found a file: '$file'\n";
}
</PRE></FONT>
Notice that two files are found which have interesting names, namely <code> . </code> and <code> .. </code>.  These two files are the current, and lower directory respectively. Nothing new, they have always been there -- run the DOS command <code> dir </code> if you don't believe me.  You don't usually want to know about them, so:
<FONT COLOR="0000FF"><PRE>
while ($file= readdir DIR) {
	next if $file=~/^\./;
	print "Found a file: '$file'\n";
}
</PRE></FONT>
is the usual workaround.  You can use scalar context to dump everything to a list of some description:
<FONT COLOR="0000FF"><PRE>
$dir= shift || '.';

opendir DIR, $dir or die "Can't open directory $dir: $!\n";

@files=readdir(DIR);

print "@files";
</PRE></FONT>
but that includes the <code>.</code> files, so it is best to ensure they aren't included:
<FONT COLOR="0000FF"><PRE>
@files=grep !/^\./, readdir(DIR);
</PRE></FONT>
We haven't met <FONT COLOR="FF0000"><code> -T </code></FONT> yet, but for the moment just remember it searches a list and if it returns true, lets the variable pass.  In this case, if it doesn't begin with . then that's true so it goes into <code>@files</code>.
</P><P>
There are other commands associated with reading directories, which tell you where in a directory you are, and then where to go to return.  You should be aware of their existence, because you never know when you might need them.  The one other command of use is 
<FONT COLOR="FF0000"><code> closedir </code></FONT>, which closes a directory.  Optional, but recommended for clarity.

<BR><A NAME='124-AssociativeArrays'></A> <H1>Associative Arrays</H1>

<BR><A NAME='125-TheBasics'></A> <H2>The Basics</H2>

<P>
Very, very useful.  First, a quick recap on arrays.  Arrays are an ordered list of scalar variables, which you access by their index number starting at 0.  <B>The elements in arrays always stay in the same order</B>.
</P><P>
Hashes are a list of scalars, but instead of being accessed by index number,
<B>they are accessed by a key</B>. The tables below illustrate the point:
<P>
<CENTER><TABLE BORDER=0 CELLSPACING=4 CELLPADDING=2>
<TR>
<TD VALIGN=TOP>
<TABLE BORDER=2 CELLPADDING=4 >
<TR>
<TD ALIGN=CENTER COLSPAN="2"><B>@myarray</B></TD>
</TR>

<TR>
<TD ALIGN=CENTER><I>Index No.</I></TD>
<TD><I>Value</I></TD>
</TR>

<TR>
<TD ALIGN=CENTER>0</TD>
<TD>The Netherlands</TD>
</TR>

<TR>
<TD ALIGN=CENTER>1</TD>
<TD>Belgium</TD>
</TR>

<TR>
<TD ALIGN=CENTER>2</TD>
<TD>Germany</TD>
</TR>

<TR>
<TD ALIGN=CENTER>3</TD>
<TD>Monaco</TD>
</TR>

<TR>
<TD ALIGN=CENTER>4</TD>
<TD>Spain</TD>
</TR>
</TABLE>
 </TD>

<TD> </TD>

<TD VALIGN=TOP>
<TABLE BORDER=2 CELLPADDING=4 >
<TR>
<TD ALIGN=CENTER COLSPAN="2"><B>%myhash</B></TD>
</TR>

<TR>
<TD ALIGN=CENTER><I>Key</I></TD>
<TD><I>Value</I></TD>
</TR>

<TR>
<TD ALIGN=CENTER>NL</TD>
<TD>The Netherlands</TD>
</TR>

<TR>
<TD ALIGN=CENTER>BE</TD>
<TD>Belgium</TD>
</TR>

<TR>
<TD ALIGN=CENTER>DE</TD>
<TD>Germany</TD>
</TR>

<TR>
<TD ALIGN=CENTER>MC</TD>
<TD>Monaco</TD>
</TR>

<TR>
<TD ALIGN=CENTER>ES</TD>

<TD>Spain</TD>
</TR>
</TABLE>
 </TD>
</TR>
</TABLE></CENTER>
</P><P>
So if we want 'Belgium' from <FONT COLOR="FF0000"><code> @myarray </code></FONT> and also from
<FONT COLOR="FF0000"><code> %myhash </code></FONT>, it'll be:
<FONT COLOR="0000FF"><PRE>
print "$myarray[1]";
print "$myhash{'BE'}";
</PRE></FONT>
Notice that the <FONT COLOR="FF0000"><code> $ </code></FONT> prefix is used, because it is a scalar variable. Despite the fact it is part of a list, it is still a scalar variable. The
hash syntax is simply to use braces <FONT COLOR="FF0000"><code> { } </code></FONT> instead of square brackets.
</P><P>
So why use hashes ? When you want to look something up by a keyword.
Suppose we wanted to create a program which returns the name of the country
when given a country code. We'd input ES, and the program would come back
with Spain.
</P><P>
You could do it with arrays. It would be messy however. One possible approach:
<OL>
<LI>create <FONT COLOR="FF0000"><code> @country </code></FONT>, and give it values such as <code>'ES,Spain'</code></LI>
<LI>Itierate over the entire array and </LI>
<LI><FONT COLOR="FF0000"><code> split </code></FONT> each element of the array, and check the first result to see if it matches the input</LI>
<LI>If so, return the index</LI>
</OL>

<FONT COLOR="0000FF"><PRE>
@countries=('NL,The Netherlands','BE,Belgium','DE,Germany','MC,Monaco','ES,Spain');

print "Enter the country code:";
chop ($find=&lt;STDIN&gt;);

foreach (@countries) {
        ($code,$name)=split /,/;
        if ($find=~/$code/i) {
                print "$name has the code $code\n";
        }
}
</PRE></FONT>
Complex and slow. We could also store a reference to another array in each
element of <FONT COLOR="FF0000"><code> @countries </code></FONT>, but that is not efficient.  Whatever way we choose,
 you still need to search the whole thing. And what if <FONT COLOR="FF0000"><code> @countries </code></FONT>
 is a big array ? See how much easier a hash is:



<BR><A NAME='126-AHashinAction'></A> <H2>A Hash in Action</H2>



<FONT COLOR="0000FF"><PRE>
%countries=('NL','The Netherlands','BE','Belgium','DE','Germany','MC','Monaco','ES','Spain');

print "Enter the country code:";
chop ($find=&lt;STDIN&gt;);

$find=~tr/a-z/A-Z/;
print "$countries{$find} has the code $find\n";
</PRE></FONT>
Very easy. All we need to do is make sure everything is in uppercase with
<FONT COLOR="FF0000"><code> tr </code></FONT> and we are there. Notice the way 
<FONT COLOR="FF0000"><code> %countries </code></FONT> is defined - exactly
the same as a normal array, except that the values are put into the hash
in key/value pairs.
</P><P>




<BR><A NAME='127-Whenyoushouldusehashes'></A> <H2>When you should use hashes</H2>




So why use arrays ? One excellent reason is because when an array is
created, its variables stay in the same order you created them in. With
a hash, perl reorders elements for quick access. Add 
<FONT COLOR="FF0000"><code> print %countries; </code></FONT>
to the end of that program above and run it. See what I mean ? No
recognisable sequence at all.  It's like trying to herd cats. If you were writing code that stored a list of variables over time and you wanted it back in the order you found it
in, don't use a hash.
</P><P>
Finally, you should know that each <B>key of a hash must be unique.</B>
Stands to reason, if you think about it. You are accessing the hash via
keys, so how can you have two keys named 'NL' or something ? If you do
define a certain key twice, the second value overwrites the first. This
is a feature, and useful. The values of a hash can be duplicates, but never
the keys.
</P><P>
If you want to assign to a hash, there is of course no concept of <FONT COLOR="FF0000"><code> push </code></FONT> , 
<FONT COLOR="FF0000"><code> pop </code></FONT> and <FONT COLOR="FF0000"><code> splice </code></FONT> etc. 
Instead:



<BR><A NAME='128-HashHackingFunctions'></A> <H2>Hash Hacking Functions</H2>


<P>
<TABLE BORDER=1 CELLSPACING=3 CELLPADDING=4 >
<TR>
<TD>Assigning</TD>
<TD><FONT COLOR="FF0000"><code>$countries{PT}='Portugal';</code></FONT></TD>
</TR>

<TR>
<TD>Deleting</TD>
<TD><FONT COLOR="FF0000"><code>delete $countries{NL};</code></FONT></TD>
</TR>
</TABLE>
<P>
<b>Accessing Your Hash</B>

<P>Assuming you keep the same <FONT COLOR="FF0000"><code> %countries </code></FONT>
 hash as above, here are some useful ways to access it:
<P>
<TABLE BORDER=1 CELLSPACING=3 CELLPADDING=4 >
<TR>
<TD>All the keys</TD>
<TD><FONT COLOR="FF0000"><code>print keys %countries;</CODE></FONT> </TD>
</TR>
<TR>
<TD>All the values</TD>
<TD><FONT COLOR="FF0000"><code>print values %countries;</CODE></FONT> </TD>
</TR>
<TR>
<TR>
<TD>A Slice of Hash :-)</TD>
<TD><FONT COLOR="FF0000"><code>print @countries{'NL','BE'};</CODE></FONT> </TD>
</TR>
<TR>
<TD>How many elements ?</TD>
<TD><FONT COLOR="FF0000"><code>print scalar(keys %countries);</CODE></FONT> </TD>
</TR>
<TR>
<TD>Does the key exist ?</TD>
<TD><FONT COLOR="FF0000"><code>print "It's there !\n" if exists $countries{'NL'};</CODE></FONT> </TD>
</TR>
</TABLE>
<P>
Well, that last one is not an access as a such but useful anyway.
<P>



<BR><A NAME='129-MoreHashAccessIterationkeysandvalues'></A> <H2>More Hash Access: Iteration, keys and values</H2>



You may have noticed that <FONT COLOR="FF0000"><code>keys </CODE></FONT>and <FONT COLOR="FF0000"><code>values </CODE></FONT>return a
list. And we can iterate over a list, using <FONT COLOR="FF0000"><code>foreach</CODE></FONT> :
<FONT COLOR="0000FF"><PRE>
foreach (keys %countries) {
        print "The key $_ contains $countries{$_}\n";
}
</PRE></FONT>
which is useful. Note how any list can be fed to <FONT COLOR="FF0000"><code>foreach </CODE></FONT>, and off it goes. As usual, there is another way to do the above:
<FONT COLOR="0000FF"><PRE>
while (($code,$name)=each %countries) {
        print "The key $code contains $name\n";
}
</PRE></FONT>
The <FONT COLOR="FF0000"><code>each </CODE></FONT> function returns each key/value pair of the hash, and
is slightly faster. In this example we assign them to a list (you spotted
the parens ?) and away we go. Eventually there are no more pairs, which
returns false to the <FONT COLOR="FF0000"><code>while </CODE></FONT> loop and it stops.
</P><P>
If you are into brevity, both the above can be accomplished in a single line:
<FONT COLOR="0000FF"><PRE>
print "The key $code contains $name\n" while ($code,$name)=each %countries;

print "The key $_ contains $countries{$_}\n" foreach keys %countries;
</PRE></FONT>
</P><P>
Note -- this won't win any prizes for easily readable code by non-programmers of Perl.
</P>




<BR><A NAME='130-Sorting'></A> <H1>Sorting</H1>








<BR><A NAME='131-ASimpleSort'></A> <H2>A Simple Sort</H2>




<P>
If I was reading this I'd be wondering about sorting.  Wonder no more, and behold:
<FONT COLOR="0000FF"><PRE>
foreach (sort keys %countries) {
        print "The key $_ contains $countries{$_}\n";
}
</PRE></FONT>
Spot the difference. Yes, <FONT COLOR="FF0000"><code>sort </CODE></FONT>crept in there. If you want the list sorted backwards, some cunning is called for. This is suitably foxy:
<FONT COLOR="0000FF"><PRE>
foreach (reverse sort keys %countries) {
        print "The key $_ contains $countries{$_}\n";
}
</PRE></FONT>
Perl is just so difficult at times, don't you think ? This works because:
<UL>
<LI><FONT COLOR="FF0000"> keys </code></FONT> returns a list
<LI><FONT COLOR="FF0000"> sort </code></FONT> expects a list -- and gets one from <FONT COLOR="FF0000"> keys </code></FONT>, and sorts it
<LI><FONT COLOR="FF0000"> reverse </code></FONT> also expects a list, so it gets one and returns it
<LI>then the whole list is <FONT COLOR="FF0000"> foreach </code></FONT>'d over.
</UL>
This is a quick example to make sure the meaning of <FONT COLOR="FF0000"> reverse </code></FONT> is clear:
<FONT COLOR="0000FF"><PRE>
print "Enter string to be reversed: ";
$input=&lt;STDIN&gt;;

@letters=split //,$input;	# splits on the 'nothings' in between each character of $input

print join ":", @letters;	# joins all elements of @letters with \n, prints it
print reverse   @letters;	# prints all of @letters, but sdrawkcab )-:
</PRE></FONT>
Perl's list operators can just feed directly to each other, saving many lines of code but also decreasing readability to those that aren't Perl-literate:
<FONT COLOR="0000FF"><PRE>
print "Enter string to be reversed: ";
print join ":",reverse split //,$_=&lt;STDIN&gt;;
</PRE></FONT>
This section is about sorting, so enough of <FONT COLOR="FF0000"> reverse </code></FONT>.  Time to go forwards instead.
</P>




<BR><A NAME='132-NumericSortingHowSortReallyWorks'></A> <H2>Numeric Sorting -- How Sort Really Works</H2>




<P>
That's easy alphabetical sorting by the keys. If you had a hash of international access numbers
like this one:
<FONT COLOR="0000FF"><PRE>
%countries=('976','Mongolia','52','Mexico','212','Morocco','64','New Zealand','33','France');

foreach (sort keys %countries) {
        print "The key $_ contains $countries{$_}\n";
}
</PRE></FONT>
You might want to sort numerically. In that case, you need to understand how
Perl's <FONT COLOR="FF0000"> sort </code></FONT> function works. 
</P><P>
The <FONT COLOR="FF0000"> sort </code></FONT> function compares two variables, 
<FONT COLOR="FF0000"> $a </code></FONT> and 
<FONT COLOR="FF0000"> $b </code></FONT>. They must be called
<FONT COLOR="FF0000"> $a </code></FONT> and <FONT COLOR="FF0000"> $b </code></FONT> otherwise it won't work. One chap published a book with stolen code, and he changed <FONT COLOR="FF0000"> $a </code></FONT> and
<FONT COLOR="FF0000"> $b </code></FONT> to $x and $y. He obviously didn't test the
program because it would have failed and he would have noticed. And this
book was really published ! Don't believe everything you read in books
-- but web tutorials are always 100% truthful :-)
</P><P>
Back to sorting. <FONT COLOR="FF0000"> $a </code></FONT> and 
<FONT COLOR="FF0000"> $b </code></FONT> are compared, and the result is:
<UL>
<LI><B>1</B> if <FONT COLOR="FF0000"> $a </code></FONT> is greater than <FONT COLOR="FF0000"> $b </code></FONT></LI>
<LI><B>-1</B> if <FONT COLOR="FF0000"> $b </code></FONT> is greater than <FONT COLOR="FF0000"> $a </code></FONT></LI>
<LI><B>0</B> if <FONT COLOR="FF0000"> $a </code></FONT> and <FONT COLOR="FF0000"> $b </code></FONT> are equal</LI>
</UL>
So as long as the <FONT COLOR="FF0000"> sort </code></FONT> function gets one of those three values back it is happy.  This means we can write our own sort routines, and feed them to sort.  For example, we know the default sort is alphabetical.  But if we write this:

<FONT COLOR="0000FF"><PRE>
%countries=('976','Mongolia','52','Mexico','212','Morocco','64','New Zealand','33','France');

foreach (sort supersort keys %countries) {
        print "$_ $countries{$_}\n";
}

sub supersort {
        if ($a &gt; $b) {
                return 1;
        } elsif ($a &lt; $b) { 
		return -1;
	} else { 
		return 0; 
	}
}
</PRE></FONT>
then it works correctly. Of course, there is an easier way. The 'spaceship' operator
<FONT COLOR="FF0000"><code>&lt;=&gt; </CODE></FONT>. It does exactly what the supersort subroutine does, namely return
1, -1 or 0 depending on the comparison of two given values.
<P>
So we can write the above much more easily as:
<FONT COLOR="0000FF"><PRE>
%countries=('976','Mongolia','52','Mexico','212','Morocco','64','New Zealand','33','France');

foreach (sort { $a &lt;=&gt; $b } keys %countries) {
        print "$_ $countries{$_}\n";
}
</PRE></FONT>
Notice the { } braces, which define the contents as the subroutine sort
must use. Pretty short subroutine. There is a companion operator to <FONT COLOR="FF0000"><code>&lt;=&gt;
</CODE></FONT>, namely <FONT COLOR="FF0000"><code> cmp </CODE></FONT>which does exactly the same thing but of course
compares the values as strings, not numbers.<I>Remember, if you are comparing
numbers, your comparison operator should contain non-alphas, if you are
comparing strings the operator should contains alphas only.  And don't talk to strangers.</I>
</P><P>
Anyway, you now have enough knowledge to sort a hash by value instead
of keys. Suppose your pointy haired manager bounced up to you and demanded
a hash sorted by <B>value</B> ? What would you do ? OK, what <I>should</I> you
do ?
</P><P>
Well, we could just sort the values.
<FONT COLOR="0000FF"><PRE>
foreach (sort values %countries) {
</PRE></FONT>
But Pointy Hair wants the keys too. And if you have a value you can't find
the key.
<P>
So we have to iterate over the keys. But just because we are iterating
over the keys doesn't mean to say we have to hand the keys over to
<FONT COLOR="FF0000"><code> sort </code></FONT>. What about:
<FONT COLOR="0000FF"><PRE>
%countries=('976','Mongolia','52','Mexico','212','Morocco','64','New Zealand','33','France');

foreach (sort { $countries{$a} cmp $countries{$b} } keys %countries) {
        print "$_ $countries{$_}\n";
}
</PRE></FONT>
beautifully simple. If you want a reverse sort transpose <FONT COLOR="FF0000"><code> $a </code></FONT> and <FONT COLOR="FF0000"><code> $b </code></FONT>.
</P>




<BR><A NAME='133-SortingMultipleLists'></A> <H2>Sorting Multiple Lists</H2>




<P>You can sort several lists at the same time:
<FONT COLOR="0000FF"><PRE>
%countries=('976','Mongolia','52','Mexico','212','Morocco','64','New Zealand','33','France');
@nations=qw(China Hungary Japan Canada Fiji);

@sorted= sort values %countries, @nations;

foreach (@nations, values %countries) {
        print "$_\n";
}

print "#----\n";

foreach (@sorted) {
        print "$_\n";
}
</PRE></FONT>
This sorts <FONT COLOR="FF0000"><code> @nations </code></FONT> and the values from 
<FONT COLOR="FF0000"><code> %countries </code></FONT> into a new array. 
</P><P>
The example also demonstrates that you can <FONT COLOR="FF0000"><code>foreach</CODE></FONT> over more than one list value -- each list is processed in turn.  How I discovered that particular trick with Perl is instructive.  I just tried it.  If you think you should be able to do something with Perl, try it.  Adhere to the syntax and conventions you will be familiar with from experience, in this case delimiting a list with commas, and try it. I'm always finding new shortcuts just by experimentation.
</P>




<BR><A NAME='134-GrepandMap'></A> <H1>Grep and Map</H1>








<BR><A NAME='135-Grep'></A> <H2>Grep</H2>




If you want to search a list, and create another list of things you found, 
<FONT COLOR="FF0000"><code> grep </CODE></FONT> is one solution.  
This is an example, which also demonstrates <FONT COLOR="FF0000"><code> join </CODE></FONT> again :

<FONT COLOR="0000FF"><PRE>
@stuff=qw(flying gliding skiing dancing parties racing);	# quote-worded list

@new = grep /ing/, @stuff;	# Creates @new, which contains elements of @stuff 
				# matching with 'ing' in them.

print join ":",@stuff,"\n";	# first makes one string out of the elements of @stuff, joined
				# with ':' , then prints it, then prints \n

print join ":",@new,"\n";
</PRE></FONT>
Remember <FONT COLOR="FF0000"><code>qw </CODE></FONT>means 'quote words', so word boundaries are used as
delimiters instead. The <FONT COLOR="FF0000"><code>grep </CODE></FONT>function must be fed a list on the
right hand side. On the left side, you may assign the results to a list
or a scalar variable. Assigning to a list gives you each actual element, and to a scalar
gives you the number of matches found:
<FONT COLOR="0000FF"><PRE>
@stuff=qw(flying gliding skiing dancing parties racing);

$new = grep /ing/, @stuff;

print join ":",@stuff,"\n";

print "Found $new elements of \@stuff which matched\n";
</PRE></FONT>
If you decide to modify the elements on their way through <FONT COLOR="FF0000"><code> grep </code></FONT>, you actually modify the original list.  Be careful out there.
<FONT COLOR="0000FF"><PRE>
@stuff=qw(flying gliding skiing dancing parties racing);

@new = grep s/ing//, @stuff;

print join ":",@stuff,"\n";
print join ":",@new,"\n";
</PRE></FONT>
To determine what actually matches you can either use an expression or
a block. Up to now we've been using expressions, but when things become
more complicated use a block:
<FONT COLOR="0000FF"><PRE>
@stuff=qw(flying gliding skiing dancing parties racing);

@new = grep { s/ing// if /^[gsp]/ } @stuff;

print join ":",@stuff,"\n";
print join ":",@new,"\n";
</PRE></FONT>
Try removing the braces and you'll get an error. Notice that the comma
before the list has gone. It is now obvious where the expression ends,
as it is inside a block delimited with { } . The regex says if the element
begins with g, s or p, then remove ing. The result is only assigned to
<FONT COLOR="FF0000"><code> @new </code></FONT> if the expression is completely true - 'parties' does begin with p,
so that works, but <FONT COLOR="FF0000"><code> s/ing// </code></FONT> fails so the overall result is false, and the
value is not assigned to <FONT COLOR="FF0000"><code> @new </code></FONT>.





<BR><A NAME='136-Map'></A> <H2>Map</H2>





Map works the same way as <FONT COLOR="FF0000"><code> grep </code></FONT>, in that they both iterate over a list, and return a list.  There are two important differences however:

<UL>
<LI><FONT COLOR="FF0000"><code> grep </code></FONT> returns the <B>value</B> of everything it <B>evaluates to be <I>true</I></B>;</LI>
<LI><FONT COLOR="FF0000"><code> map </code></FONT> returns the <B>results</B> of <B>everything</B> it evaluates.</LI>
</UL>

As usual, an example will assist the penny in dropping, clear the fog and turn on the light (if not make my metaphors easier to understand):

<FONT COLOR="0000FF"><PRE>
@stuff=qw(flying gliding skiing dancing parties racing);

print "There are ",scalar(@stuff)," elements in \@stuff\n";
print join ":",@stuff,"\n";

@mapped  = map  /ing/, @stuff;
@grepped = grep /ing/, @stuff;

print "There are ",scalar(@stuff)," elements in \@stuff\n";
print join ":",@stuff,"\n";

print "There are ",scalar(@mapped)," elements in \@mapped\n";
print join ":",@mapped,"\n";

print "There are ",scalar(@grepped)," elements in \@grepped\n";
print join ":",@grepped,"\n";
</PRE></FONT>
You can see that <FONT COLOR="FF0000"><code> @mapped </code></FONT> is just a list of 1's.  Notice that there are <B>5 ones</B> whereas there are <B>six elements</B> in the original array, <code>@stuff</code>. This is because <code>@mapped</code> contains the <I>true results</I>
of <FONT COLOR="FF0000"><code> map </code></FONT> -- in every case the expression 
<FONT COLOR="FF0000"><code> /ing/ </code></FONT> is successful, except for 'parties'.
</P><P>
In that case there the expression is false, so the result is discarded. Contrast this action with the 
<FONT COLOR="FF0000"><code> grep </code></FONT> function, which returns
the actual value, <B>but only if it is true</B>. Try this:
<FONT COLOR="0000FF"><PRE>
@letters=(a,b,c,d,e);

@ords=map ord, @letters;
print join ":",@ords,"\n";

@chrs=map chr, @ords;   
print join ":",@chrs,"\n";
</PRE></FONT>
This uses the <FONT COLOR="FF0000"><code> ord </code></FONT> function to change each letter into its ASCII equivalent,
then the <FONT COLOR="FF0000"><code> chr </code></FONT> function convert ASCII numbers to characters. If you change
<FONT COLOR="FF0000"><code> map </code></FONT> to <FONT COLOR="FF0000"><code> grep </code></FONT> in the example above, you can see that nothing appears to happen.
What is happening is that <FONT COLOR="FF0000"><code> grep </code></FONT> is trying the expression on each element,
and if it succeeds (is true) it returns the element, not the result. The
expression succeeds for each element, so each element is returned in turn.
Another example:
<FONT COLOR="0000FF"><PRE>
@stuff=qw(flying gliding skiing dancing parties racing);

print join ":",@stuff,"\n";

@mapped  = map  { s/(^[gsp])/$1 x 2/e } @stuff;
@grepped = grep { s/(^[gsp])/$1 x 2/e } @stuff;

print join ":",@stuff,"\n";
print join ":",@mapped,"\n";
print join ":",@grepped,"\n";
</PRE></FONT>
Recapping on regex, what that does is match any element beginning with
g, s or p, and replace it with the same element twice. The caret <FONT COLOR="FF0000"><code> ^ </code></FONT> forces
a match at the beginning of the string, the [square brackets] denote a
character class, and <FONT COLOR="FF0000"><code> /e </code></FONT> forces Perl to evaluate the RHS as an expression.

<P>The output from this is a mixture of 1 and nothing for <FONT COLOR="FF0000"><code> map </code></FONT>, and a three-element
array called <FONT COLOR="FF0000"><code> @grepped </code></FONT> from grep. Yet another example:
<FONT COLOR="0000FF"><PRE>
@mapped  = map  { chop } @stuff;
@grepped = grep { chop } @stuff;
</PRE></FONT>
The <FONT COLOR="FF0000"><code>chop </CODE></FONT>function removes the last character from a string, and
returns it. So that's what you get back from <FONT COLOR="FF0000"><code> ^ </code></FONT>, the <I>result</I> of the expression.
The <FONT COLOR="FF0000"><code>grep</CODE></FONT> function gives you the mangled remains of the original
value.




<BR><A NAME='137-Writingyourowngrepandmapfunctions'></A> <H2>Writing your own grep and map functions</H2>




<P>Finally, you can write your own functions:
<FONT COLOR="0000FF"><PRE>
@stuff=qw(flying gliding skiing dancing parties racing);

print join ":",@stuff,"\n";

@mapped  = map  { &amp;isit } @stuff;
@grepped = grep { &amp;isit } @stuff;

print join ":",@mapped,"\n";
print join ":",@grepped,"\n";

sub isit {
        ($word)=/(^.*)ing/;

        if (length $word == 3) {
                return "ok";
        } else {
                return 0;
        }
}
</PRE></FONT>
The subroutine <FONT COLOR="FF0000"><code>isit </CODE></FONT>first grabs everything up until 'ing', puts
it into <FONT COLOR="FF0000"><code> $word </code></FONT>, then returns 'ok' if the there are three characters in 
<FONT COLOR="FF0000"><code> $word </code></FONT>.
If not, it returns the false value 0. You can make these subroutines (think of them as functions) as complex as you like.
<P>
Sometimes it is very useful to have <FONT COLOR="FF0000"><code> map </code></FONT> return the actual value, rather than the result.  The answer is easy, but not obvious.  Remember that subroutines return the value of the last expression evaluated?  So, in this case, do blocks. What if the expression was, very simply:
<FONT COLOR="0000FF"><PRE>
@grepstuff=@mapstuff=qw(flying gliding skiing dancing parties racing);

print join " ",map  { s/(^[gsp])/$1 x 2/e } @mapstuff;
print "\n";
print join " ",grep { s/(^[gsp])/$1 x 2/e } @grepstuff;
</PRE></FONT>
Now, make sure <FONT COLOR="FF0000"><code> $_ </code></FONT> is the last thing evaluated:
<FONT COLOR="0000FF"><PRE>
@grepstuff=@mapstuff=qw(flying gliding skiing dancing parties racing);

print join " ",map  { s/(^[gsp])/$1 x 2/e;$_} @mapstuff;
print "\n";
print join " ",grep { s/(^[gsp])/$1 x 2/e } @grepstuff;
</PRE></FONT>
and there you have it.  Now you understand that you can go and impress your friends, but please don't count on success.





<BR><A NAME='138-ExternalCommands'></A> <H1>External Commands</H1>








<BR><A NAME='139-Somewaysto'></A> <H2>Some ways to...</H2>




Perl can start external commands.  There are five main ways to do this:
<UL>
<LI><FONT COLOR="FF0000"><code>system</CODE></FONT></LI>
<LI><FONT COLOR="FF0000"><code>exec</CODE></FONT></LI>
<LI>Command Input, also known as <FONT COLOR="FF0000"><code>`backticks`</CODE></FONT></LI>
<LI>Piping data from a process
<LI>Quote execute
</UL>

We'll compare <FONT COLOR="FF0000"><code>system</CODE></FONT> and <FONT COLOR="FF0000"><code>exec</CODE></FONT> first.





<BR><A NAME='140-Exec'></A> <H2>Exec</H2>




<P>
Poor old <FONT COLOR="FF0000"><code> exec </code></FONT> is broken on Perl for Win32.  What it should do is stop running your Perl script and start running whatever you tell it to.  If it can't start the external process, it should return with an error code.  This doesn't work properly under Perl for Win32.  The <FONT COLOR="FF0000"><code> exec </code></FONT> function does work properly on the standard Perl distribution.
</P>




<BR><A NAME='141-System'></A> <H2>System</H2>




This runs an external command for you, then carries on with the script.  It always returns, and the value it returns goes into <FONT COLOR="FF0000"><code> $? </CODE></FONT>.  This means you can test to see if the program worked.  Actually you are testing to see if it could be started, what the program does when it runs is outside your control if you use <FONT COLOR="FF0000"><code> system </code></FONT>.
</P><P>
This example demonstrates <FONT COLOR="FF0000"><code> system </code></FONT> in action. Run the 'vol' command from a command prompt first if you are not familiar with it. Then run the 'vole' command. I'm assuming you have no cute furry executables called vole on your system,
or at least in the path. If you do have an executable called 'vole', be creative and change it.

<FONT COLOR="0000FF"><PRE>
system("vole");

print "\n\nResult: $?\n\n";

system("vol");

print "\n\nResult: $?\n\n";
</PRE></FONT>
As you can see, a successful system call returns 0. An unsuccessful one
returns a value which you need to divide by 256 to get the real return
value. Also notice you can see the output. And because <FONT COLOR="FF0000"><code>system</CODE></FONT>
returns, the code after the first <FONT COLOR="FF0000"><code> system </code></FONT> call is executed. Not so with
<FONT COLOR="FF0000"><code>exec</CODE></FONT>, which will terminate your perl script if it is successful.  Perl's usual use of single and double quotes applies as per variable interpolation.





<BR><A NAME='142-Backticks'></A> <H2>Backticks</H2>




These <FONT COLOR="FF0000"><code> `` </code></FONT> are different again to system and exec.  They also start external processes, but <B>return the output of the process. </B>You can then do whatever you like with the output.  If you aren't sure where backticks are on your keyboard, try the top left, just left of the 1 key. Often around there.  Don't confuse single quotes 
<FONT COLOR="FF0000"><code> '' </code></FONT> with backticks
<FONT COLOR="FF0000"><code> `` </code></FONT>.

<FONT COLOR="0000FF"><PRE>
$volume=`vol`;

print "The contents of the variable \$volume are:\n\n";

print $volume;

print "\nWe shall regexise this variable thus :\n\n";

$volume=~m#Volume in drive \w is (.*)#;

print "$1\n";
</PRE></FONT>
As you can see here, the Win32 vol command is executed. We just print it
out, escaping the <FONT COLOR="FF0000"><code> $ </code></FONT> in the variable name. Then a simple regex, using #
as a delimiter just in case you'd forgotten delimiters don't have to be / .





<BR><A NAME='143-Whentouseexternalcalls'></A> <H2>When to use external calls</H2>




<P>Before you get carried away with creating elaborate scripts based on
the output from NT's <FONT COLOR="FF0000"><code>net </CODE></FONT>commands, note there are plenty of excellent
modules out there which do a very good job of this sort of thing, and that
any form of external process call slows your script. Also note there are
plenty of built in functions such as <FONT COLOR="FF0000"><code>  readdir </code></FONT> which can be used instead
of <FONT COLOR="FF0000"><code> `dir` </code></FONT>. <B>You should use Perl functions where possible rather than calling
external programs</B> because Perl's functions are:
<UL>
<LI>
portable (usually, but there are exceptions). This means you can write
a script on your Mac PowerBook, test it on an NT box and then use it live
on your Unix box without modifying a single line of code;</LI>
<LI>
faster, as every external process significantly slows your program;</LI>
<LI>
don't usually require regexing to find the result you want;</LI>
<LI>
don't rely on output in a particular format, which might be changed in
the next version of your OS or application;</LI>
<LI>are more likely to be understood by a Perl programmer -- for example, <FONT COLOR="FF0000"><code>$files=`ls`;
</CODE></FONT>on a Unix box means little to someone that doesn't know that <code>ls</code> is
the Unix command for listing files, as <code>dir</code> is in Windows.</LI>
</UL>
Don't start using backticks all over the place when <FONT COLOR="FF0000"><code>system</CODE></FONT> will
do. You might get a very large return value which you don't need, and will
 consequently slurp lots of memory. Just use them when you actually want to check the returned strings.





<BR><A NAME='144-OpeningaProcess'></A> <H2>Opening a Process</H2>




The problem with backticks is that you have to wait for the entire process to complete, then analyse the entire
return code.  This is a big problem if you have large return codes or slow processes.  For example, the DOS
command <code>tree</code>.  If you aren't familiar with this command, run a DOS/command prompt, switch to the root directory  (<code>C:\ </code>) and type <code>tree</code>.  Examine the wondrous output.
<P>
We can open a process, and pipe data in via a filehandle in exactly the same way you would read a file.  The code below is exactly the same as opening a filehandle on a file, with two exceptions:
<OL>
<LI>We use an external command, not a filename.  That's the process name, in this case, <code>tree</code>.
<LI>A pipe, ie <FONT COLOR="FF0000"><code> | </CODE></FONT> is appended to the process name.
</OL>
<FONT COLOR="0000FF"><PRE>
open TRIN, "tree c:\\ /a |" or die "Can't see the tree :$!";

while (&lt;TRIN&gt;) {
	print "$. $_";
}
</PRE></FONT>
Note the <FONT COLOR="FF0000"><code> | </code></FONT> which denotes that data is to be piped <I>from</I> the specified process.  You can also pipe data <I>to</I> a process by using <FONT COLOR="FF0000"><code> | </code></FONT>
as the first character.
<P>
As usual, <FONT COLOR="FF0000"><code> $. </code></FONT> is the line number.  What we can do now is terminate our 
<code>tree</code> early.  Environmentally unsound, but efficient.  
<FONT COLOR="0000FF"><PRE>
open TRIN, "tree c:\\ /a |" or die "Can't see the tree :$!";

while (&lt;TRIN&gt;) {
	printf "%3s $_", $.;
	last if $. == 10;
}
</PRE></FONT>
As soon as <FONT COLOR="FF0000"><code> $. </code></FONT> hits 10 we shut the process off by exiting the loop.  Easy.  
</P><P>
Except, maybe it won't.  What if this was a long program, and you forgot about that particular line of code which exits the loop?  Suppose that <code> $. </code> somehow went from 9 to 11, or was assigned to?  It would never reach 10.  So, to be safe

<FONT COLOR="0000FF"><PRE>
open TRIN, "tree c:\\ /a |" or die "Can't see the tree :$!";

while (&lt;TRIN&gt;) {
	printf "%3s $_", $.;
	last if $. >= 10;
}
</PRE></FONT>
exit your loops in a paranoid manner, unless you <I>really</I> mean only to exit when at line ten.  For maximum safety, maybe you should create your own counter variable because <code> $. </code> is a global variable.  I'm not necessarily advocating doing any of the above, but I am suggested these things are considered.  
</P><P>
You might notice the presence of a new keyword - <FONT COLOR="FF0000"><code> printf </code></FONT>.  It works like 
<FONT COLOR="FF0000"><code> print </code></FONT>, but <B>f</B>ormats the string before printing.  The formatting is controlled
by such parameters as <FONT COLOR="FF0000"><code> %3s </code></FONT>, which means "pad out to a total of three spaces".  After the doublequoted string comes whatever you want to be printed in the format specified.  Some examples follow.  Just uncomment each line in turn to see what it does.  There is a lot of new stuff below, but try and work out what is happening. An explanation follows after the code.
<FONT COLOR="0000FF"><PRE>
$windir=$ENV{'WINDIR'};		# yes, you can access the environment variables !

$x=0;

opendir WDIR, "$windir" or die "Can't open $windir !!! Panic : $!";

while ($file= readdir WDIR) {
	next if $file=~/^\./;		# try commenting this line to see why it is there

	$age= -M "$windir/$file";	# -M returns the age in days
	$age=~s/(\d*\.\d{3}).*/$1/;	# hmmmmm

	#### %4.4d - must take up 4 columns, and pad with 0s to make up space
	####         and minimum width is also 4
	#### %10s  - must take up 10 columns, pad with spaces
	# printf "%4.4d %10s %45s \n", $x, $age, $file;

	#### %-10s - left justify
	# printf "%4.4d %-10s %-45s \n", $x, $age, $file;

	####  %10.3 - use 10 columns, pad with 0s if less than 3 columns used
	# printf "%4.4d %10.3d %45s \n", $x, $age, $file;

	$x++;

	last if $x==15;			# we don't want to go through all the files :-)
}
</PRE></FONT>
There are some intentionally new functions there.  When you start hacking Perl (actually, you already started if you
have worked through this far) you'll see a lot of example code.  Try and understand the above, then read the explanation
below.
<P>
Firstly, all environment variables can be accessed and set via Perl.  They are in the 
<FONT COLOR="FF0000"><code> %ENV </code></FONT> hash.  If you aren't sure what environment variables are, refer to your
friendly Microsoft documentation or books. The best known environment variable is <code>path</code>, and you can see its value and that of all other environment variables by simply typing <code> set </code> at your command prompt.
<P>
The regex <FONT COLOR="FF0000"><code> /^\./ </code></FONT> bounces out invalid entries before we bother do any processing on them.  Good programming practice.  What it matches is "anything that begins with '.'".  The caret anchors the match to the beginning of the string, and as <FONT COLOR="FF0000"><code> . </code></FONT> is a metacharacter it has to be escaped.
<P>
Perl has several tests to apply on files.  The <FONT COLOR="FF0000"><code> -M </code></FONT> test returns the age in days.  See the documentation for similar tests. Note that the calls to <FONT COLOR="FF0000"><code> readdir </code></FONT> return just the file, not the complete pathname. As you were careful to use a variable for the directory to be opened rather than hardcoding it (horrors) it is no trouble to glue it together by using doublequotes.
<P>
Try commenting out <FONT COLOR="FF0000"><code> $age=~s/(\d*\.\d{3}).*/$1/ </code></FONT> and note the size of
<FONT COLOR="FF0000"><code> $age </code></FONT>.  It could do with a trim.  Just for regex practice, we make it a little smaller.  What the regex does is:
<UL>
<LI>start capturing with <FONT COLOR="FF0000"><code> ( </code></FONT>
<LI>look for 0 or more digits <FONT COLOR="FF0000"><code> \d* </code></FONT>
<LI>then a <FONT COLOR="FF0000"><code> . </code></FONT> (escaped)
<LI>followed by three digits <FONT COLOR="FF0000"><code> \d{3} </code></FONT>
<LI>and that's all we want to capture so the parens are closed. <FONT COLOR="FF0000"><code> ) </code></FONT>
<LI>Finally, everything else in the string is matched <FONT COLOR="FF0000"><code> .* </code></FONT> where
<FONT COLOR="FF0000"><code> . </code></FONT> is any character (almost) and <FONT COLOR="FF0000"><code> * </code></FONT>
0 or more.  This is pretty much guaranteed to match to the end of the line
<LI>Having matched the entire string (and put part of it into <FONT COLOR="FF0000"><code> $1 </code></FONT> by using parens)
we simply replace the string with what we have matched.
</UL>
Easy !
<P>
Mention should also be made of <FONT COLOR="FF0000"><code> sprintf </code></FONT>, which is exactly like
<FONT COLOR="FF0000"><code> printf </code></FONT> except it doesn't print.  You just use it to format strings, which
you can do something with later.  For example :
<FONT COLOR="0000FF"><PRE>
open TRIN, "tree c:\\ /a |" or die "Can't see the tree :$!";

while (&lt;TRIN&gt;) {
	$line= sprintf "%3s $_", $.;
	print $line;
	last if $. == 10;
}
</PRE></FONT>




<BR><A NAME='145-Quoteexecute'></A> <H2>Quote execute</H2>




<FONT COLOR="0000FF"><PRE>
@opts=qw(w on ad oe b);

for (@opts) {
	$result=qx(dir /$_);
	print "dir /$_ resulted in:\n$result",'-' x 79;
	sleep 1;
}
</PRE></FONT>
Anything within <FONT COLOR="FF0000"><code> qx( ) </code></FONT> is executed, and duly variable interpolated.  This sample also demonstrated <FONT COLOR="FF0000"><code> qw </code></FONT> which is 'quote words', so the elements of <code>@opts</code> are delimited by word boundaries, not the usual commas. You can also use <FONT COLOR="FF0000"><code> for </code></FONT> instead of
<FONT COLOR="FF0000"><code> foreach </code></FONT> if you want to save typing four character for the sake of legibility.
</P><P>
You may have noticed that <FONT COLOR="FF0000"><code> system </code></FONT> outputs the result of the command to the screen whereas <FONT COLOR="FF0000"><code> qx </code></FONT> does not.  Each to its own.
</P>
<BR>




<BR><A NAME='146-Oneliners'></A> <H1>Oneliners</H1>








<BR><A NAME='147-Ashortexample'></A> <H2>A short example</H2>




You'll have noticed Perl packs a lot of power into a small amount of code.  You can feed Perl code directly on the 
command line.  This is known as a oneliner, for obvious reasons.  An example:
<FONT COLOR="00AA00"><pre>
perl -e"for (55..75) { print chr($_) }"
</FONT></PRE>
The <FONT COLOR="FF0000"><code> -e </code></FONT> switch tells Perl that a command is following.  The command must be
enclosed in doublequotes, not singles as on Unix.  The command itself in this case simply prints the ASCII code for
the number 55 to 75 inclusive.
<P>




<BR><A NAME='148-Fileaccess'></A> <H2>File access</H2>




This is a simple find routine.  As it uses a regex, it is infinitely superior to NT's <code> findstr </code>:
<FONT COLOR="00AA00"><pre>
perl -e"while (&lt;&gt;) {print if /^[bv]/i}" shop.txt
</FONT></PRE>
Remember, the <FONT COLOR="FF0000"><code> while (&lt;&gt;) </code></FONT> construct will open whatever is in 
<FONT COLOR="FF0000"><code> @ARGV </code></FONT>.  In this case, we have supplied <code> shop.txt </code> so it is
opened and we print lines that begin with either 'b' or 'v'.
<P>
That can be made shorter.  Run <FONT COLOR="00AA00"><code> perl -h </code></FONT> and you'll see a whole list of switches.
The one we'll use now is <FONT COLOR="FF0000"><code> -n </code></FONT>, which puts a 
<FONT COLOR="FF0000"><code> while (&lt;&gt;) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} </code></FONT> loop around whatever code you supply with 
<FONT COLOR="FF0000"><code> -e </code></FONT>.  So:
<FONT COLOR="00AA00"><pre>
perl -ne"print if /^[bv]/i" shop.txt
</FONT></PRE>
which does exactly the same as the previous program, but uses the <FONT COLOR="FF0000"><code> -n </code></FONT>
switch to put a <FONT COLOR="FF0000"><code> while (&lt;&gt;) </code></FONT> loop around whatever other commands are supplied.
<P>
A slightly more sophisticated version:
<FONT COLOR="00AA00"><pre>
perl -ne"printf \"$ARGV : %3s : $_\",$. if /^[bv]/i" shop.txt
</PRE></FONT>
which demonstrates that doublequotes must be escaped.  
<P>




<BR><A NAME='149-ModifyingfileswithaonelinerandI'></A> <H2>Modifying files with a oneliner and $^I</H2>




If you don't remember <FONT COLOR="FF0000"><code> $^I </code></FONT> then please review the section on Files before proceeding.  When you're ready, copy <code> shop.txt </code> to <code> shop2.txt </code>.
<P>
<FONT COLOR="00AA00"><pre>
perl -i.bk -ne"printf \"%4s : $_\",$." shop2.txt
</FONT></PRE>
The <FONT COLOR="FF0000"><code> -i </code></FONT> switch primes the inplace edit operator.  We still need 
<FONT COLOR="FF0000"><code> -n </code></FONT>.  
<P>
If you had a typical quoted email message such as:
<PRE>
&gt;&gt; this is what was said
&gt;&gt; blah blah
&gt; blaaaaahhh

The new text
</PRE>
and you wanted to remove the <code>&gt;</code>, then:
<FONT COLOR="00AA00"><pre>
perl -i.bk -pe"s/^&gt;+ ?//" email.txt
</FONT></PRE>
does the trick.  Regex recap -- the caret matches what follows to the beginning of the string, the <code>+</code> means one or more (no, we do not use <code>*</code> which means 0 or more), then we will match one space with <code> \s </code>, but it is not necessary for the space to be there for the match to be successful, hence <code> ? </code>.
</P><P>
What is new in terms of oneliners is the use of <FONT COLOR="FF0000"><code> -p </code></FONT>, which does exactly the same thing as
<FONT COLOR="FF0000"><code> -n </code></FONT> except that it adds a <FONT COLOR="FF0000"><code> print </code></FONT>
statement too.  In case you were wondering why the previous example used <FONT COLOR="FF0000"><code> -n </code></FONT> and this one uses <FONT COLOR="FF0000"><code> -p </code></FONT> -- the previous example uses prints data with <FONT COLOR="FF0000"><code> printf</code></FONT></code>, whereas this example doesn't have an explicit print statement so we provide one with <FONT COLOR="FF0000"><code> -p </code></FONT>.
<P>
Some other useful oneliners -- a calculator and a ASCII number lookup:
<FONT COLOR="00AA00"><pre>
perl -e"print 50/200+2"
perl -e"for (50..90) { print chr($_) }"
</FONT></PRE>
There are plenty more oneliners, and they are an essential part of any sysadmin's toolbox.  The two examples below are functionally equivalent but the lower one is perhaps a little more readable:
<FONT COLOR="00AA00"><pre>
perl -e"for $i (50..90) { print chr($i),\" is $i\n\" }"

perl -e"for $i (50..90) { print chr($i),qq| is $i\n| }
</FONT></PRE>
Whatever follows <FONT COLOR="FF0000"><code> qq </code></FONT> is used as a delimiter, instead of    having to escape the backslash. I learnt this from the Perl-Win32-Users mailing list (see top) - I think it was Lennart Borgman who pointed it out.  He also mentioned that you don't need the closing doublequote.  Saves a little typing.
</P>




<BR><A NAME='150-SubroutinesandParameters'></A> <H1>Subroutines and Parameters</H1>





In Perl, subroutines are functions are subroutines.  If you like, a subroutine is a user defined function.  It's a bit like calling a script a program, or a program a script.  For the purposes of this tutorial we'll refer to functions as subroutines, except when we call them functions. Hope that's made the point.
</P><P>
For the purposes of this section we will develop a small program which, by the end, will demonstrate how subroutines work.  It also serves to demonstrate how many programs are built, namely a little at a time, in manageable sections.  At least, that method works for me. engines.  
</P><P>
The chosen theme is gliding.  That's aeroplanes without engines. A subject close to every glider pilot's heart is how far they can fly from the altitude they are at.  Our program will calculate this.  To make it easy we'll assume the air is perfectly calm.  Wind would be a complication we don't need, especially when in a crowded lift.
</P><P>
What we need in order to calculate the distance we can fly is:
<UL>
<LI>How high we are (in feet)
<LI>How many metres we travel forward for every metre we drop.  This is the glide ratio, for example 24:1 would mean travelling 24 metres forward for every 1 metre of height lost.  
</UL> 
</P><P>
Obviously input is needed.  We can either prompt the user or grab the input from the command line.  The latter is easier so we'll just look at <FONT COLOR="FF0000"><code> @ARGV </code></FONT> for the command line parameters.  Like so:

<FONT COLOR="0000FF"><pre>
($height,$angle)=@ARGV;		# @ARGV is the command line parameters

$distance=$height*$angle;	# an easy calculation

print "With a glide ratio of $angle:1 you can fly $distance from $height\n";
</FONT></PRE>
The above should be executed thus:
<FONT COLOR="00AA00"><pre>
perl yourscript.pl 5000 24
</FONT></PRE>
or whatever your script is called, with whatever parameters you choose to use.  I'm a poet and I don't even know it.
</P><P>
That works.  What about a slight variation? The pilot does have some control over the glide ratio, for example he can fly faster but at a penalty of a lesser glide ratio.  So we should perhaps give a couple of options either side of the given parameters:
<FONT COLOR="0000FF"><pre>
($height,$angle)=@ARGV;

$distance=$height*$angle;
print "With a glide ratio of $angle:1 you can fly $distance from $height\n";

$angle++;			# add 1 to $angle
$distance=$height*$angle;
print "With a glide ratio of $angle:1 you can fly $distance from $height\n";

$angle-=2;			# subtract 2 from $angle so it is 1 less than the original
$distance=$height*$angle;
print "With a glide ratio of $angle:1 you can fly $distance from $height\n";
</FONT></PRE>
That's cumbersome code.  We repeat exactly the same statement.  This wastes space, and if we want to change it there are three changes to be made.  A better option is to put it into a subroutine:
<FONT COLOR="0000FF"><pre>
($height,$angle)=@ARGV;

&howfar;
print "With a glide ratio of $angle:1 you can fly $distance from $height\n";

$angle++;
&howfar;
print "With a glide ratio of $angle:1 you can fly $distance from $height\n";

$angle-=2;
&howfar;
print "With a glide ratio of $angle:1 you can fly $distance from $height\n";

sub howfar {				# sub subroutinename
	$distance=$height*$angle;
}
</FONT></PRE>
This is a basic subroutine, and you could stop here and have learnt a very useful technique for programming.  Now, when changes are made they are made in one place.  Less work, less chances of errors.  Improvements can always be made.  For example, pilots outside Eastern Europe generally measure height in feet, and glider pilots are usually concerned with how many kilometres they travel over the ground.  So we can adapt our program to accept height in feet and output the distance in kilometres:
<FONT COLOR="0000FF"><pre>
($height,$angle)=@ARGV;

$height/=3.2;			# divide feet by 3.2 to get metres

&howfar;
print "With a glide ratio of $angle:1 you can fly $distance from $height\n";

$angle++;
&howfar;
print "With a glide ratio of $angle:1 you can fly $distance from $height\n";

$angle-=2;
&howfar;
print "With a glide ratio of $angle:1 you can fly $distance from $height\n";

sub howfar {
	$distance=$height*$angle;
}
</FONT></PRE>
When you run this you'll probably get a result which involves a fair few digits after the decimal point.  This is messy, and we can fix this by the <FONT COLOR="FF0000"><code> int </code></FONT> function, which in Perl and most other languages returns a number as an integer, ie without those irritating numbers after the decimal point.
</P><P>
You might have also noticed a small bit of Bad Programming Practice slipped into the last example.  It was the evil Constant, the '3.2' used to convert feet to metres.  Why, I don't hear you ask, is this bad?  Surely the conversion will never change?  
</P><P>
It won't change, but our use of it might.  We may decide that it should be 3.208 instead of 3.2.  We may decide to convert from feet to nautical miles instead.  You don't know what could happen.  Therefore, code with flexibility in mind and that means avoiding constants.
</P><P>
The new improved version with <FONT COLOR="FF0000"><code> int </code></FONT> and constant removed:
<FONT COLOR="0000FF"><pre>
($height,$ratio)=@ARGV;
$cnv1=3.2;			# now it is a variable.  Could easily be a cmd line 
				# parameter too.  We have the flexibility.
$height  =int($height/$cnv1);	# divide feet by 3.2 to get metres

&howfar;
print "With a glide ratio of $ratio:1 you can fly $distance from $height\n";

$ratio++;
&howfar;
print "With a glide ratio of $ratio:1 you can fly $distance from $height\n";

$ratio-=2;
&howfar;
print "With a glide ratio of $ratio:1 you can fly $distance from $height\n";

sub howfar {
	$distance=int($height*$ratio);
}
</FONT></PRE>
We could of course build the <FONT COLOR="FF0000"><code> print </code></FONT> statement into the subroutine, but I usually separate output presentation from the calculation.  Again, that means it is easier to modify later on.  
</P><P>
Something else we can improve about this code is the use of  the <FONT COLOR="FF0000"><code> $ratio </code></FONT> variable.  We are having to keep track of what we do to it -- first add one, then subtract two in order to subtract one from the original input.  In this case it is fairly easy, but with a complex program it can be difficult, and you don't want to be creating lots of variables just to track one input, for example <code> $ratio1 </code>, <code> $ratio2 </code> etc.
</P><P>




<BR><A NAME='151-Parameters'></A> <H2>Parameters</H2>




One solution is to pass the subroutine parameters.  In the best tradition of American columnists,  who seem to have a particular affection for this phrase, 'Here's how:'
<FONT COLOR="0000FF"><pre>
($height,$ratio)=@ARGV;
$cnv1=3.2;			

&howfar($height,$ratio);
print "With a glide ratio of $ratio:1 you can fly $distance from $height\n";

&howfar($height,$ratio+1);
print "With a glide ratio of ",$ratio+1,":1 you can fly $distance from $height\n";

&howfar($height,$ratio-1);
print "With a glide ratio of ",$ratio-1,":1 you can fly $distance from $height\n";

sub howfar {
	print "The parameters passed to this subroutine are @_\n";
	($ht,$rt)=@_;
	$ht  =int($ht/$cnv1);
	$distance=int($ht*$rt);
}
</FONT></PRE>
Quite a few things have changed here.  Firstly, the subroutine is being called with parameters.  These are a comma-delimited list in parens after the subroutine call.  The two parameters are <code> $height</code> and <code>$ratio</code>.
</P><P>
The parameters end up in the subroutine as the <FONT COLOR="FF0000"><code> @_ </code></FONT> array.  Being an array, they are in the same order as passed.  All the usual array operations work.  All we will do is assign the contents of the array to two variables.
</P><P>
We have also moved the conversion function into the subroutine, because we want to put all the code for generating the distance into one place.
</P>




<BR><A NAME='152-Namespaces'></A> <H2>Namespaces</H2>




We cannot use the variable names <code> $height </code> and <code> $ratio </code> because we modify them in the subroutine and that will affect the main program.  So we choose new ones to do the operation on.  Finally, a small change is made to the print output.
</P><P>
This approach works well enough for our small program here.  For larger programs, having to think of new variable names all the time is difficult.  It would be even more difficult if different programmers were working on different sections of the program.  It would be impossible if a program were written, then an extension created by another person somewhere else, and that same extension had to be used by many people in many different programs.  Obviously, the risk of using the same variable name is too great.  There are only so many logical names out there.
</P><P>
There is a solution. Imagine you own a house with two gardens.  You have two identical dogs, one in the front garden, one in the back garden.  Bear with me, this is relevant.  Both dogs are called Rover, because their owner lacks imagination.
</P><P>
When you go to the front garden and call 'Rover!!!' or open a can of dog food, the dog in the front garden comes running.  Similarly, you go to the back garden, call your dog and the other dog bounces up to you.
</P><P>
You have two dogs, both called Rover, and you can change either one of them.  Wash one, neuter the other -- it doesn't matter, but both are dogs and both have the same name.  Changes to one won't affect the other.  You don't get them confused because they are in different places, in two different <B>namespaces</B>.
</P><P>




<BR><A NAME='153-VariableScope'></A> <H2>Variable Scope</H2>




To bring things back to Perl, a short diversion is necessary to illustrate the point with actual Perl code instead of canine metaphors:
<FONT COLOR="0000FF"><pre>
$name='Rover';
$pet ='dog';
$age =3;

print "$name the $pet is aged $age\n";

{
	my $age =4;	  # run this again, but comment this line out
	my $name='Spot';  # and this one
	$pet    ='cat';

	print "$name the $pet is aged $age\n";
}

print "$name the $pet is aged $age\n";
</pre></FONT>
</FONT>This is pretty straightforward until we get to the <FONT COLOR="FF0000"><code> { </code></FONT>.  This marks the start of a <B>block</B>.  One feature of a block is that it can have its own namespace.  Variables declared, in other words initialised, within that block are just normal variables, unless they are declared with <FONT COLOR="FF0000"><code> my </code></FONT>.
</P><P>
When variables are declared with <FONT COLOR="FF0000"><code> my </code></FONT> they are visible inside the block only.  Also, any variable which has the same name outside the block is ignored.  Points to note from the example above:
<UL>
<LI>The two <FONT COLOR="FF0000"><code> my </code></FONT> variables appear to overwrite the variables of the same name from outside the block.
<LI>The two original variables aren't really overwritten because as we prove after the block has ended, they haven't been touched.
<LI>The variable <code>$pet</code> is accessible inside and outside the block as usual.  Of course, if we declare it with <FONT COLOR="FF0000"><code> my </code></FONT> then things will change.
</UL>




<BR><A NAME='154-myVariables'></A> <H2>my Variables</H2>




So there we have it.  Namespaces.  They work for all the other types of variable too, like arrays and hashes.  This is how you can write code and not care about what other people use for variable names -- you just declare everything with <FONT COLOR="FF0000"><code> my </code></FONT> and have your own private party.  Our original program about gliding can be improved now:
<FONT COLOR="0000FF"><pre>
($height,$ratio)=@ARGV;
$cnv1=3.2;			

&howfar($height,$ratio);
print "With a glide ratio of $ratio:1 you can fly $distance from $height\n";

&howfar($height,$ratio+1);
print "With a glide ratio of ",$ratio+1,":1 you can fly $distance from $height\n";

&howfar($height,$ratio-1);
print "With a glide ratio of ",$ratio-1,":1 you can fly $distance from $height\n";

sub howfar {
	my ($height,$ratio)=@_;
	$height  =int($height/$cnv1);
	$distance=int($height*$ratio);
}

</FONT></PRE>
The only change is that the parameters to the subroutine, ie the contents of the array <FONT COLOR="FF0000"><code> @_ </code></FONT>, are declared with
<FONT COLOR="FF0000"><code> my </code></FONT>.  This means they are now only visible within that block.  The block happens to also be a subroutine.  Outside of the block, the original variables are still accessible.  At this point I'll introduce the technical term, which is <B>lexical scoping</B>.  That means the variable is confined to the block -- it is only visible within the block.
</P><P>
We still have to be concerned with what variables we use inside the subroutine.  The variable <code>$distance</code> is created in the subroutine and used outside of it.  With larger programs this will cause exactly the same problem as before -- you have to be careful that the subroutine variables you use are the same ones as outside the subroutine.  For all the same reasons as before, like two different people working on the code and use of custom extensions to Perl, that can be difficult.
</P><P>
The obvious solution is to declare <code>$distance</code> with 
<FONT COLOR="FF0000"><code> my </code></FONT>, and thus lexically scope it.  If we do this, then how do we get the result of the subroutine?  Like so:
</P><P>
<FONT COLOR="0000FF"><pre>
($height,$ratio)=@ARGV;
$cnv1=3.2;			

$distance=&howfar($height,$ratio);  # run this again and delete '$distance='
print "With a glide ratio of $ratio:1 you can fly $distance from $height\n";

$distance=&howfar($height,$ratio+1);
print "With a glide ratio of ",$ratio+1,":1 you can fly $distance from $height\n";

$distance=&howfar($height,$ratio-1);
print "With a glide ratio of ",$ratio-1,":1 you can fly $distance from $height\n";

sub howfar {
	my ($height,$ratio)=@_;
	my $distance;
	$height  =int($height/$cnv1);
	$distance=int($height*$ratio/1000); 	# output result in kilometres not metres
}
</FONT></PRE>
First change -- <code>$distance</code> is declared with <FONT COLOR="FF0000"><code> my </code></FONT>.  Secondly, the result of the subroutine is assigned to a variable, which is also named <code>$distance</code>.  However, it is a <code>$distance</code> in a different namespace.  Remember the two gardens.  You may wish to delete the <code>$distance=</code> from the first assignment and re-run the code.  The only other change is one to change the output from meters to kilometres.
</P><P>
We have now achieved a sort of Black Box effect, where the subroutine is given input and creates output.  We pass the subroutine two numbers, which may or may not be variables.  We assign the output of the subroutine to a variable.  <B>We care not what goes on inside the subroutine, what variables it uses or what magic it performs.  This is how subroutines should operate.</B>  The only exception is the variable <code>$cnv1</code>.  This is declared in the main body of the program but also used in the subroutine.  This has been done in case we need to use the variable elsewhere.  In larger programs it would be a good idea to pass it to subroutines along with the other parameters too.
</P><P>




<BR><A NAME='155-MultipleReturns'></A> <H2>Multiple Returns</H2>




That's all the major learning out the way with.  The next step is relatively easy, but we need to add new functionality to the program in order to demonstrate it.  What we will do is work out how long it will take the glider pilot to fly the distance.  For this calculation, we need to know his airspeed.  That can be a third parameter.  The actual calculation will be part of <code> howfar</code>.  An easy change:
<FONT COLOR="0000FF"><pre>
($height,$ratio,$airspeed)=@ARGV;
$cnv1=3.2;			
$cnv2=1.8;

($distance,$time)=&howfar($height,$ratio,$airspeed);
print "Glide ratio $ratio:1, $distance from $height taking $time\n";

($distance,$time)=&howfar($height,$ratio+1,$airspeed);
print "Glide ratio ",$ratio+1,":1, $distance from $height taking $time\n";

($distance,$time)=&howfar($height,$ratio-1,$airspeed);
print "Glide ratio ",$ratio-1,":1, $distance from $height taking $time\n";

sub howfar {
	my ($height,$ratio,$airspeed)=@_;
	my ($distance,$time);			    # how to 'my' multiple variables
	$airspeed*=$cnv2;		 	    # convert knots to kmph
	$height  =int($height/$cnv1);
	$distance=int($height*$ratio/1000);
	$time	 =int($distance/($airspeed/60));    # simple time conversion
	# print "Time:$time, Distance:$distance\n"; # uncomment this later
}
</FONT></PRE>
This doesn't work correctly.  First, the changes.  The result from <code> howfar </code> is now assigned to two variables.  Subroutines return a list, and so assigning to some scalar variables between parens separated by commas will work.  This is exactly the same as reading the command line arguments from <FONT COLOR="FF0000"><code> @ARGV </code></FONT>.
</P><P>
We are also passing a new parameter, <code>$airspeed</code>.  There is a another conversion and a one-line calculation to provide the amount of minutes it will take to fly <code>$distance</code>.
</P><P>
If you look carefully, you can perhaps work out what the problem is. There was a clue in the Regex section, when <FONT COLOR="FF0000"><code> /e </code></FONT> was explained.
</P><P>
The problem is that <B>Perl returns the result of the last expression evaluated.</B>  In this case, the last expression is the one calculating <code>$time</code>, so the value <code>$time</code> is returned, and it is the only value returned.  Therefore, the value of <code>$time</code> is assigned to <code>$distance</code>, and <code>$distance</code> itself doesn't actually get a value at all.
</P><P>
Re-run the program but this time uncomment the line in the subroutine which prints <code>$distance</code> and <code>$time</code>.  You'll noticed the value is 1, which means that the expression was successful.  Perl is faithfully returning the value of the last expression evaluated.
</P><P>
This is all well and good, but not what we need.  What is required is a method of telling Perl what needs to be returned, rather than what Perl thinks would be a good idea:

<FONT COLOR="0000FF"><pre>
($height,$ratio,$airspeed)=@ARGV;
$cnv1=3.2;			
$cnv2=1.8;

($distance,$time)=&howfar($height,$ratio,$airspeed);
print "Glide ratio $ratio:1, $distance from $height taking $time\n";

($distance,$time)=&howfar($height,$ratio+1,$airspeed);
print "Glide ratio ",$ratio+1,":1, $distance from $height taking $time\n";

($distance,$time)=&howfar($height,$ratio-1,$airspeed);
print "Glide ratio ",$ratio-1,":1, $distance from $height taking $time\n";

sub howfar {
	my ($height,$ratio,$airspeed)=@_;
	my ($distance,$time);			 # how lexically scope multiple variables
	$airspeed*=$cnv2;			 # convert knots to kmph
	$height  =int($height/$cnv1);
	$distance=int($height*$ratio/1000); 	 # output result in kilometres not metres
	$time	 =int($distance/($airspeed/60)); # simple time conversion
	return ($distance,$time);		 # explicit return
}
</FONT></PRE>
A simple fix.  Now, we tell Perl what to return, with the aptly named <FONT COLOR="FF0000"><code> return </code></FONT> function.  With this function we have complete control over what is returned and when.  It is quite usual to use <FONT COLOR="FF0000"><code> if </code></FONT> statements to control different return values, but we won't bother with that here.
</P><P>
There is a subtle flaw in the program above.  It is not backwards compatible with the old method of calling the subroutine.  Run this:
<FONT COLOR="0000FF"><pre>
($height,$ratio,$airspeed)=@ARGV;
$cnv1=3.2;			
$cnv2=1.8;

($distance,$time)=&howfar($height,$ratio,$airspeed);
print "Glide ratio $ratio:1, $distance from $height taking $time\n";

($distance,$time)=&howfar($height,$ratio+1,$airspeed);
print "Glide ratio ",$ratio+1,":1, $distance from $height taking $time\n";

$distance=&howfar($height,$ratio-1);	# old way of calling it
print "With a glide ratio of ",$ratio-1,":1 you can fly $distance from $height\n";

sub howfar {
	my ($height,$ratio,$airspeed)=@_;
	my ($distance,$time);			 
	$airspeed*=$cnv2;			 
	$height  =int($height/$cnv1);
	$distance=int($height*$ratio/1000); 	 
	$time	 =int($distance/($airspeed/60)); 
	return ($distance,$time);
}
</FONT></PRE>
A division by 0 results third time around. This is of course because <code>$airspeed</code> doesn't exist, so of course it will effectively be 0.  Making your subroutines backwards compatible is important in large programs, or if you are writing an add-in module for other people to use.  You can't expect everyone to retrofit additional parameters to their subroutine calls just because you decided to be a bit creative one day.
</P><P>
There are many ways to fix the problem, and this is just one:
<FONT COLOR="0000FF"><pre>
($height,$ratio,$airspeed)=@ARGV;
$cnv1=3.2;			
$cnv2=1.8;

($distance,$time)=&howfar($height,$ratio,$airspeed);
print "Glide ratio $ratio:1, $distance from $height taking $time\n";

($distance,$time)=&howfar($height,$ratio+1,$airspeed);
print "Glide ratio ",$ratio+1,":1, $distance from $height taking $time\n";

$distance=&howfar($height,$ratio-1);
print "With a glide ratio of ",$ratio-1,":1 you can fly $distance from $height\n";

print "Direct print: ",join ",",&howfar(5000,55,60)," not bad for no engine!\n";

sub howfar {
	my ($height,$ratio,$airspeed)=@_;
	my ($distance,$time);			 # how to 'my' multiple variables
	$airspeed*=$cnv2;			 # convert knots to kmph
	$height  =int($height/$cnv1);
	$distance=int($height*$ratio/1000); 	 # output result in kilometres not metres
	if ($airspeed > 0) {
		$time	 =int($distance/($airspeed/60));
		return ($distance,$time);
	} else {
		return $distance;
	}
}
</FONT></PRE>
Here we just test the <code>$airspeed</code> to ensure we won't be doing any divisions by 0.  It also affects what we return.  There is also a new <FONT COLOR="FF0000"><code> print </code></FONT> statement, which shows that you don't need to assign to intermediate variables, or even pass variables as parameters.  Constants, evil things that they are, work just as well.  I already mentioned this, but a demonstration doesn't hurt.  Unless you work for an electric chair manufacturer.
</P><P>
The astute reader.....:-)  Every time I read that I wonder what I've missed. Usually something obscure which the author knows nobody will ever notice, but likes to belittle the reader.  No exception here!  Anyway, you may be wondering why this would not have sufficed instead of the 
<FONT COLOR="FF0000"><code> if </code></FONT> statement:
<FONT COLOR="0000FF"><pre>
sub howfar {
	my ($height,$ratio,$airspeed)=@_;
	my ($distance,$time);			 # how to 'my' multiple variables
	$airspeed*=$cnv2;			 # convert knots to kmph
	$height  =int($height/$cnv1);
	$distance=int($height*$ratio/1000); 	 # output result in kilometres not metres
	$time	 =int($distance/($airspeed/60)) if $airspeed > 0;
	return ($distance,$time);
}
</FONT></PRE>
After all, the first item returned is <code>$distance</code>, so therefore it should be the first one assigned via:
<FONT COLOR="0000FF"><pre>
$distance=&howfar($height,$ratio-1);
</FONT></PRE>
and <code>$time</code> should just disappear into the bit bucket.
</P><P>
The answer lies with scalars and lists.  We are returning a list, but assigning it to a scalar.  What happens when you do that?  The scalar takes on the <B>last value of the list</B>. The last value of the list being returned is of course <code>$time</code>, which is has been declared but not otherwise touched. Therefore, it is nothing and appears as such on the printed statement. A small program to demonstrate that point:
<FONT COLOR="0000FF"><pre>
$word=&wordfunc("Greetings");
print "The word is $word\n";

(@words)=&wordfunc("Bonjour");
print "The words are @words\n";

sub wordfunc {
my $word=shift;		# when in a subroutine, shifts @_ if no target specified
	my @words;				# how to my an array
	@words=split //,$word;			# splits on the nothings between each letter
	($first,$last)=($words[0],$words[$#words]);  # see section on Arrays if required
	return ($first,$last);			# Returns just the first and last
}
</FONT></PRE>
As you can see, the first call prints the letter 's', which is the last element of the list that is returned.  You could of course use a list consisting of just one element:
<FONT COLOR="0000FF"><pre>
($word)=&wordfunc("Greetings");
</FONT></PRE>
Now we are assigning a list to a list, so perl starts at the first element and keeps assigning till it runs out of elements.  The parens turns a lonely scalar into an element of a list.  You might consider always assigning the results of subroutines this way, as you never know when the subroutine might change. I know I've just evangelised about how subroutines shouldn't change, but if you take care and the subroutine write takes care, there definitely won't be any problems!
</P><P>
That's about it for good old <FONT COLOR="FF0000"><code> my </code></FONT>.  There is a lot more to learn about it but that's enough to get started.  You now know about a little about variable visibility, and I don't mean changeable weather.
</P><P>




<BR><A NAME='156-Local'></A> <H2>Local</H2>




There is one more function that I'd like to draw to your attention, and we'll launch straight into the demonstration:
<FONT COLOR="0000FF"><PRE>
@words=@ARGV;

print "Output Field Separator is :$,:\n";
print '1. Words:', @words, "\n";

&change;

$,='_';

print "\nOutput Field Separator is :$,:\n";
print '2. Words:', @words, "\n";

&change;

sub change {
	print '   Words:', @words, "\n";
}</PRE></FONT>
which should be executed something like this:
<FONT COLOR="00AA00"><pre>
perl test.pl sarcasm is the lowest form of wit
</PRE></FONT>
The special variable <FONT COLOR="FF0000"><code> $, </code></FONT> defines what Perl should print in between lists it is given.  By default, it is nothing. So the first two prints should have no spaces between the words.  Then we assign '_' to <FONT COLOR="FF0000"><code> $, </code></FONT> so  the next prints have underscores between the words.
<P>
If we want to use a different value for <FONT COLOR="FF0000"><code> $, </code></FONT> in the <code> change </code> subroutine, and not disturb the main value, we have a little problem.  This problem cannot be solved by <FONT COLOR="FF0000"><code> my </code></FONT> because global variables like <FONT COLOR="FF0000"><code> $, </code></FONT> cannot at this time be lexically scoped. So, we could manually do it:
<FONT COLOR="0000FF"><PRE>
@words=@ARGV;

print "Output Field Separator is :$,:\n";
print '1. Words:', @words, "\n";

&change;

$,="_";

print "\nOutput Field Separator is :$,:\n";
print '2. Words:', @words, "\n";

&change;

sub change {
	$save=$,;
	$,='*';
	print '   Words:', @words, "\n";
	$,=$save;
}
</PRE></FONT>
That works, but it is messy.  Perl has a special function for occasions of this nature, called
<FONT COLOR="FF0000"><code> local </code></FONT>.  An example of <FONT COLOR="FF0000"><code> local </code></FONT> in action:
<FONT COLOR="0000FF"><PRE>

@words=@ARGV;

print "Output Field Separator is :$,:\n";
print '1. Words:', @words, "\n";

&change;

$,="_";

print "\nOutput Field Separator is :$,:\n";
print '2. Words:', @words, "\n";

&change;

sub change {
        local $,="!-!";
	print '   Words:', @words, "\n";
}
</PRE></FONT>
You can try it with <FONT COLOR="FF0000"><code> my </code></FONT> instead but it won't work. I'm sure you'll try it anyway, I know you learn things the hard way otherwise you a) wouldn't be programming computers and b) wouldn't be using this tutorial to do it.
</P><P>
The <FONT COLOR="FF0000"><code> local </code></FONT> function works in a similar way to
<FONT COLOR="FF0000"><code> my </code></FONT>, but assigns temporary values to global variables.  The <FONT COLOR="FF0000"><code> my </code></FONT> function creates new variables that have the same name.  The distinction is important, but the reasons require perl proficiency beyond the scope of this humble tutorial.  In practice, the difference is:
<UL>
<LI>lexically scoped variables (those declared with <FONT COLOR="FF0000"><code> my </code></FONT> )are faster than non-lexically scoped variables.
<LI><FONT COLOR="FF0000"><code> local </code></FONT> variables are visible to called subroutines.
<LI><FONT COLOR="FF0000"><code> my </code></FONT> doesn't work on global variables like
<FONT COLOR="FF0000"><code> $, </code></FONT> so you must use <FONT COLOR="FF0000"><code> local </code></FONT>.
</UL>




<BR><A NAME='157-Returningarrays'></A> <H2>Returning arrays</H2>




So that's the end of subroutines and parameters. Would you believe I have only scratched the surface?  There are closures, prototypes, autoloading and references to learn.  Not, however, in this tutorial.  At least not yet.  I'll finish with one last demonstration.  You may have noticed that Perl returns one long list from subroutines.  This is fine, but suppose you want two separate lists, for example two arrays?  This is one way to do it:
<FONT COLOR="0000FF"><pre>
($w1,$w2)=&wordfunc("Hello World");	# Assign the array references to scalars

print "@$w1 and @$w2\n";		# deference, ie access, the arrays referred to
#print "$w1 and $w2\n";			# uncomment this next time round

sub wordfunc {
        my $phrase=shift;
	my (@words,@word1,@word2);	# declare three variables lexically
	@words=split /\s+/,$phrase;	# split the phrase on whitespace
	@word1=split //,$words[0];	# create array of letters from the first word
	@word2=split //,$words[1];	# and the second
	return (\@word1,\@word2);	# return references to the two arrays -- scalars
}
</FONT></PRE>
There is a lot going on there.  It should be clear up until the 
<FONT COLOR="FF0000"><code> return </code></FONT> statement.  As we know, Perl only returns a single list. So, we make Perl return a list of the arrays it has just created.  Not the actual arrays themselves, but references to the arrays.  A bit like a shopping list is a just a bit of paper, not the actual goods itself.  The reference is created by use of the
<FONT COLOR="FF0000"><code> \ </code></FONT> backslash.
</P><P>
Having returned two array references they are assigned to scalar variables.  If you uncomment the second print line you'll see two references to arrays.
</P><P>
The next problem is how to dereference the references, or access the arrays.  The construct
<FONT COLOR="FF0000"><code> @$xxx </code></FONT> does that for us.  I know I said I wouldn't cover references, and I haven't -- that is just a useful trick.
</P><P>
This little section is not designed as a complete guide, it is just a taster of things to come.  Perl is immensely powerful.  If you think something can't be done, the problem is likely to be it is beyond your ability, not that of Perl.
</P>




<BR><A NAME='158-Modules'></A> <H1>Modules</H1>








<BR><A NAME='159-Anintroduction'></A> <H2>An introduction</H2>




Subroutines are oft-used pieces of code.  They exist so you can re-use the code and not have to constantly rewrite it.
</P><P>
A module is, in principle, similar to a subroutine.  It is also an oft-used piece of code.  The difference is that modules don't live in your program, they are their own separate script outside  your code.  For example, you might write a routine to send email.  You could then use this code in ten, a hundred, a thousand different programs just by referencing the original program.
</P><P>
As you would expect, the basic Perl package includes a large number of modules.  These have been written by people who had a need for the code, made it a module and released it into the big wide world.  Many of these modules have been debugged, improved and documented by yet more people.  To quote the OpenSource mantra, all bugs are shallow under the scrutiny of every programmer. 
</P><P>
Aside from the many modules included with Perl there are hundreds more available on CPAN, the Comprehensive Perl Archive Network.  Refer to your documentation for details.
</P><P>




<BR><A NAME='160-FileFindusingamodule'></A> <H2>File::Find -- using a module</H2>




An example of a module included with Perl is <code>File::Find</code>.  There are several modules under the <code>File::Find</code> section, such as <code>File::Basetree</code>, <code>File::Compare</code> and <code>File::Stat</code>.
</P><P>
This is an example of how <code>File::Find</code> can be used:

<FONT COLOR="0000FF"><pre>
use File::Find;

$dir1='/some/dir/with/lots/of/files';
$dir2='/another/directory/';

find(\&wanted, $dir1,$dir2);

sub wanted {
	print "Found it $File::Find::dir/$_\n" if /^[a-d]/i;

}
</FONT></PRE>
The first line is the most important.  The <FONT COLOR="FF0000"><code> use </code></FONT> function loads the <code>File::Find</code> module.  Now, all the power and functionality of <code>File::Find</code> is available for use.  Such as the <code> find </code> function.  This accepts two basic parameters:
<UL>
<LI>The name of a subroutine, usually <code>wanted</code> which defines what you want to do with the list of files being returned.  The filename will be in <code>$_</code>.
<LI>A list of directories to be searched.  Subdirectories will also be searched.
</UL>
The subroutine <code>wanted</code> simply prints the directory the file was found in if the filename begins with a,b,c or d.  Make your own regex to suit.  The line <code>$File::Find::dir</code> means the <code>$dir</code> variable in the module <code>$File::Find</code>.  This is explained further in the next section.
</P><P>
Note -- the <code>\&wanted</code> parameter is a reference to a subroutine.  Essentially, this means that the code in <code>File::Find</code> knows where to find the <code>&wanted</code> subroutine.  It is basically like shortcuts under Windows 9x and NT4, instead of actual files (but the UNIX Perl people would slaughter me for that, so be quiet).
</P><P>




<BR><A NAME='161-ChangeNotify'></A> <H2>ChangeNotify</H2>




Another example is <code>Win32::ChangeNotify</code>.  As you might expect there are a number of Win32-specific modules, and ChangeNotify is one of them.  It waits until a something changes in a directory, then acts.  What it waits for and what it does are up to you, for example:
<FONT COLOR="0000FF"><pre>
use Win32::ChangeNotify;

$Path='/downloads';
$WatchSubTree=0;
$Events='FILE_NAME';
$browser='E:/progs/netscape/Communicator/program/netscape.exe';
$changes=0;

$notify = Win32::ChangeNotify->new($Path,$WatchSubTree,$Events);

while (1) {
	print "- ",scalar(localtime)," $changes so far to $Path.\n";
	$notify->wait;
	++$changes;
	print "- ",scalar(localtime), " Launching $browser...\n";
	system("$browser $Path");
	$notify->reset;
}
</FONT></PRE>
<BR>
Again, the module is incorporated into the program with <FONT COLOR="FF0000"><code> use </code></FONT>.  An object referred to by the variable <code>$notify</code> is created.  The parameters passed are the path to be watched, whether we want to watch subtrees, and what sort of events we want to be notified about, in this case only filename changes.
</P><P>
Then, we enter a loop which continues while 1 is true -- which will be forever.
</P><P>
The program pauses when the <code>wait</code> method of the <code>$notify</code> notify object is called. Only when there is a change to the directory, then the rest of the subroutine completes, launching the browser. We have to reset the <code>$notify</code> object.
</P><P>
There is some pretty frightening stuff about objects in the explanation.  But you don't actually need to understand anything about objects.  Just read the documentation, and experiment.
</P><P>
You can use as many modules as you like in one program. As they are all written with carefully scoped variables you need not worry about programmers using the same variable names in different modules.  Now you *really* appreciate scoping!
</P>




<BR><A NAME='162-YourVeryOwnModule'></A> <H2>Your Very Own Module</H2>




You too can write your own modules.  It is easy.  First, we will create the fantastic bit of code that we want to re-use everywhere.  First, we'll write a normal Perl program:
<FONT COLOR="0000FF"><pre>
$name=shift;

print &logname($name);

sub logname {
	my $name=shift;
	my @namebits;
	my ($logon,$inital);
	@namebits=split /\s+/,$name;
	($inital)=$name=~/(\w)/;
	$logon=$inital.$namebits[$#namebits];
	$logon=lc $logon;
	return $logon;
}
</FONT></PRE>
Execute like so; <FONT COLOR="FF0000"><code>perl script.pl "Nick Bladon"</code></FONT> 
</P><P>
The script itself is nothing amazing.  The <FONT COLOR="FF0000"><code> lc </code></FONT> function stands for LowerCase, or probably lOWERcASE -- you can see what it does.
</P><P>
In order to turn it into a module carry out the following steps:
<OL>
<LI>Find out where your copy of Perl is installed, for example <code>c:\progs\perl</code>.
<LI>Within that directory there should be a <code>lib</code> directory.
<LI>Make a directory within lib, for example <code>c:\progs\perl\lib\RMP\</code>
</OL>
Now we'll make the module.  Remember, a module is just code you are going to reuse.  So we don't need all of the above example.  Just this bit:
<FONT COLOR="0000FF"><pre>
sub logname {
        my $name=shift;
        my @namebits;
        my ($logon,$inital);
        @namebits=split /\s+/,$name;
        ($inital)=$name=~/(\w)/;
        $logon=$inital.$namebits[$#namebits];
        $logon=lc $logon;
        return $logon;
}

1;
</FONT></PRE>
The bit that has been added is the <code>1</code> at the bottom.  Why? Perl requires that all modules return true.  We know that a subroutine always returns the value of the last expression evaluated. As 1 evaluates to true, that'll do.
</P><P>
You need to save this as <code>logon.pm</code> in your newly created directory under <code>lib</code>.  The <code>pm</code> stands for Perl Module.
</P><P>
That's it. A module created.  To use, just make a normal Perl script such as:
<FONT COLOR="0000FF"><pre>
use RMP::logon;

$name=shift;

print logname($name);
</FONT></PRE>
and hey presto!  Module power is yours!
</P><P>
You don't have to create your own subdirectory within <code>lib</code> but I would advise it for  the sake of neatness.  And as you might expect, there is a lot more to learn about modules but this is supposed to be a basic tutorial, so that's enough for the time being.
</P>




<BR><A NAME='163-BondageandDiscipline'></A> <H1>Bondage and Discipline</H1>




Perl is a very flexible language. It is designed as a hacking tool, for quick sysadmin magic.  It can do quite a bit more besides, but being small and powerful is a core Perl feature.  Earlier on I said Perl is not a bondage and discipline language -- to qualify that, it doesn't <I>have</I> to be.  However, there is a time and place for everything.
</P><P>
For tiny scripts you don't want to be declaring variables, typecasting and generally spending more time obeying rules than you do getting the job done.  So, Perl doesn't force you to do all of these good programming practices.  However, not all your programs are going to be five-minute hacks.  Some will be pretty large.  Therefore, some Discipline is in order.
</P><P>
Perl has two primary methods of enforcing discipline.  They are:
<UL>
<LI><FONT COLOR="FF0000"><code> -w </code></FONT> for Warnings
<LI><FONT COLOR="FF0000"><code> use strict; </code></FONT> 
</UL>




<BR><A NAME='164-w'></A> <H2>-w</H2>




Consider for a moment this little program:
<FONT COLOR="0000FF"><pre>
@input=@ARGV;

$outfile='outfile.txt';
open OUT, ">$outfile" or die "Can't open $outfile for write:$!\n";

$input2++;
$delay=2 if $input[0] eq 'sleep';

sleep $delay;

print "The first element of \@input is $input[0]\n";
print OUY "Slept $delay!\n";
</FONT></PRE>
It doesn't do much. Just prints out the first argument supplied, and demonstrates the uninspiring 
<FONT COLOR="FF0000"><code> sleep </code></FONT> function.  The program itself is full of holes, and it is only a few lines.  How many errors can you spot?  Try and count them.  When you are finished, execute the program with error-checks enabled:
<FONT COLOR="00AA00"><pre>
perl -w script.pl hello
</PRE></FONT>
Perl finds quite a few errors. The <FONT COLOR="FF0000"><code> -w </code></FONT> switch finds, among other heinous sins:
<UL>
<LI>Variables used only once. In the example, <code>$input2</code> is used only once.  It is a useless variable.
<LI>Filehandles used incorrectly. With <code>print OUY</code> I'm trying to print to a non-existent filehandle. With <FONT COLOR="FF0000"><code> -w </code></FONT> an alarm is raised, as it would be if I tried to write to a filehandle which was read-only.
<LI>Use of uninitialised variables.  The variable <code>$delay</code> is uninitialised if 'sleep' is not the first parameter.  Making variables spring into the air on demand is not good programming practice. They should be defined carefully first.
</UL>
So, generally, <FONT COLOR="FF0000"><code> -w </code></FONT> is a Good Thing.  It forces you to write cleaner code.  So use it, but don't be afraid not to for very short programs.  
</P>




<BR><A NAME='165-Shebang'></A> <H3>Shebang</H3>




You know that you can turn warnings on with <FONT COLOR="FF0000"><code> -w </code></FONT> on the command line.  You can also turn them on within the script itself. For that matter, you can give perl any command line option within the script itself. For example:
<FONT COLOR="00AA00"><pre>
perl script.pl hello
</PRE></FONT>
to execute this:
<FONT COLOR="0000FF"><pre>
#!perl -w

@input=@ARGV;

$outfile='outfile.txt';
open OUT, ">$outfile" or die "Can't open $outfile for write:$!\n";

$input2++;
$delay=2 if $input[0] eq 'sleep';

sleep $delay;

print "The first element of \@input is $input[0]\n";
print OUY "Slept $delay!\n";
</FONT></PRE>
has the same effect as:
<FONT COLOR="00AA00"><pre>
perl -w script.pl hello
</PRE></FONT>
It may be more convenient for you to put the flag inside the script.  It doesn't have to be just 
<FONT COLOR="FF0000"><code> -w </code></FONT>, it can be any argument Perl supports.  Run
<FONT COLOR="00AA00"><pre>perl -h</PRE></FONT> for a full list.
</P>
The first line, <code>#!perl -w</code> is the shebang line.  This is derived from UNIX, where Perl was first developed.  UNIX systems make a script executable by changing an attribute. The operating system then loads the file and works out how to execute it -- in this case by looking at the first line, then loading the perl interpreter.  Windows systems know that all files with a certain extension must be passed to a certain program for execution, eg all <code>.bat</code> files are passed to <code>command.com</code>, and all <code>.xls</code> files are passed to Excel.  The point of all this being that you don't need a shebang line, but it doesn't hurt.
</P>




<BR><A NAME='166-usestrict'></A> <H2>use strict;</H2>




So what's strict and how do you use it?  The module <code> strict </code> restricts 'unsafe constructs', according to the perldocs.  The <code> strict </code> module is a <B>pragma</B>, which is a hint that must be obeyed.  Like when your girlfriend says 'oh, that ring is *far* too expensive'.  
</P><P>
There is no need to be frightened about unsafe code if you don't mind endless hours of debugging unstructured programs. When you enable the <code> strict </code> module, the three things that Perl becomes strict about are:
<UL>
<LI>Variables 'vars'
<LI>References 'refs'
<LI>Subroutines 'subs'
</UL>
This tutorial doesn't presently cover references (and let's hope I remember to remove this sentence if I do cover it in later versions) so we won't worry about refs.
</P><P>
Strict variables are useful.  Essentially, this means that all variables must be declared, that is defined before use rather than springing into existence as required.  Furthermore, each variable must be defined with <FONT COLOR="FF0000"><code> my </code></FONT> or fully qualified.  This is an example of a program that is not strict, and should be executed something like this:
<FONT COLOR="00AA00"><pre>
perl script.pl "Alain James Smith";
</PRE></FONT>
where the "" enclose the string as a single parameter as opposed to three separate space-delimited parameters.
<FONT COLOR="0000FF"><pre>
#use strict;			# uncomment after running a couple of times

$name=shift;			# shifts @ARGV if no arguments supplied

print "The name is $name\n";
$inis=&initials($name);

$luck=int(rand(10)) if $inis=~/^(?:[a-d]|[n-p]|[x-z])/i;

print "The initials are $inis, lucky number: $luck\n";

sub initials {
        my $name=shift;
        $initials.=$1 while $name=~/(\w)\w+\s?/g;
        return $initials;
}
</FONT></PRE>
By now you should be able to work out what the above does.  When you uncomment the
<FONT COLOR="FF0000"><code> use strict; </code></FONT> pragma, and re-run the program, you will get output something like this:
<PRE>
Global symbol "$name" requires explicit package name at n1.pl line 3.
Global symbol "$inis" requires explicit package name at n1.pl line 6.
Global symbol "$luck" requires explicit package name at n1.pl line 8.
Global symbol "$initials" requires explicit package name at n1.pl line 14.
Execution of n1.pl aborted due to compilation errors.
</PRE>
These warnings mean Perl is not exactly clear about what the scope of variables is.  If Perl is not clear, you might not be either.  So you need to be explicit about your variables, which means either declaring them with <FONT COLOR="FF0000"><code> my </code></FONT> so they are restricted to the current block, or referring to them with their fully qualified name.  An example, using both methods:
<FONT COLOR="0000FF"><pre>
use strict;

$MAIN::name=shift;			# shifts @ARGV if no arguments supplied

print "The name is ",$MAIN::name,"\n";
my $inis='';
my $luck='';

$inis=&initials($MAIN::name);

$luck=int(rand(10)) if $inis=~/^(?:[a-d]|[n-p]|[x-z])/i;

print "The initials are $inis, lucky number: $luck\n";

sub initials {
        my $name=shift;
	my $initials;
        $initials.=$1 while $name=~/(\w)\w+\s?/g;
        return $initials;
}

</FONT></PRE>
The <FONT COLOR="FF0000"><code> my </code></FONT> variables in the subroutine are nothing new.  The <FONT COLOR="FF0000"><code> my </code></FONT> variables outside the subroutine are.  If you think about it, the main program itself is also a kind of block, and therefore variables can be lexically scoped to be visible only within the block.
</P><P>
The other interesting bit is the <code>$MAIN::name</code> business.  This, as you might expect, is the fully qualified name of the variable.  The first part is the package name, in this case <code>MAIN</code>.  The second part is the actual variable name.  Personally, I've never needed to refer to a variable this way.  I'm not saying you'll never use the syntax, but I would suggest that knowing this is not on a perl students Top 10 list of Things to Master.
</P><P>
The important thing about <FONT COLOR="FF0000"><code> use strict </code></FONT> is that it does enforce more discipline than you have been used to, and for all but the smallest of programs, that is most definitely a Good Thing.
</P>

<BR><A NAME='167-Debugging'></A> <H1>Debugging</H1>

Sooner or later you'll need to do some fairly hairy debugging.  It will be later if you are using 
<FONT COLOR="FF0000"><code> strict </code></FONT>,
<FONT COLOR="FF0000"><code> -w </code></FONT> and writing your subroutines properly, but the moment will come.
</P><P>
When it does you'll be poring over code, probably late at night, wondering where the hell the problem is.  Some techniques I find useful are:
<UL>
<LI>Print your variables and other information out at frequent intervals.
<LI>Split difficult components of the program out into small, throwaway scripts.  Get these working, then copy the results back into the main program.
<LI># Comment frequently.
</UL>
Eventually, you'll be stuck.  Such is the price of progress.  In this case, Perl's own debugger can be invaluable.  Run this code as normal first:
<FONT COLOR="0000FF"><pre>
$name=shift;

print "Logon name creation program\n:Converting '$name'\n";

print &logname($name),"\n\n";

print "Program ended at", scalar(localtime),"\n";

sub logname {
        my $name=shift;
        my @namebits;
        my ($logon,$inital);
        @namebits=split /\s+/,$name;
        ($inital)=$name=~/(\w)/;
        $logon=$inital.$namebits[$#namebits];
        $logon=lc $logon;
        return $logon;
}
</FONT></PRE>
We'll run it with the debugger so you can watch perl at work while it runs:
<FONT COLOR="00AA00"><pre>
perl -d script.pl "Peter Dakin";
</PRE></FONT>
and you are into the debugger, which should look something like this:
<PRE>
c:\scripts\db.pl>perl -d db.pl "Peter Dakin"

Loading DB routines from perl5db.pl version 1.0401
Emacs support available.

Enter h or `h h' for help.

main::(<FONT COLOR="#0000FF">db.pl</FONT>:<FONT COLOR="#FF0000">1</FONT>):        <FONT COLOR="#00FF00">$name=shift;</FONT>
  DB<1>
</PRE>
<TABLE CELLSPACING=2 CELLPADDING=2 BORDER=1>
<TR>
<TD><FONT COLOR="#0000FF">db.pl</FONT></TD>
<TD>Name of script being executed</TD>
</TR><TR>
<TD><FONT COLOR="#FF0000">1</FONT></TD>
<TD>Line number of script that is just about to be executed.</TD>
</TR><TR>
<TD><FONT COLOR="#00FF00">$name=shift;</FONT></TD>
<TD>The code that is just about to be executed.</TD>
</TR>
</TABLE>
</P><P>
Type <code>s</code> for a single step and press enter.  The code <code>$name=shift;</code> will be executed, and perl waits for your next command.  Keep inputting <code>s</code> until the program terminates.
</P><P>
This by itself is useful as you see the subroutine flow, but if you enter 
<code>h</code> for help you'll see a bewildering range of debug options.  I won't detail them all here, but some of the ones I find most useful are:
<BR>
<TABLE CELLSPACING=2 CELLPADDING=2 BORDER=1>
<TR>
<TD ALIGN='center'><code> n </code></TD>
<TD>Executes main program, but skips subroutine calls.  The subroutine is executed, but you aren't stepped through it.  Try using <code> n </code> instead of <code> s </code>.
</TD>
</TR><TR>
<TD ALIGN='center'><code> /xx/ </code></TD>
<TD>Searches through program for xx
</TD>
</TR><TR>
<TD ALIGN='center'><code> p </code></TD>
<TD>Prints, for example <code>p @namebits</code>, <code>p $name</code>
</TD>
</TR><TR>
<TD ALIGN='center'><code> Enter </code></TD>
<TD>Pressing the Enter key (inputting a carriage return) repeats the last
<code> n </code> or <code> s </code> command.
</TD>
</TR><TR>
<TD ALIGN='center'><code> perlcode </code></TD>
<TD>
You can type any perl code in and it will be evaluated, and have a effect on your program.  In the example below I remove spaces from <code>$name</code>.  Inputs in <B>bold</B>:
<PRE>
main::(db.pl:1):        $name=shift;
  DB<1> <B>s</B>
main::(db.pl:3):        print "Logon name creation program\n:Converting '$name'\n";
  DB<1> <B>$name=~s/\s//g;</B>

  DB<2> <B>print $name</B>
MarkGray
  DB<3>
</PRE>
</TD>
</TR>
</TABLE>
<P>
There are many, many more debugger options which are worth becoming familiar with.  Type <code> h </code> for a full list.
</P>




<BR><A NAME='168-LogicalOperators'></A> <H1>Logical Operators</H1>




Logical operators are such things as OR, NOT, AND.  They all evaluate expressions.  The expression evaluates to true, or false.  Exactly what criteria for evaluation are used depends on the operator.




<BR><A NAME='169-or'></A> <H2>or</H2>




The <FONT COLOR="FF0000"><code> or </code></FONT> operator works as follows:
<FONT COLOR="0000FF"><pre>
open STUFF, $stuff or die "Cannot open $stuff for read :$!";
</FONT></PRE>
This line means -- if the operation for opening <code>STUFF</code> fails, then do something else. Another example:
<FONT COLOR="0000FF"><pre>
$_=shift;

/^R/ or print "Doesn't start with R\n";
</FONT></PRE>
If the regular expression is false, then whatever is on the left side of the 
<FONT COLOR="FF0000"><code> or </code></FONT> is printed.  As you know, 
<FONT COLOR="FF0000"><code> shift </code></FONT> works on
<FONT COLOR="FF0000"><code> @ARGV </code></FONT> if no target is given, or
<FONT COLOR="FF0000"><code> @_ </code></FONT> inside a subroutine.
</P><P>
Perl has two <code> OR </code> operators.  One is the now familiar 
<FONT COLOR="FF0000"><code> or </code></FONT> and the other is
<FONT COLOR="FF0000"><code> || </code></FONT>.
</P><P>

<BR><A NAME='170-PrecedenceWhatcomesFirst'></A> <H2>Precedence: What comes First</H2>


To understand the difference between the two we need to talk about precedence.  Precedence means priority, order, importance.  A good example is:
<FONT COLOR="00AA00"><pre>
perl -e"print 2+8
</FONT></PRE>
which we know equals 10.  But if we add:
<FONT COLOR="00AA00"><pre>
perl -e"print 2+8/2
</FONT></PRE>
Now, will this be 2+8 == 10, divided by 2 == 5?  Or maybe 8/2 == 4, plus 2 == 6?
</P><P>
Precedence is about what is done first.  In the example above, you can see that the division is done first, then the addition.  Therefore, division has a higher precedence that addition.
</P><P>
You can force the issue with parens:
<FONT COLOR="00AA00"><pre>
perl -e"print ((2+8)/2)
</FONT></PRE>
which forces Perl, kicking and screaming, to evaluate 2+8 then divide the result by 2.
</P><P>
So what has this to do with logical operators?  Well, the main difference between
<FONT COLOR="FF0000"><code> or </code></FONT> and
<FONT COLOR="FF0000"><code> || </code></FONT> is precedence.  
</P><P>
In the example below, we attempt to assign two variables to non-existent elements of an array.  This will fail:
<FONT COLOR="0000FF"><pre>
@list=qw(a b c);

$name1 =  $list[4] or "1-Unknown";

$name2 =  $list[4] || "2-Unknown";

print "Name1 is $name1, Name2 is $name2\n";

print "Name1 exists\n" if defined $name1;
print "Name2 exists\n" if defined $name2;

</FONT></PRE>
The output is interesting.  The variable <code>$name2</code> has been created, albeit with a false value.  However, 
<code>$name1</code> does not exist.  The reason is all about precedence.  The 
<FONT COLOR="FF0000"><code> or </code></FONT> operator has a lower precedence than 
<FONT COLOR="FF0000"><code> || </code></FONT>.  
</P><P>
This means 
<FONT COLOR="FF0000"><code> or </code></FONT> looks at the entire expression on its left hand side.  In this case, that is <code>$name1 =  $list[4] </code>.  If it is true, it gets done. If it is false, it is not and the right hand side is evaluated, and the left hand side is ignored as if it never existed.  In the example above, once the left side is found to be false, then all the right side evaluates is <code>"1-Unknown"</code> which may be true but doesn't produce any output.
</P><P>
In the case of <FONT COLOR="FF0000"><code> || </code></FONT>, which has a higher precedence, the code immediately on the left of the operator is evaluated.  In this case, that is
<code>$list[4]</code>.  This is false, so the code immediately to the right is evaluated. But, the original code on the left which was not evaluated, <code>$name2 = </code> is not forgotten.  Therefore, the expression evaluated to <code>$name2 = "2-Unknown"</code>.
</P><P>
The example below should help clarify things:
<FONT COLOR="0000FF"><pre>
@list=qw(a b c);

$ele1 = $list[4] or print "1 Failed\n";
$ele2 = $list[4] || print "2 Failed\n";

print &lt;&lt;PRT;
ele1 :$ele1:

ele2 :$ele2:

PRT
</FONT></PRE>
The two failure codes are both printed, but for different reasons. The first is printed because we are assigning <code>$ele1</code> a false value, so the result of the operation is false.  Therefore, the right hand side is evaluated.
</P><P>
The second is printed because <code>$list[4]</code> itself false. Yet, as you can see, <code>$ele2</code> exists.  Any idea why?
</P><P>
The reason is that the result of <code>print "2-Failed\n"</code> has been assigned to <code>$ele2</code>.  This is successful, and therefore returns 1.
</P><P>
Another example:
<FONT COLOR="0000FF"><pre>
$file='not-there.txt';

open FILE, $file   || print "1: Can't open file:$!\n";

open FILE, $file   or print "2: Can't open file:$!\n";

</FONT></PRE>
In the first example, the error message is not printed.  This is because <code>$file</code> is evaluating to true.  However, in the second example, 
<FONT COLOR="FF0000"><code> or </code></FONT> looks at the entire expression, not just what is immediately to the left and takes action on the result of evaluating the entire left hand side, not just the expression immediately to its left.
</P><P>
You can fix things with parens:
<FONT COLOR="0000FF"><pre>
$file='not-there.txt';

open FILE, $file   || print "1: Can't open file:$!\n";

open FILE, $file   or print "2: Can't open file:$!\n";

open (FILE, $file) || print "3: Can't open file:$!\n";

</FONT></PRE>
like so, but why bother when you have a perfectly good operator in
<FONT COLOR="FF0000"><code> or </code></FONT> ?  You could apply parens elsewhere:
<FONT COLOR="0000FF"><pre>
@list=qw(a b c);

$name1 =  $list[4]   or "1-Unknown";

($name2 =  $list[4]) || "2-Unknown";

print "Name1 is $name1, Name2 is $name2\n";

print "Name1 exists\n" if defined $name1;
print "Name2 exists\n" if defined $name2;
</FONT></PRE>
Now, <code>($name2 =  $list[4]) </code> is evaluated as a complete expression, not just as <code>$list[4]</code> is evaluated as a complete expression, not just as <code>$list[4]</code>, so we get exactly the same result as if we used 
<FONT COLOR="FF0000"><code> or </code></FONT>.


<BR><A NAME='171-And'></A> <H2>And</H2>

now for something similar.  And.  Logical AND operators evaluate two expressions, and return true only if <B>both are true</B>.  Contrast this with OR, which returns true only of <B>one or more</B> of the two expressions are true.  Perl has a few AND operators.
</P><P>
The first type of AND we will look at is <FONT COLOR="FF0000"><code> && </code></FONT>:
<FONT COLOR="0000FF"><pre>
@list=qw(a b c);

print "List is:@list\n";

if ($list[0] eq 'x' && $list[2]++ eq 'd') {
	print "True\n";
	} else {
	print "False\n";
}

print "List is:@list\n";
</FONT></PRE>
The output here is false.  It is clear that <code>$list[0]</code> does not equal <code> x </code>. As AND statements can only return true if both expressions being evaluated are true, then as the first statement is false this is an obvious non-starter and perl decides it need not continue to the second statement. Entirely sensible.
</P><P>
The second type of AND statement is <FONT COLOR="FF0000"><code> & </code></FONT>.  This is similar to <FONT COLOR="FF0000"><code> && </code></FONT>.  See if you can work out what the difference is using this example:
<FONT COLOR="0000FF"><pre>
@list=qw(a b c);

print "List is:@list\n";

if ($list[0] eq 'x' & $list[2]++ eq 'd') {
	print "True\n";
	} else {
	print "False\n";
}

print "List is:@list\n";
</FONT></PRE>
The difference is that the second part of the expression is evaluated no matter what the result of the first part is.  Despite the fact that the AND statement cannot possibly return true, perl goes ahead and evaluates the second part of the statement anyway, hence <code>$list[2]</code> ends up as <code> d </code>.
</P><P>
The third AND which we will look at is <FONT COLOR="FF0000"><code> and </code></FONT>.  This behaves in the same way as <FONT COLOR="FF0000"><code> && </code></FONT> but is lower precedence.   Therefore, all the guidelines about <FONT COLOR="FF0000"><code> || </code></FONT> and 
<FONT COLOR="FF0000"><code> or </code></FONT> apply.

<BR><A NAME='172-OtherLogicalOperators'></A> <H2>Other Logical Operators</H2>

Perl has <FONT COLOR="FF0000"><code> not </code></FONT>, which works like
<FONT COLOR="FF0000"><code> ! </code></FONT> except for low precedence.  If you are wondering where you have seen <FONT COLOR="FF0000"><code> ! </code></FONT> before, what about:
<FONT COLOR="0000FF"><pre>
$x !~/match/;

if ($t != 5) {
</FONT></PRE>
as two examples.  There is also Exclusive OR, or XOR.  This means:
<UL>
<LI>If one expression is true, XOR returns true
<LI>If both expressions are false, XOR returns false
<LI>If both expressions are true, XOR returns false (the crucial difference from OR)
</UL>
This needs an example.  Jane and Sonia are two known troublemakers, with a reputation for throwing good beer around, going topless at inappropriate moments and singing out of tune to the karaoke machine.  You only want to let one of them into your party, and instead of a big muscle-bound bouncer you have this perl script on the door:
<FONT COLOR="0000FF"><pre>
($name1,$name2)=@ARGV;

if ($name1 eq 'Jane' xor $name2 eq 'Sonia') {
	print "OK, allowed\n";
} else {
	print "Sorry, not allowed\n";
}
</FONT></PRE>
I would suggest running it thus:
<FONT COLOR="00AA00"><pre>perl script.pl Jane Karen </PRE></FONT> (one true, one false)<BR>
<FONT COLOR="00AA00"><pre>perl script.pl Jim Sonia </PRE></FONT> (one true, one false)<BR>
<FONT COLOR="00AA00"><pre>perl script.pl Jane Sonia </PRE></FONT> (both true)<BR>
<FONT COLOR="00AA00"><pre>perl script.pl Jim Sam </PRE></FONT> (both false)<BR>
<P>
Well, the script is not perfect as a doorman, as all Jane and Sonia have to do is type their names in lowercase, but hopefully it demonstrated <FONT COLOR="FF0000"><code> xor </code></FONT>. 
</P><P>
One thing to beware of is:
<FONT COLOR="0000FF"><pre>
$_=shift;

print "OK\n" unless not(!/r/i || /o/i & /p/ or /q/);
</FONT></PRE>
over-complication, and believe me the above is not as complicated as it could be. Take the time to understand what you want to do.  Perl provides a plethora of logical operands so you really don't have any excuse for not writing legible code.  The above can be written a lot more concisely and clearly.  As well as a lot more obscurely :-)

<FONT COLOR="0000FF"><pre>
</FONT></PRE>
<FONT COLOR="FF0000"><code> @ARGV </code></FONT> 

<BR><A NAME='173-Lastwords'></A> <H1>Last words</H1>

I hope you have enjoyed this tutorial and learnt something from it.  I would appreciate an email letting me know how it could be improved.  What you have learnt is just a fraction of Perl's functionality, but you'll find skills like regexes can be applied in many other places than Perl.  
<P>
Good luck.<BR>
<PRE>
--
Robert
</PRE>

<BR><A NAME='174-Thanksto'></A> <H1>Thanks to...</H1>

Everyone that helped in the development of this tutorial.  I do read all the feedback emails, but don't always action them the same year.  What you have just read is better because of the people below. They fix the bugs, scream when they don't understand and I rewrite whole sections. Documents like this are written by the authors, but polished by the readers.
<P>
The roll of honour is, in a semi-chronological order:
<BR>
<UL>
<LI><B>Mark Miller</B> for his long email suggesting improvements and highlighting typos. I cringed when I realised what I'd let through :-(
<LI><B>Roland</B> to whom I am eternally grateful for sending in many typo reports, and pointing out where he didn't understand an explanation.
<LI>
<B><A HREF="http://ourworld.compuserve.com/homepages/media_vision/">Katya
de Vries</A>  </B> for finding HTML errors and problems with the example code.<BR>
<LI>
<B>Steven Ham</B> for being picky about spelling errors. Good going, considering
English is his second language !<BR>
<LI><B>Carlos Jaramillo Uribe</B> for pointing out where
I could have explained postincrements and regex a little better and for pointing out a typo or two.
<LI><B>Sergio Polini</B> who brought an interesting aspect Perl's behaviour with arrays to my attention, and helping to improve parts of the Regex section.
<LI><B>Leo Durocher</B> for telling me he had trouble with the regex section.  If he did, I'm sure many others did too.
<LI><B>Paul Trafford</B> for solving the Them/Us problem I was too lazy to bother with, and doing it so elegantly.
<LI><B>Eric Smith</B> who was one of many people who <I>made</I> me a table of contents rather than just tell me I should include one.  I never used any of them, and the one you see now is auto-generated by a program written in Java (only kidding, its not auto-generated :-)
<LI><B>Mike Conkin</B> who said he didn't understand $^I.  Good point. I'd forgotten to explain it at all.  Mike went to list several other areas I could do with improving in one of the most amusing and useful missives I've had on the tutorial.  Thanks.
<LI><B><A HREF="http://www.chez.com/vasile/">Vasile Calamuti</A></B> who picked up on my use of <code>join</code> before I'd explained it, and a couple more oversights.
<LI><B>Didier Owono</B> for pointing out my original explanation of <code> /ee </code> didn't make sense. Hopefully the second version does.
<LI><B>Keen Meng Lew</B> and <B>Ever Olano</B> who, independently (I assume) picked up exactly the same two typos.  Which are now fixed.
<LI><B>Anna in Ohio</B> who sent a polite email with a few errors she picked up on. 
<LI><B>Ken Teuchler</B> for knowing the difference between <code> = </code> and <code>=~</code>, and for his long list of improvements which varied from grammar errors to style suggestions to oversights.  A huge help.
<LI><B>cookie</B>, firstly for his Win9x experiments and error checks about my explanation of scoping.  Secondly for his many subsequent emails pointing out minor problems which elevated him to status of #1 bugfixer. Appreciated.
<LI><B>Ginny</B> for spotting an errant ; which in the best tradition of teachers I have changed into an exercise for debugging, of course I meant to leave it out in the first place.  I should also point out that a major motivation for me do put the effort into this tutorial is the appreciation of the userbase, and Ginny sent me a particularly motivational missive.
<LI><B>Jeffery Jackson</B> for noticing my error about 0-based arrays.
<LI><B>Kevin Haskins</B> for pointing out Notepad's limitations and an equality issue.
<LI><B><A HREF="http://u1.netgate.net/~pmccarthy/">Pat McCarthy</A></B> for picking up a small typo.
<LI><B>Bob Kauten</B> who noticed that I hadn't explained the range operator properly. I blame....well, me really.
<LI><B>Ayhan Tuncer</B> for picking up a mistake where I'd carelessly cut and pasted pasted pasted.  The next day <B>Michael Kersey</B> found the exact same error, before I'd had a chance to fix it.
Ayhan also found quite a few more errors after that one during her work on the Turkish translation.
<LI><B>Ray Price</B> who was another one who found the above error, and a couple more typos as well.
<LI><B>Henry Vermeulen</B>, a Dutch chap who noticed I'd mispelled Heineken.  Nothing to do with Perl, just one of my outlandish examples.
<LI><B>Everyone that has ever worked on perl</B>, all the hackers on the <B>perl-win32*</B> mailing lists, <B>ActiveState</B> and the netizens of <B>clpm</B>.
</UL>
<P>
<CENTER>The original location of this document is:<BR><B>http://www.netcat.co.uk/rob/perl/win32perltut.html</B></CENTER>
<P>
<HR><FONT COLOR="#FF0000"><B>
This tutorial is copyright 1997, 1998, 1999 by Robert Pepper.  Reproduction in whole or part is prohibited.  Please contact me if you want to use this information anywhere.  Thank you.</B></FONT>
<BR>--<BR>
<A HREF="/rob/">Robert Pepper</A>&nbsp;&nbsp;&nbsp;&nbsp;
<A HREF="mailto:robert@netcat.co.uk">mailto:Robert@netcat.co.uk</A>
<BR>
<HR>
</BODY>
</HTML>
